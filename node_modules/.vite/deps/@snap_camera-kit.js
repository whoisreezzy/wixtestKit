var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js
var require_grpc_web_client_umd = __commonJS({
  "node_modules/@improbable-eng/grpc-web/dist/grpc-web-client.umd.js"(exports, module) {
    !function(e2, t2) {
      if ("object" == typeof exports && "object" == typeof module) module.exports = t2();
      else if ("function" == typeof define && define.amd) define([], t2);
      else {
        var r2 = t2();
        for (var n2 in r2) ("object" == typeof exports ? exports : e2)[n2] = r2[n2];
      }
    }(exports, function() {
      return e2 = { 418: function(e3, t3) {
        !function(e4, t4) {
          for (var r2 in t4) e4[r2] = t4[r2];
        }(t3, function(e4) {
          var t4 = {};
          function r2(n2) {
            if (t4[n2]) return t4[n2].exports;
            var o = t4[n2] = { i: n2, l: false, exports: {} };
            return e4[n2].call(o.exports, o, o.exports, r2), o.l = true, o.exports;
          }
          return r2.m = e4, r2.c = t4, r2.i = function(e5) {
            return e5;
          }, r2.d = function(e5, t5, n2) {
            r2.o(e5, t5) || Object.defineProperty(e5, t5, { configurable: false, enumerable: true, get: n2 });
          }, r2.n = function(e5) {
            var t5 = e5 && e5.__esModule ? function() {
              return e5.default;
            } : function() {
              return e5;
            };
            return r2.d(t5, "a", t5), t5;
          }, r2.o = function(e5, t5) {
            return Object.prototype.hasOwnProperty.call(e5, t5);
          }, r2.p = "", r2(r2.s = 1);
        }([function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(3), o = function() {
            function e5(e6, t5) {
              void 0 === e6 && (e6 = {}), void 0 === t5 && (t5 = { splitValues: false });
              var r3, o2 = this;
              this.headersMap = {}, e6 && ("undefined" != typeof Headers && e6 instanceof Headers ? n2.getHeaderKeys(e6).forEach(function(r4) {
                n2.getHeaderValues(e6, r4).forEach(function(e7) {
                  t5.splitValues ? o2.append(r4, n2.splitHeaderValue(e7)) : o2.append(r4, e7);
                });
              }) : "object" == typeof (r3 = e6) && "object" == typeof r3.headersMap && "function" == typeof r3.forEach ? e6.forEach(function(e7, t6) {
                o2.append(e7, t6);
              }) : "undefined" != typeof Map && e6 instanceof Map ? e6.forEach(function(e7, t6) {
                o2.append(t6, e7);
              }) : "string" == typeof e6 ? this.appendFromString(e6) : "object" == typeof e6 && Object.getOwnPropertyNames(e6).forEach(function(t6) {
                var r4 = e6[t6];
                Array.isArray(r4) ? r4.forEach(function(e7) {
                  o2.append(t6, e7);
                }) : o2.append(t6, r4);
              }));
            }
            return e5.prototype.appendFromString = function(e6) {
              for (var t5 = e6.split("\r\n"), r3 = 0; r3 < t5.length; r3++) {
                var n3 = t5[r3], o2 = n3.indexOf(":");
                if (o2 > 0) {
                  var s2 = n3.substring(0, o2).trim(), i = n3.substring(o2 + 1).trim();
                  this.append(s2, i);
                }
              }
            }, e5.prototype.delete = function(e6, t5) {
              var r3 = n2.normalizeName(e6);
              if (void 0 === t5) delete this.headersMap[r3];
              else {
                var o2 = this.headersMap[r3];
                if (o2) {
                  var s2 = o2.indexOf(t5);
                  s2 >= 0 && o2.splice(s2, 1), 0 === o2.length && delete this.headersMap[r3];
                }
              }
            }, e5.prototype.append = function(e6, t5) {
              var r3 = this, o2 = n2.normalizeName(e6);
              Array.isArray(this.headersMap[o2]) || (this.headersMap[o2] = []), Array.isArray(t5) ? t5.forEach(function(e7) {
                r3.headersMap[o2].push(n2.normalizeValue(e7));
              }) : this.headersMap[o2].push(n2.normalizeValue(t5));
            }, e5.prototype.set = function(e6, t5) {
              var r3 = n2.normalizeName(e6);
              if (Array.isArray(t5)) {
                var o2 = [];
                t5.forEach(function(e7) {
                  o2.push(n2.normalizeValue(e7));
                }), this.headersMap[r3] = o2;
              } else this.headersMap[r3] = [n2.normalizeValue(t5)];
            }, e5.prototype.has = function(e6, t5) {
              var r3 = this.headersMap[n2.normalizeName(e6)];
              if (!Array.isArray(r3)) return false;
              if (void 0 !== t5) {
                var o2 = n2.normalizeValue(t5);
                return r3.indexOf(o2) >= 0;
              }
              return true;
            }, e5.prototype.get = function(e6) {
              var t5 = this.headersMap[n2.normalizeName(e6)];
              return void 0 !== t5 ? t5.concat() : [];
            }, e5.prototype.forEach = function(e6) {
              var t5 = this;
              Object.getOwnPropertyNames(this.headersMap).forEach(function(r3) {
                e6(r3, t5.headersMap[r3]);
              }, this);
            }, e5.prototype.toHeaders = function() {
              if ("undefined" != typeof Headers) {
                var e6 = new Headers();
                return this.forEach(function(t5, r3) {
                  r3.forEach(function(r4) {
                    e6.append(t5, r4);
                  });
                }), e6;
              }
              throw new Error("Headers class is not defined");
            }, e5;
          }();
          t4.BrowserHeaders = o;
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(0);
          t4.BrowserHeaders = n2.BrowserHeaders;
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true }), t4.iterateHeaders = function(e5, t5) {
            for (var r3 = e5[Symbol.iterator](), n2 = r3.next(); !n2.done; ) t5(n2.value[0]), n2 = r3.next();
          }, t4.iterateHeadersKeys = function(e5, t5) {
            for (var r3 = e5.keys(), n2 = r3.next(); !n2.done; ) t5(n2.value), n2 = r3.next();
          };
        }, function(e4, t4, r2) {
          "use strict";
          Object.defineProperty(t4, "__esModule", { value: true });
          var n2 = r2(2);
          t4.normalizeName = function(e5) {
            if ("string" != typeof e5 && (e5 = String(e5)), /[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(e5)) throw new TypeError("Invalid character in header field name");
            return e5.toLowerCase();
          }, t4.normalizeValue = function(e5) {
            return "string" != typeof e5 && (e5 = String(e5)), e5;
          }, t4.getHeaderValues = function(e5, t5) {
            var r3 = e5;
            if (r3 instanceof Headers && r3.getAll) return r3.getAll(t5);
            var n3 = r3.get(t5);
            return n3 && "string" == typeof n3 ? [n3] : n3;
          }, t4.getHeaderKeys = function(e5) {
            var t5 = e5, r3 = {}, o = [];
            return t5.keys ? n2.iterateHeadersKeys(t5, function(e6) {
              r3[e6] || (r3[e6] = true, o.push(e6));
            }) : t5.forEach ? t5.forEach(function(e6, t6) {
              r3[t6] || (r3[t6] = true, o.push(t6));
            }) : n2.iterateHeaders(t5, function(e6) {
              var t6 = e6[0];
              r3[t6] || (r3[t6] = true, o.push(t6));
            }), o;
          }, t4.splitHeaderValue = function(e5) {
            var t5 = [];
            return e5.split(", ").forEach(function(e6) {
              e6.split(",").forEach(function(e7) {
                t5.push(e7);
              });
            }), t5;
          };
        }]));
      }, 617: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.ChunkParser = t3.ChunkType = t3.encodeASCII = t3.decodeASCII = void 0;
        var n2, o = r2(65);
        function s2(e4) {
          return 9 === (t4 = e4) || 10 === t4 || 13 === t4 || e4 >= 32 && e4 <= 126;
          var t4;
        }
        function i(e4) {
          for (var t4 = 0; t4 !== e4.length; ++t4) if (!s2(e4[t4])) throw new Error("Metadata is not valid (printable) ASCII");
          return String.fromCharCode.apply(String, Array.prototype.slice.call(e4));
        }
        function a2(e4) {
          return 128 == (128 & e4.getUint8(0));
        }
        function u2(e4) {
          return e4.getUint32(1, false);
        }
        function d2(e4, t4, r3) {
          return e4.byteLength - t4 >= r3;
        }
        function c2(e4, t4, r3) {
          if (e4.slice) return e4.slice(t4, r3);
          var n3 = e4.length;
          void 0 !== r3 && (n3 = r3);
          for (var o2 = new Uint8Array(n3 - t4), s3 = 0, i2 = t4; i2 < n3; i2++) o2[s3++] = e4[i2];
          return o2;
        }
        t3.decodeASCII = i, t3.encodeASCII = function(e4) {
          for (var t4 = new Uint8Array(e4.length), r3 = 0; r3 !== e4.length; ++r3) {
            var n3 = e4.charCodeAt(r3);
            if (!s2(n3)) throw new Error("Metadata contains invalid ASCII");
            t4[r3] = n3;
          }
          return t4;
        }, function(e4) {
          e4[e4.MESSAGE = 1] = "MESSAGE", e4[e4.TRAILERS = 2] = "TRAILERS";
        }(n2 = t3.ChunkType || (t3.ChunkType = {}));
        var p2 = function() {
          function e4() {
            this.buffer = null, this.position = 0;
          }
          return e4.prototype.parse = function(e5, t4) {
            if (0 === e5.length && t4) return [];
            var r3, s3 = [];
            if (null == this.buffer) this.buffer = e5, this.position = 0;
            else if (this.position === this.buffer.byteLength) this.buffer = e5, this.position = 0;
            else {
              var p3 = this.buffer.byteLength - this.position, h2 = new Uint8Array(p3 + e5.byteLength), f3 = c2(this.buffer, this.position);
              h2.set(f3, 0);
              var l2 = new Uint8Array(e5);
              h2.set(l2, p3), this.buffer = h2, this.position = 0;
            }
            for (; ; ) {
              if (!d2(this.buffer, this.position, 5)) return s3;
              var g = c2(this.buffer, this.position, this.position + 5), b2 = new DataView(g.buffer, g.byteOffset, g.byteLength), y2 = u2(b2);
              if (!d2(this.buffer, this.position, 5 + y2)) return s3;
              var v2 = c2(this.buffer, this.position + 5, this.position + 5 + y2);
              if (this.position += 5 + y2, a2(b2)) return s3.push({ chunkType: n2.TRAILERS, trailers: (r3 = v2, new o.Metadata(i(r3))) }), s3;
              s3.push({ chunkType: n2.MESSAGE, data: v2 });
            }
          }, e4;
        }();
        t3.ChunkParser = p2;
      }, 8: function(e3, t3) {
        "use strict";
        var r2;
        Object.defineProperty(t3, "__esModule", { value: true }), t3.httpStatusToCode = t3.Code = void 0, function(e4) {
          e4[e4.OK = 0] = "OK", e4[e4.Canceled = 1] = "Canceled", e4[e4.Unknown = 2] = "Unknown", e4[e4.InvalidArgument = 3] = "InvalidArgument", e4[e4.DeadlineExceeded = 4] = "DeadlineExceeded", e4[e4.NotFound = 5] = "NotFound", e4[e4.AlreadyExists = 6] = "AlreadyExists", e4[e4.PermissionDenied = 7] = "PermissionDenied", e4[e4.ResourceExhausted = 8] = "ResourceExhausted", e4[e4.FailedPrecondition = 9] = "FailedPrecondition", e4[e4.Aborted = 10] = "Aborted", e4[e4.OutOfRange = 11] = "OutOfRange", e4[e4.Unimplemented = 12] = "Unimplemented", e4[e4.Internal = 13] = "Internal", e4[e4.Unavailable = 14] = "Unavailable", e4[e4.DataLoss = 15] = "DataLoss", e4[e4.Unauthenticated = 16] = "Unauthenticated";
        }(r2 = t3.Code || (t3.Code = {})), t3.httpStatusToCode = function(e4) {
          switch (e4) {
            case 0:
              return r2.Internal;
            case 200:
              return r2.OK;
            case 400:
              return r2.InvalidArgument;
            case 401:
              return r2.Unauthenticated;
            case 403:
              return r2.PermissionDenied;
            case 404:
              return r2.NotFound;
            case 409:
              return r2.Aborted;
            case 412:
              return r2.FailedPrecondition;
            case 429:
              return r2.ResourceExhausted;
            case 499:
              return r2.Canceled;
            case 500:
              return r2.Unknown;
            case 501:
              return r2.Unimplemented;
            case 503:
              return r2.Unavailable;
            case 504:
              return r2.DeadlineExceeded;
            default:
              return r2.Unknown;
          }
        };
      }, 934: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.client = void 0;
        var n2 = r2(65), o = r2(617), s2 = r2(8), i = r2(346), a2 = r2(57), u2 = r2(882);
        t3.client = function(e4, t4) {
          return new d2(e4, t4);
        };
        var d2 = function() {
          function e4(e5, t4) {
            this.started = false, this.sentFirstMessage = false, this.completed = false, this.closed = false, this.finishedSending = false, this.onHeadersCallbacks = [], this.onMessageCallbacks = [], this.onEndCallbacks = [], this.parser = new o.ChunkParser(), this.methodDefinition = e5, this.props = t4, this.createTransport();
          }
          return e4.prototype.createTransport = function() {
            var e5 = this.props.host + "/" + this.methodDefinition.service.serviceName + "/" + this.methodDefinition.methodName, t4 = { methodDefinition: this.methodDefinition, debug: this.props.debug || false, url: e5, onHeaders: this.onTransportHeaders.bind(this), onChunk: this.onTransportChunk.bind(this), onEnd: this.onTransportEnd.bind(this) };
            this.props.transport ? this.transport = this.props.transport(t4) : this.transport = a2.makeDefaultTransport(t4);
          }, e4.prototype.onTransportHeaders = function(e5, t4) {
            if (this.props.debug && i.debug("onHeaders", e5, t4), this.closed) this.props.debug && i.debug("grpc.onHeaders received after request was closed - ignoring");
            else if (0 === t4) ;
            else {
              this.responseHeaders = e5, this.props.debug && i.debug("onHeaders.responseHeaders", JSON.stringify(this.responseHeaders, null, 2));
              var r3 = c2(e5);
              this.props.debug && i.debug("onHeaders.gRPCStatus", r3);
              var n3 = r3 && r3 >= 0 ? r3 : s2.httpStatusToCode(t4);
              this.props.debug && i.debug("onHeaders.code", n3);
              var o2 = e5.get("grpc-message") || [];
              if (this.props.debug && i.debug("onHeaders.gRPCMessage", o2), this.rawOnHeaders(e5), n3 !== s2.Code.OK) {
                var a3 = this.decodeGRPCStatus(o2[0]);
                this.rawOnError(n3, a3, e5);
              }
            }
          }, e4.prototype.onTransportChunk = function(e5) {
            var t4 = this;
            if (this.closed) this.props.debug && i.debug("grpc.onChunk received after request was closed - ignoring");
            else {
              var r3 = [];
              try {
                r3 = this.parser.parse(e5);
              } catch (e6) {
                return this.props.debug && i.debug("onChunk.parsing error", e6, e6.message), void this.rawOnError(s2.Code.Internal, "parsing error: " + e6.message);
              }
              r3.forEach(function(e6) {
                if (e6.chunkType === o.ChunkType.MESSAGE) {
                  var r4 = t4.methodDefinition.responseType.deserializeBinary(e6.data);
                  t4.rawOnMessage(r4);
                } else e6.chunkType === o.ChunkType.TRAILERS && (t4.responseHeaders ? (t4.responseTrailers = new n2.Metadata(e6.trailers), t4.props.debug && i.debug("onChunk.trailers", t4.responseTrailers)) : (t4.responseHeaders = new n2.Metadata(e6.trailers), t4.rawOnHeaders(t4.responseHeaders)));
              });
            }
          }, e4.prototype.onTransportEnd = function() {
            if (this.props.debug && i.debug("grpc.onEnd"), this.closed) this.props.debug && i.debug("grpc.onEnd received after request was closed - ignoring");
            else if (void 0 !== this.responseTrailers) {
              var e5 = c2(this.responseTrailers);
              if (null !== e5) {
                var t4 = this.responseTrailers.get("grpc-message"), r3 = this.decodeGRPCStatus(t4[0]);
                this.rawOnEnd(e5, r3, this.responseTrailers);
              } else this.rawOnError(s2.Code.Internal, "Response closed without grpc-status (Trailers provided)");
            } else {
              if (void 0 === this.responseHeaders) return void this.rawOnError(s2.Code.Unknown, "Response closed without headers");
              var n3 = c2(this.responseHeaders), o2 = this.responseHeaders.get("grpc-message");
              if (this.props.debug && i.debug("grpc.headers only response ", n3, o2), null === n3) return void this.rawOnEnd(s2.Code.Unknown, "Response closed without grpc-status (Headers only)", this.responseHeaders);
              var a3 = this.decodeGRPCStatus(o2[0]);
              this.rawOnEnd(n3, a3, this.responseHeaders);
            }
          }, e4.prototype.decodeGRPCStatus = function(e5) {
            if (!e5) return "";
            try {
              return decodeURIComponent(e5);
            } catch (t4) {
              return e5;
            }
          }, e4.prototype.rawOnEnd = function(e5, t4, r3) {
            var n3 = this;
            this.props.debug && i.debug("rawOnEnd", e5, t4, r3), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(o2) {
              if (!n3.closed) try {
                o2(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            }));
          }, e4.prototype.rawOnHeaders = function(e5) {
            this.props.debug && i.debug("rawOnHeaders", e5), this.completed || this.onHeadersCallbacks.forEach(function(t4) {
              try {
                t4(e5);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            });
          }, e4.prototype.rawOnError = function(e5, t4, r3) {
            var o2 = this;
            void 0 === r3 && (r3 = new n2.Metadata()), this.props.debug && i.debug("rawOnError", e5, t4), this.completed || (this.completed = true, this.onEndCallbacks.forEach(function(n3) {
              if (!o2.closed) try {
                n3(e5, t4, r3);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            }));
          }, e4.prototype.rawOnMessage = function(e5) {
            var t4 = this;
            this.props.debug && i.debug("rawOnMessage", e5.toObject()), this.completed || this.closed || this.onMessageCallbacks.forEach(function(r3) {
              if (!t4.closed) try {
                r3(e5);
              } catch (e6) {
                setTimeout(function() {
                  throw e6;
                }, 0);
              }
            });
          }, e4.prototype.onHeaders = function(e5) {
            this.onHeadersCallbacks.push(e5);
          }, e4.prototype.onMessage = function(e5) {
            this.onMessageCallbacks.push(e5);
          }, e4.prototype.onEnd = function(e5) {
            this.onEndCallbacks.push(e5);
          }, e4.prototype.start = function(e5) {
            if (this.started) throw new Error("Client already started - cannot .start()");
            this.started = true;
            var t4 = new n2.Metadata(e5 || {});
            t4.set("content-type", "application/grpc-web+proto"), t4.set("x-grpc-web", "1"), this.transport.start(t4);
          }, e4.prototype.send = function(e5) {
            if (!this.started) throw new Error("Client not started - .start() must be called before .send()");
            if (this.closed) throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending) throw new Error("Client already finished sending - cannot .send()");
            if (!this.methodDefinition.requestStream && this.sentFirstMessage) throw new Error("Message already sent for non-client-streaming method - cannot .send()");
            this.sentFirstMessage = true;
            var t4 = u2.frameRequest(e5);
            this.transport.sendMessage(t4);
          }, e4.prototype.finishSend = function() {
            if (!this.started) throw new Error("Client not started - .finishSend() must be called before .close()");
            if (this.closed) throw new Error("Client already closed - cannot .send()");
            if (this.finishedSending) throw new Error("Client already finished sending - cannot .finishSend()");
            this.finishedSending = true, this.transport.finishSend();
          }, e4.prototype.close = function() {
            if (!this.started) throw new Error("Client not started - .start() must be called before .close()");
            if (this.closed) throw new Error("Client already closed - cannot .close()");
            this.closed = true, this.props.debug && i.debug("request.abort aborting request"), this.transport.cancel();
          }, e4;
        }();
        function c2(e4) {
          var t4 = e4.get("grpc-status") || [];
          if (t4.length > 0) try {
            var r3 = t4[0];
            return parseInt(r3, 10);
          } catch (e5) {
            return null;
          }
          return null;
        }
      }, 346: function(e3, t3) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.debug = void 0, t3.debug = function() {
          for (var e4 = [], t4 = 0; t4 < arguments.length; t4++) e4[t4] = arguments[t4];
          console.debug ? console.debug.apply(null, e4) : console.log.apply(null, e4);
        };
      }, 607: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.grpc = void 0;
        var n2, o = r2(418), s2 = r2(57), i = r2(229), a2 = r2(540), u2 = r2(210), d2 = r2(859), c2 = r2(8), p2 = r2(938), h2 = r2(35), f3 = r2(934);
        (n2 = t3.grpc || (t3.grpc = {})).setDefaultTransport = s2.setDefaultTransportFactory, n2.CrossBrowserHttpTransport = d2.CrossBrowserHttpTransport, n2.FetchReadableStreamTransport = i.FetchReadableStreamTransport, n2.XhrTransport = u2.XhrTransport, n2.WebsocketTransport = a2.WebsocketTransport, n2.Code = c2.Code, n2.Metadata = o.BrowserHeaders, n2.client = function(e4, t4) {
          return f3.client(e4, t4);
        }, n2.invoke = p2.invoke, n2.unary = h2.unary;
      }, 938: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.invoke = void 0;
        var n2 = r2(934);
        t3.invoke = function(e4, t4) {
          if (e4.requestStream) throw new Error(".invoke cannot be used with client-streaming methods. Use .client instead.");
          var r3 = n2.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
          return t4.onHeaders && r3.onHeaders(t4.onHeaders), t4.onMessage && r3.onMessage(t4.onMessage), t4.onEnd && r3.onEnd(t4.onEnd), r3.start(t4.metadata), r3.send(t4.request), r3.finishSend(), { close: function() {
            r3.close();
          } };
        };
      }, 65: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.Metadata = void 0;
        var n2 = r2(418);
        Object.defineProperty(t3, "Metadata", { enumerable: true, get: function() {
          return n2.BrowserHeaders;
        } });
      }, 57: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.makeDefaultTransport = t3.setDefaultTransportFactory = void 0;
        var n2 = r2(859), o = function(e4) {
          return n2.CrossBrowserHttpTransport({ withCredentials: false })(e4);
        };
        t3.setDefaultTransportFactory = function(e4) {
          o = e4;
        }, t3.makeDefaultTransport = function(e4) {
          return o(e4);
        };
      }, 229: function(e3, t3, r2) {
        "use strict";
        var n2 = this && this.__assign || function() {
          return (n2 = Object.assign || function(e4) {
            for (var t4, r3 = 1, n3 = arguments.length; r3 < n3; r3++) for (var o2 in t4 = arguments[r3]) Object.prototype.hasOwnProperty.call(t4, o2) && (e4[o2] = t4[o2]);
            return e4;
          }).apply(this, arguments);
        };
        Object.defineProperty(t3, "__esModule", { value: true }), t3.detectFetchSupport = t3.FetchReadableStreamTransport = void 0;
        var o = r2(65), s2 = r2(346);
        t3.FetchReadableStreamTransport = function(e4) {
          return function(t4) {
            return function(e5, t5) {
              return e5.debug && s2.debug("fetchRequest", e5), new i(e5, t5);
            }(t4, e4);
          };
        };
        var i = function() {
          function e4(e5, t4) {
            this.cancelled = false, this.controller = self.AbortController && new AbortController(), this.options = e5, this.init = t4;
          }
          return e4.prototype.pump = function(e5, t4) {
            var r3 = this;
            if (this.reader = e5, this.cancelled) return this.options.debug && s2.debug("Fetch.pump.cancel at first pump"), void this.reader.cancel().catch(function(e6) {
              r3.options.debug && s2.debug("Fetch.pump.reader.cancel exception", e6);
            });
            this.reader.read().then(function(e6) {
              if (e6.done) return r3.options.onEnd(), t4;
              r3.options.onChunk(e6.value), r3.pump(r3.reader, t4);
            }).catch(function(e6) {
              r3.cancelled ? r3.options.debug && s2.debug("Fetch.catch - request cancelled") : (r3.cancelled = true, r3.options.debug && s2.debug("Fetch.catch", e6.message), r3.options.onEnd(e6));
            });
          }, e4.prototype.send = function(e5) {
            var t4 = this;
            fetch(this.options.url, n2(n2({}, this.init), { headers: this.metadata.toHeaders(), method: "POST", body: e5, signal: this.controller && this.controller.signal })).then(function(e6) {
              if (t4.options.debug && s2.debug("Fetch.response", e6), t4.options.onHeaders(new o.Metadata(e6.headers), e6.status), !e6.body) return e6;
              t4.pump(e6.body.getReader(), e6);
            }).catch(function(e6) {
              t4.cancelled ? t4.options.debug && s2.debug("Fetch.catch - request cancelled") : (t4.cancelled = true, t4.options.debug && s2.debug("Fetch.catch", e6.message), t4.options.onEnd(e6));
            });
          }, e4.prototype.sendMessage = function(e5) {
            this.send(e5);
          }, e4.prototype.finishSend = function() {
          }, e4.prototype.start = function(e5) {
            this.metadata = e5;
          }, e4.prototype.cancel = function() {
            var e5 = this;
            this.cancelled ? this.options.debug && s2.debug("Fetch.cancel already cancelled") : (this.cancelled = true, this.controller ? (this.options.debug && s2.debug("Fetch.cancel.controller.abort"), this.controller.abort()) : this.options.debug && s2.debug("Fetch.cancel.missing abort controller"), this.reader ? (this.options.debug && s2.debug("Fetch.cancel.reader.cancel"), this.reader.cancel().catch(function(t4) {
              e5.options.debug && s2.debug("Fetch.cancel.reader.cancel exception", t4);
            })) : this.options.debug && s2.debug("Fetch.cancel before reader"));
          }, e4;
        }();
        t3.detectFetchSupport = function() {
          return "undefined" != typeof Response && Response.prototype.hasOwnProperty("body") && "function" == typeof Headers;
        };
      }, 859: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.CrossBrowserHttpTransport = void 0;
        var n2 = r2(229), o = r2(210);
        t3.CrossBrowserHttpTransport = function(e4) {
          if (n2.detectFetchSupport()) {
            var t4 = { credentials: e4.withCredentials ? "include" : "same-origin" };
            return n2.FetchReadableStreamTransport(t4);
          }
          return o.XhrTransport({ withCredentials: e4.withCredentials });
        };
      }, 210: function(e3, t3, r2) {
        "use strict";
        var n2, o = this && this.__extends || (n2 = function(e4, t4) {
          return (n2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e5, t5) {
            e5.__proto__ = t5;
          } || function(e5, t5) {
            for (var r3 in t5) Object.prototype.hasOwnProperty.call(t5, r3) && (e5[r3] = t5[r3]);
          })(e4, t4);
        }, function(e4, t4) {
          function r3() {
            this.constructor = e4;
          }
          n2(e4, t4), e4.prototype = null === t4 ? Object.create(t4) : (r3.prototype = t4.prototype, new r3());
        });
        Object.defineProperty(t3, "__esModule", { value: true }), t3.stringToArrayBuffer = t3.MozChunkedArrayBufferXHR = t3.XHR = t3.XhrTransport = void 0;
        var s2 = r2(65), i = r2(346), a2 = r2(849);
        t3.XhrTransport = function(e4) {
          return function(t4) {
            if (a2.detectMozXHRSupport()) return new d2(t4, e4);
            if (a2.detectXHROverrideMimeTypeSupport()) return new u2(t4, e4);
            throw new Error("This environment's XHR implementation cannot support binary transfer.");
          };
        };
        var u2 = function() {
          function e4(e5, t4) {
            this.options = e5, this.init = t4;
          }
          return e4.prototype.onProgressEvent = function() {
            this.options.debug && i.debug("XHR.onProgressEvent.length: ", this.xhr.response.length);
            var e5 = this.xhr.response.substr(this.index);
            this.index = this.xhr.response.length;
            var t4 = p2(e5);
            this.options.onChunk(t4);
          }, e4.prototype.onLoadEvent = function() {
            this.options.debug && i.debug("XHR.onLoadEvent"), this.options.onEnd();
          }, e4.prototype.onStateChange = function() {
            this.options.debug && i.debug("XHR.onStateChange", this.xhr.readyState), this.xhr.readyState === XMLHttpRequest.HEADERS_RECEIVED && this.options.onHeaders(new s2.Metadata(this.xhr.getAllResponseHeaders()), this.xhr.status);
          }, e4.prototype.sendMessage = function(e5) {
            this.xhr.send(e5);
          }, e4.prototype.finishSend = function() {
          }, e4.prototype.start = function(e5) {
            var t4 = this;
            this.metadata = e5;
            var r3 = new XMLHttpRequest();
            this.xhr = r3, r3.open("POST", this.options.url), this.configureXhr(), this.metadata.forEach(function(e6, t5) {
              r3.setRequestHeader(e6, t5.join(", "));
            }), r3.withCredentials = Boolean(this.init.withCredentials), r3.addEventListener("readystatechange", this.onStateChange.bind(this)), r3.addEventListener("progress", this.onProgressEvent.bind(this)), r3.addEventListener("loadend", this.onLoadEvent.bind(this)), r3.addEventListener("error", function(e6) {
              t4.options.debug && i.debug("XHR.error", e6), t4.options.onEnd(e6.error);
            });
          }, e4.prototype.configureXhr = function() {
            this.xhr.responseType = "text", this.xhr.overrideMimeType("text/plain; charset=x-user-defined");
          }, e4.prototype.cancel = function() {
            this.options.debug && i.debug("XHR.abort"), this.xhr.abort();
          }, e4;
        }();
        t3.XHR = u2;
        var d2 = function(e4) {
          function t4() {
            return null !== e4 && e4.apply(this, arguments) || this;
          }
          return o(t4, e4), t4.prototype.configureXhr = function() {
            this.options.debug && i.debug("MozXHR.configureXhr: setting responseType to 'moz-chunked-arraybuffer'"), this.xhr.responseType = "moz-chunked-arraybuffer";
          }, t4.prototype.onProgressEvent = function() {
            var e5 = this.xhr.response;
            this.options.debug && i.debug("MozXHR.onProgressEvent: ", new Uint8Array(e5)), this.options.onChunk(new Uint8Array(e5));
          }, t4;
        }(u2);
        function c2(e4, t4) {
          var r3 = e4.charCodeAt(t4);
          if (r3 >= 55296 && r3 <= 56319) {
            var n3 = e4.charCodeAt(t4 + 1);
            n3 >= 56320 && n3 <= 57343 && (r3 = 65536 + (r3 - 55296 << 10) + (n3 - 56320));
          }
          return r3;
        }
        function p2(e4) {
          for (var t4 = new Uint8Array(e4.length), r3 = 0, n3 = 0; n3 < e4.length; n3++) {
            var o2 = String.prototype.codePointAt ? e4.codePointAt(n3) : c2(e4, n3);
            t4[r3++] = 255 & o2;
          }
          return t4;
        }
        t3.MozChunkedArrayBufferXHR = d2, t3.stringToArrayBuffer = p2;
      }, 849: function(e3, t3) {
        "use strict";
        var r2;
        function n2() {
          if (void 0 !== r2) return r2;
          if (XMLHttpRequest) {
            r2 = new XMLHttpRequest();
            try {
              r2.open("GET", "https://localhost");
            } catch (e4) {
            }
          }
          return r2;
        }
        function o(e4) {
          var t4 = n2();
          if (!t4) return false;
          try {
            return t4.responseType = e4, t4.responseType === e4;
          } catch (e5) {
          }
          return false;
        }
        Object.defineProperty(t3, "__esModule", { value: true }), t3.detectXHROverrideMimeTypeSupport = t3.detectMozXHRSupport = t3.xhrSupportsResponseType = void 0, t3.xhrSupportsResponseType = o, t3.detectMozXHRSupport = function() {
          return "undefined" != typeof XMLHttpRequest && o("moz-chunked-arraybuffer");
        }, t3.detectXHROverrideMimeTypeSupport = function() {
          return "undefined" != typeof XMLHttpRequest && XMLHttpRequest.prototype.hasOwnProperty("overrideMimeType");
        };
      }, 540: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.WebsocketTransport = void 0;
        var n2, o = r2(346), s2 = r2(617);
        !function(e4) {
          e4[e4.FINISH_SEND = 1] = "FINISH_SEND";
        }(n2 || (n2 = {}));
        var i = new Uint8Array([1]);
        t3.WebsocketTransport = function() {
          return function(e4) {
            return function(e5) {
              e5.debug && o.debug("websocketRequest", e5);
              var t4, r3 = function(e6) {
                if ("https://" === e6.substr(0, 8)) return "wss://" + e6.substr(8);
                if ("http://" === e6.substr(0, 7)) return "ws://" + e6.substr(7);
                throw new Error("Websocket transport constructed with non-https:// or http:// host.");
              }(e5.url), a2 = [];
              function u2(e6) {
                if (e6 === n2.FINISH_SEND) t4.send(i);
                else {
                  var r4 = e6, o2 = new Int8Array(r4.byteLength + 1);
                  o2.set(new Uint8Array([0])), o2.set(r4, 1), t4.send(o2);
                }
              }
              return { sendMessage: function(e6) {
                t4 && t4.readyState !== t4.CONNECTING ? u2(e6) : a2.push(e6);
              }, finishSend: function() {
                t4 && t4.readyState !== t4.CONNECTING ? u2(n2.FINISH_SEND) : a2.push(n2.FINISH_SEND);
              }, start: function(n3) {
                (t4 = new WebSocket(r3, ["grpc-websockets"])).binaryType = "arraybuffer", t4.onopen = function() {
                  var r4;
                  e5.debug && o.debug("websocketRequest.onopen"), t4.send((r4 = "", n3.forEach(function(e6, t5) {
                    r4 += e6 + ": " + t5.join(", ") + "\r\n";
                  }), s2.encodeASCII(r4))), a2.forEach(function(e6) {
                    u2(e6);
                  });
                }, t4.onclose = function(t5) {
                  e5.debug && o.debug("websocketRequest.onclose", t5), e5.onEnd();
                }, t4.onerror = function(t5) {
                  e5.debug && o.debug("websocketRequest.onerror", t5);
                }, t4.onmessage = function(t5) {
                  e5.onChunk(new Uint8Array(t5.data));
                };
              }, cancel: function() {
                e5.debug && o.debug("websocket.abort"), t4.close();
              } };
            }(e4);
          };
        };
      }, 35: function(e3, t3, r2) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.unary = void 0;
        var n2 = r2(65), o = r2(934);
        t3.unary = function(e4, t4) {
          if (e4.responseStream) throw new Error(".unary cannot be used with server-streaming methods. Use .invoke or .client instead.");
          if (e4.requestStream) throw new Error(".unary cannot be used with client-streaming methods. Use .client instead.");
          var r3 = null, s2 = null, i = o.client(e4, { host: t4.host, transport: t4.transport, debug: t4.debug });
          return i.onHeaders(function(e5) {
            r3 = e5;
          }), i.onMessage(function(e5) {
            s2 = e5;
          }), i.onEnd(function(e5, o2, i2) {
            t4.onEnd({ status: e5, statusMessage: o2, headers: r3 || new n2.Metadata(), message: s2, trailers: i2 });
          }), i.start(t4.metadata), i.send(t4.request), i.finishSend(), { close: function() {
            i.close();
          } };
        };
      }, 882: function(e3, t3) {
        "use strict";
        Object.defineProperty(t3, "__esModule", { value: true }), t3.frameRequest = void 0, t3.frameRequest = function(e4) {
          var t4 = e4.serializeBinary(), r2 = new ArrayBuffer(t4.byteLength + 5);
          return new DataView(r2, 1, 4).setUint32(0, t4.length, false), new Uint8Array(r2, 5).set(t4), new Uint8Array(r2);
        };
      } }, t2 = {}, function r2(n2) {
        if (t2[n2]) return t2[n2].exports;
        var o = t2[n2] = { exports: {} };
        return e2[n2].call(o.exports, o, o.exports, r2), o.exports;
      }(607);
      var e2, t2;
    });
  }
});

// node_modules/browser-headers/dist/browser-headers.umd.js
var require_browser_headers_umd = __commonJS({
  "node_modules/browser-headers/dist/browser-headers.umd.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define([], factory);
      else {
        var a2 = factory();
        for (var i in a2) (typeof exports === "object" ? exports : root)[i] = a2[i];
      }
    })(exports, function() {
      return (
        /******/
        function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) {
              return installedModules[moduleId].exports;
            }
            var module2 = installedModules[moduleId] = {
              /******/
              i: moduleId,
              /******/
              l: false,
              /******/
              exports: {}
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.l = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.i = function(value) {
            return value;
          };
          __webpack_require__.d = function(exports2, name, getter) {
            if (!__webpack_require__.o(exports2, name)) {
              Object.defineProperty(exports2, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                /******/
              });
            }
          };
          __webpack_require__.n = function(module2) {
            var getter = module2 && module2.__esModule ? (
              /******/
              function getDefault() {
                return module2["default"];
              }
            ) : (
              /******/
              function getModuleExports() {
                return module2;
              }
            );
            __webpack_require__.d(getter, "a", getter);
            return getter;
          };
          __webpack_require__.o = function(object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
          };
          __webpack_require__.p = "";
          return __webpack_require__(__webpack_require__.s = 1);
        }([
          /* 0 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var util_1 = __webpack_require__(3);
            function isBrowserHeaders(arg) {
              return typeof arg === "object" && typeof arg.headersMap === "object" && typeof arg.forEach === "function";
            }
            var BrowserHeaders3 = function() {
              function BrowserHeaders4(init, options) {
                if (init === void 0) {
                  init = {};
                }
                if (options === void 0) {
                  options = { splitValues: false };
                }
                var _this = this;
                this.headersMap = {};
                if (init) {
                  if (typeof Headers !== "undefined" && init instanceof Headers) {
                    var keys = util_1.getHeaderKeys(init);
                    keys.forEach(function(key) {
                      var values = util_1.getHeaderValues(init, key);
                      values.forEach(function(value) {
                        if (options.splitValues) {
                          _this.append(key, util_1.splitHeaderValue(value));
                        } else {
                          _this.append(key, value);
                        }
                      });
                    });
                  } else if (isBrowserHeaders(init)) {
                    init.forEach(function(key, values) {
                      _this.append(key, values);
                    });
                  } else if (typeof Map !== "undefined" && init instanceof Map) {
                    var asMap = init;
                    asMap.forEach(function(value, key) {
                      _this.append(key, value);
                    });
                  } else if (typeof init === "string") {
                    this.appendFromString(init);
                  } else if (typeof init === "object") {
                    Object.getOwnPropertyNames(init).forEach(function(key) {
                      var asObject = init;
                      var values = asObject[key];
                      if (Array.isArray(values)) {
                        values.forEach(function(value) {
                          _this.append(key, value);
                        });
                      } else {
                        _this.append(key, values);
                      }
                    });
                  }
                }
              }
              BrowserHeaders4.prototype.appendFromString = function(str) {
                var pairs2 = str.split("\r\n");
                for (var i = 0; i < pairs2.length; i++) {
                  var p2 = pairs2[i];
                  var index = p2.indexOf(":");
                  if (index > 0) {
                    var key = p2.substring(0, index).trim();
                    var value = p2.substring(index + 1).trim();
                    this.append(key, value);
                  }
                }
              };
              BrowserHeaders4.prototype.delete = function(key, value) {
                var normalizedKey = util_1.normalizeName(key);
                if (value === void 0) {
                  delete this.headersMap[normalizedKey];
                } else {
                  var existing = this.headersMap[normalizedKey];
                  if (existing) {
                    var index = existing.indexOf(value);
                    if (index >= 0) {
                      existing.splice(index, 1);
                    }
                    if (existing.length === 0) {
                      delete this.headersMap[normalizedKey];
                    }
                  }
                }
              };
              BrowserHeaders4.prototype.append = function(key, value) {
                var _this = this;
                var normalizedKey = util_1.normalizeName(key);
                if (!Array.isArray(this.headersMap[normalizedKey])) {
                  this.headersMap[normalizedKey] = [];
                }
                if (Array.isArray(value)) {
                  value.forEach(function(arrayValue) {
                    _this.headersMap[normalizedKey].push(util_1.normalizeValue(arrayValue));
                  });
                } else {
                  this.headersMap[normalizedKey].push(util_1.normalizeValue(value));
                }
              };
              BrowserHeaders4.prototype.set = function(key, value) {
                var normalizedKey = util_1.normalizeName(key);
                if (Array.isArray(value)) {
                  var normalized_1 = [];
                  value.forEach(function(arrayValue) {
                    normalized_1.push(util_1.normalizeValue(arrayValue));
                  });
                  this.headersMap[normalizedKey] = normalized_1;
                } else {
                  this.headersMap[normalizedKey] = [util_1.normalizeValue(value)];
                }
              };
              BrowserHeaders4.prototype.has = function(key, value) {
                var keyArray = this.headersMap[util_1.normalizeName(key)];
                var keyExists = Array.isArray(keyArray);
                if (!keyExists) {
                  return false;
                }
                if (value !== void 0) {
                  var normalizedValue = util_1.normalizeValue(value);
                  return keyArray.indexOf(normalizedValue) >= 0;
                } else {
                  return true;
                }
              };
              BrowserHeaders4.prototype.get = function(key) {
                var values = this.headersMap[util_1.normalizeName(key)];
                if (values !== void 0) {
                  return values.concat();
                }
                return [];
              };
              BrowserHeaders4.prototype.forEach = function(callback) {
                var _this = this;
                Object.getOwnPropertyNames(this.headersMap).forEach(function(key) {
                  callback(key, _this.headersMap[key]);
                }, this);
              };
              BrowserHeaders4.prototype.toHeaders = function() {
                if (typeof Headers !== "undefined") {
                  var headers_1 = new Headers();
                  this.forEach(function(key, values) {
                    values.forEach(function(value) {
                      headers_1.append(key, value);
                    });
                  });
                  return headers_1;
                } else {
                  throw new Error("Headers class is not defined");
                }
              };
              return BrowserHeaders4;
            }();
            exports2.BrowserHeaders = BrowserHeaders3;
          },
          /* 1 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var BrowserHeaders_1 = __webpack_require__(0);
            exports2.BrowserHeaders = BrowserHeaders_1.BrowserHeaders;
          },
          /* 2 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            function iterateHeaders(headers, callback) {
              var iterator2 = headers[Symbol.iterator]();
              var entry = iterator2.next();
              while (!entry.done) {
                callback(entry.value[0]);
                entry = iterator2.next();
              }
            }
            exports2.iterateHeaders = iterateHeaders;
            function iterateHeadersKeys(headers, callback) {
              var iterator2 = headers.keys();
              var entry = iterator2.next();
              while (!entry.done) {
                callback(entry.value);
                entry = iterator2.next();
              }
            }
            exports2.iterateHeadersKeys = iterateHeadersKeys;
          },
          /* 3 */
          /***/
          function(module2, exports2, __webpack_require__) {
            "use strict";
            Object.defineProperty(exports2, "__esModule", { value: true });
            var iterateHeaders_1 = __webpack_require__(2);
            function normalizeName(name) {
              if (typeof name !== "string") {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
                throw new TypeError("Invalid character in header field name");
              }
              return name.toLowerCase();
            }
            exports2.normalizeName = normalizeName;
            function normalizeValue(value) {
              if (typeof value !== "string") {
                value = String(value);
              }
              return value;
            }
            exports2.normalizeValue = normalizeValue;
            function getHeaderValues(headersAsNative, key) {
              var headers = toWindowHeaders(headersAsNative);
              if (headers instanceof Headers && headers.getAll) {
                return headers.getAll(key);
              }
              var getValue = headers.get(key);
              if (getValue && typeof getValue === "string") {
                return [getValue];
              }
              return getValue;
            }
            exports2.getHeaderValues = getHeaderValues;
            function toWindowHeaders(headersAsNative) {
              return headersAsNative;
            }
            function getHeaderKeys(headersAsNative) {
              var headers = toWindowHeaders(headersAsNative);
              var asMap = {};
              var keys = [];
              if (headers.keys) {
                iterateHeaders_1.iterateHeadersKeys(headers, function(key) {
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              } else if (headers.forEach) {
                headers.forEach(function(_, key) {
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              } else {
                iterateHeaders_1.iterateHeaders(headers, function(entry) {
                  var key = entry[0];
                  if (!asMap[key]) {
                    asMap[key] = true;
                    keys.push(key);
                  }
                });
              }
              return keys;
            }
            exports2.getHeaderKeys = getHeaderKeys;
            function splitHeaderValue(str) {
              var values = [];
              var commaSpaceValues = str.split(", ");
              commaSpaceValues.forEach(function(commaSpaceValue) {
                commaSpaceValue.split(",").forEach(function(commaValue) {
                  values.push(commaValue);
                });
              });
              return values;
            }
            exports2.splitHeaderValue = splitHeaderValue;
          }
          /******/
        ])
      );
    });
  }
});

// node_modules/@snap/ts-inject/dist/esm/memoize.js
function isMemoized(fn) {
  return typeof fn === "function" && typeof fn.delegate === "function";
}
function memoize(thisArg, delegate) {
  let memo;
  const memoized = (...args) => {
    if (typeof memo !== "undefined")
      return memo;
    memo = delegate.apply(memoized.thisArg, args);
    return memo;
  };
  memoized.delegate = delegate;
  memoized.thisArg = thisArg;
  return memoized;
}

// node_modules/@snap/ts-inject/dist/esm/entries.js
var entries = (o) => Object.entries(o);

// node_modules/@snap/ts-inject/dist/esm/Injectable.js
function Injectable(token, dependenciesOrFn, maybeFn) {
  const dependencies = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];
  const fn = typeof dependenciesOrFn === "function" ? dependenciesOrFn : maybeFn;
  if (!fn) {
    throw new TypeError("[Injectable] Received invalid arguments. The factory function must be either the second or third argument.");
  }
  if (fn.length !== dependencies.length) {
    throw new TypeError(`[Injectable] Function arity does not match the number of dependencies. Function has arity ${fn.length}, but ${dependencies.length} dependencies were specified.
Dependencies: ${JSON.stringify(dependencies)}`);
  }
  const factory = (...args) => fn(...args);
  factory.token = token;
  factory.dependencies = dependencies;
  return factory;
}
function InjectableCompat(token, dependencies, fn) {
  return Injectable(token, dependencies, fn);
}
function ClassInjectable(token, cls) {
  const factory = (...args) => new cls(...args);
  factory.token = token;
  factory.dependencies = cls.dependencies;
  return factory;
}
function ConcatInjectable(token, dependenciesOrFn, maybeFn) {
  const dependencies = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];
  const fn = typeof dependenciesOrFn === "function" ? dependenciesOrFn : maybeFn;
  if (!fn) {
    throw new TypeError("[ConcatInjectable] Received invalid arguments. The factory function must be either the second or third argument.");
  }
  if (fn.length !== dependencies.length) {
    throw new TypeError(`[Injectable] Function arity does not match the number of dependencies. Function has arity ${fn.length}, but ${dependencies.length} dependencies were specified.
Dependencies: ${JSON.stringify(dependencies)}`);
  }
  const factory = (array, ...args) => {
    return array.concat(fn(...args));
  };
  factory.token = token;
  factory.dependencies = [token, ...dependencies];
  return factory;
}

// node_modules/@snap/ts-inject/dist/esm/PartialContainer.js
var PartialContainer = class _PartialContainer {
  constructor(injectables) {
    __publicField(this, "injectables");
    __publicField(this, "providesValue", (token, value) => this.provides(Injectable(token, [], () => value)));
    __publicField(this, "providesClass", (token, cls) => this.provides(ClassInjectable(token, cls)));
    this.injectables = injectables;
  }
  provides(fn) {
    return new _PartialContainer({ ...this.injectables, [fn.token]: fn });
  }
  getFactories(parent) {
    let factories = void 0;
    return factories = Object.fromEntries(entries(this.injectables).map(([token, fn]) => [
      token,
      memoize(parent, () => fn(...fn.dependencies.map((t2) => {
        return t2 === token ? parent.get(t2) : factories[t2] ? factories[t2]() : parent.get(t2);
      })))
    ]));
  }
  getTokens() {
    return Object.keys(this.injectables);
  }
};

// node_modules/@snap/ts-inject/dist/esm/Container.js
var CONTAINER = "$container";
var Container = class _Container {
  constructor(factories) {
    __publicField(this, "factories");
    __publicField(this, "providesClass", (token, cls) => this.providesService(ClassInjectable(token, cls)));
    __publicField(this, "providesValue", (token, value) => this.providesService(Injectable(token, [], () => value)));
    __publicField(this, "appendValue", (token, value) => this.providesService(ConcatInjectable(token, () => value)));
    __publicField(this, "appendClass", (token, cls) => this.providesService(ConcatInjectable(token, () => this.providesClass(token, cls).get(token))));
    __publicField(this, "append", (fn) => this.providesService(ConcatInjectable(fn.token, () => this.providesService(fn).get(fn.token))));
    const memoizedFactories = {};
    for (const k2 in factories) {
      const fn = factories[k2];
      if (isMemoized(fn)) {
        memoizedFactories[k2] = fn;
        fn.thisArg = this;
      } else {
        memoizedFactories[k2] = memoize(this, fn);
      }
    }
    this.factories = memoizedFactories;
  }
  static provides(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer)
      return new _Container({}).provides(fnOrContainer);
    if (fnOrContainer instanceof _Container)
      return new _Container({}).provides(fnOrContainer);
    return new _Container({}).provides(fnOrContainer);
  }
  static providesValue(token, value) {
    return new _Container({}).providesValue(token, value);
  }
  static fromObject(services) {
    return entries(services).reduce((container, [token, value]) => container.providesValue(token, value), new _Container({}));
  }
  copy(scopedServices) {
    const factories = { ...this.factories };
    (scopedServices || []).forEach((token) => {
      factories[token] = this.factories[token].delegate;
    });
    return new _Container(factories);
  }
  get(token) {
    if (token === CONTAINER)
      return this;
    const factory = this.factories[token];
    if (!factory) {
      throw new Error(`[Container::get] Could not find Service for Token "${String(token)}". This should've caused a compile-time error. If the Token is 'undefined', check all your calls to the Injectable function. Make sure you define dependencies using string literals or string constants that are definitely initialized before the call to Injectable.`);
    }
    return factory();
  }
  run(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer) {
      const runnableContainer = this.provides(fnOrContainer);
      for (const token of fnOrContainer.getTokens()) {
        runnableContainer.get(token);
      }
    } else {
      this.provides(fnOrContainer).get(fnOrContainer.token);
    }
    return this;
  }
  provides(fnOrContainer) {
    if (fnOrContainer instanceof PartialContainer || fnOrContainer instanceof _Container) {
      const factories = fnOrContainer instanceof PartialContainer ? fnOrContainer.getFactories(this) : fnOrContainer.factories;
      return new _Container({
        ...this.factories,
        ...factories
      });
    }
    return this.providesService(fnOrContainer);
  }
  providesService(fn) {
    const token = fn.token;
    const dependencies = fn.dependencies;
    const getFromParent = dependencies.indexOf(token) === -1 ? void 0 : () => this.get(token);
    const factory = memoize(this, function() {
      return fn(...dependencies.map((t2) => t2 === token ? getFromParent() : this.get(t2)));
    });
    const factories = { ...this.factories, [token]: factory };
    return new _Container(factories);
  }
};

// node_modules/@snap/camera-kit/dist/common/copyDefinedProperties.js
function copyDefinedProperties(obj) {
  return Object.fromEntries(Object.entries(obj).filter(([_, value]) => value !== void 0));
}

// node_modules/@snap/camera-kit/dist/configurationOverrides.js
var windowFieldPrefix = "__snap_camkit_override__";
var configPropertiesToOverride = [
  "wasmEndpointOverride",
  "logger",
  "logLevel",
  "userAgentFlavor"
];
configPropertiesToOverride.forEach((fieldToOverride) => {
  defineWindowField(fieldToOverride);
});
function defineWindowField(propertyToOverride) {
  if (typeof window === "undefined")
    return;
  Object.defineProperty(window, `${windowFieldPrefix}${propertyToOverride}`, {
    get() {
      var _a;
      return (_a = getConfigurationOverrides()) === null || _a === void 0 ? void 0 : _a[propertyToOverride];
    },
    set(value) {
      const storedOverrides = Object.assign(Object.assign({}, getConfigurationOverrides()), { [propertyToOverride]: value });
      if (Object.values(storedOverrides).every((value2) => typeof value2 === "undefined")) {
        sessionStorage.removeItem(windowFieldPrefix);
      } else {
        sessionStorage.setItem(windowFieldPrefix, JSON.stringify(storedOverrides));
      }
    },
    enumerable: false,
    configurable: true
  });
}
function getConfigurationOverrides() {
  if (!sessionStorage)
    return void 0;
  const overridesString = sessionStorage.getItem(windowFieldPrefix);
  return overridesString && JSON.parse(overridesString);
}

// node_modules/@snap/camera-kit/dist/configuration.js
var defaultConfiguration = {
  lensPerformance: { cluster: 0, benchmarks: [], webglRendererInfo: "unknown" },
  logger: "noop",
  logLevel: "info",
  shouldUseWorker: true,
  apiHostname: "camera-kit-api.snapar.com",
  userAgentFlavor: "release",
  fonts: []
};
var configurationToken = "configuration";
function isHandledAppleDevice() {
  return /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 2;
}
var createCameraKitConfigurationFactory = (configuration) => {
  const overrides = getConfigurationOverrides();
  if (overrides) {
    console.warn("Configuration overrides applied", overrides);
  }
  return Injectable(configurationToken, () => {
    const safeConfig = Object.assign(Object.assign({}, configuration), { lensPerformance: configuration.lensPerformance instanceof Promise ? configuration.lensPerformance.catch(() => defaultConfiguration.lensPerformance) : configuration.lensPerformance });
    return Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfiguration), { shouldUseWorker: isHandledAppleDevice() ? false : defaultConfiguration.shouldUseWorker }), copyDefinedProperties(safeConfig)), copyDefinedProperties(overrides !== null && overrides !== void 0 ? overrides : {}));
  });
};

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f3) {
    if (f3 !== void 0 && typeof f3 !== "function") throw new TypeError("Function expected");
    return f3;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p2 in contextIn) context2[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context2.access[p2] = contextIn.access[p2];
    context2.addInitializer = function(f3) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f3 || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f3) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f3 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values2(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
  if (m2) return m2.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f3) {
    return function(v2) {
      return Promise.resolve(v2).then(f3, reject);
    };
  }
  function verb(n2, f3) {
    if (g[n2]) {
      i[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
      if (f3) i[n2] = f3(i[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step(g[n2](v2));
    } catch (e2) {
      settle(q[0][3], e2);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f3, v2) {
    if (f3(v2), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v7) {
      resolve({ value: v7, done: d2 });
    }, reject);
  }
}

// node_modules/@snap/camera-kit/dist/namedErrors.js
function cleanErrorStack(stack) {
  const [first2, _, ...rest] = stack.split("\n");
  return [first2, ...rest].join("\n");
}
function namedError(name) {
  return (message, cause) => {
    const error = new Error(message, { cause });
    error.name = name;
    error.stack = error.stack && cleanErrorStack(error.stack);
    return error;
  };
}
var legalError = namedError("LegalError");
var lensContentValidationError = namedError("LensContentValidationError");
var lensError = namedError("LensError");
var cameraKitSourceError = namedError("CameraKitSourceError");
var lensImagePickerError = namedError("LensImagePickerError");
var cacheKeyNotFoundError = namedError("CacheKeyNotFoundError");
var configurationError = namedError("ConfigurationError");
var webGLError = namedError("WebGLError");
var benchmarkError = namedError("BenchmarkError");
var platformNotSupportedError = namedError("PlatformNotSupportedError");
var lensExecutionError = namedError("LensExecutionError");
var lensAbortError = namedError("LensAbortError");
var persistentStoreError = namedError("PersistentStoreError");
var lensAssetError = namedError("LensAssetError");
var bootstrapError = namedError("BootstrapError");
var argumentValidationError = namedError("ArgumentValidationError");

// node_modules/@snap/camera-kit/dist/benchmark/webglUtils.js
var webGLEntityCreationError = (name) => webGLError(`Could not create ${name}.`);
function createProgram(gl, vertexSource2, fragmentSource2) {
  const vertexShader = createShader(gl, vertexSource2, gl.VERTEX_SHADER);
  const fragmentShader = createShader(gl, fragmentSource2, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  if (!program)
    throw webGLEntityCreationError("WebGLProgram");
  gl.attachShader(program, vertexShader);
  gl.deleteShader(vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.deleteShader(fragmentShader);
  gl.linkProgram(program);
  const success = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!success) {
    const message = gl.getProgramInfoLog(program);
    gl.deleteProgram(program);
    throw webGLError(`WebGLProgram linking failed with status: ${message}.`);
  }
  return program;
}
function createShader(gl, source, type) {
  const shader = gl.createShader(type);
  if (!shader)
    throw webGLEntityCreationError(`WebGLShader (type ${type})`);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!success) {
    const message = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw webGLError(`WebGLShader (type ${type}) compilation failed with status: ${message}.`);
  }
  return shader;
}
function createTexture(gl, width2, height2) {
  const texture = gl.createTexture();
  if (!texture)
    throw webGLEntityCreationError("WebGLTexture");
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width2, height2, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
  return texture;
}
function createFramebuffer(gl, texture) {
  const framebuffer = gl.createFramebuffer();
  if (!framebuffer)
    throw webGLEntityCreationError("WebGLFramebuffer");
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  return framebuffer;
}
function setUniform1i(gl, program, name, data) {
  gl.uniform1i(gl.getUniformLocation(program, name), data);
}
function setUniform4f(gl, program, name, data) {
  gl.uniform4f(gl.getUniformLocation(program, name), ...data);
}
function promiseSync(gl) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  if (!sync)
    throw webGLEntityCreationError("WebGLSync");
  gl.flush();
  return new Promise((resolve, reject) => {
    const waitForSync = () => {
      const glEnum = gl.clientWaitSync(sync, 0, 0);
      switch (glEnum) {
        case gl.TIMEOUT_EXPIRED:
          setTimeout(waitForSync);
          return;
        case gl.WAIT_FAILED:
          gl.deleteSync(sync);
          return reject();
        case gl.ALREADY_SIGNALED:
        case gl.CONDITION_SATISFIED:
          gl.deleteSync(sync);
          return resolve();
      }
    };
    waitForSync();
  });
}

// node_modules/@snap/camera-kit/dist/benchmark/benchmarkGflops.js
var vertexSource = `#version 300 es

precision mediump float;
precision mediump int;

in vec2 pos;

void main() {
    gl_Position = vec4(pos, 0.0, 1.0);
}
`;
var fragmentSource = `#version 300 es

precision mediump float;
precision mediump int;

uniform int LOOP_COUNT;
uniform vec4 v0;
uniform vec4 v1;
uniform vec4 v2;

out vec4 fragColor;

#define REPEAT_2(x) x; x
#define REPEAT_4(x) REPEAT_2(x); REPEAT_2(x)
#define REPEAT_8(x) REPEAT_4(x); REPEAT_4(x)
#define REPEAT_16(x) REPEAT_8(x); REPEAT_8(x)
#define REPEAT_32(x) REPEAT_16(x); REPEAT_16(x)

void main() {
    vec4 r = v2;
    for (int i = 0; i < LOOP_COUNT; i++) {
        REPEAT_32(r = r * v1 + v0);
    }
    fragColor = r;
}
`;
var width = 1024;
var height = 1024;
var budgetMs = 300;
var maxLoopCount = 1e3;
function prepareBenchmark(gl) {
  const texture = createTexture(gl, width, height);
  const framebuffer = createFramebuffer(gl, texture);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  const buffer2 = gl.createBuffer();
  if (!buffer2) {
    throw new Error("Failed to create WebGLBuffer.");
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer2);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, 1, -1, -1, 1, -1, 1, 1]), gl.STATIC_DRAW);
  gl.viewport(0, 0, width, height);
  gl.disable(gl.CULL_FACE);
  gl.disable(gl.DEPTH_TEST);
  const program = createProgram(gl, vertexSource, fragmentSource);
  gl.useProgram(program);
  const posLocation = gl.getAttribLocation(program, "pos");
  gl.enableVertexAttribArray(posLocation);
  gl.vertexAttribPointer(posLocation, 2, gl.FLOAT, false, 0, 0);
  setUniform4f(gl, program, "v0", [1.15, 1.23, 1.47, 1.84]);
  setUniform4f(gl, program, "v1", [1.65, 1.22, 1.69, 1.04]);
  setUniform4f(gl, program, "v2", [1.05, 1.3, 1.55, 1.23]);
  return {
    program,
    cleanupBenchmark: () => {
      gl.deleteProgram(program);
      gl.deleteBuffer(buffer2);
      gl.deleteFramebuffer(framebuffer);
      gl.deleteTexture(texture);
    }
  };
}
function runBenchmark(gl, program) {
  return __awaiter(this, void 0, void 0, function* () {
    yield promiseSync(gl);
    const start = performance.now();
    const flops = [];
    let loopCount = 20;
    while (true) {
      setUniform1i(gl, program, "LOOP_COUNT", loopCount);
      const iterationStart = performance.now();
      gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
      yield promiseSync(gl);
      const iterationEnd = performance.now();
      const duration = iterationEnd - iterationStart;
      flops.push(loopCount / duration);
      const remainingBudgetMs = budgetMs - (iterationEnd - start);
      if (remainingBudgetMs < 0)
        break;
      if (loopCount < maxLoopCount) {
        loopCount += remainingBudgetMs < duration ? 10 : 0.6 * loopCount * remainingBudgetMs / duration;
      }
    }
    const maxFlops = Math.max(...flops) * (8 * 32) * width * height;
    return maxFlops / 1e6;
  });
}
var gflopsClusterCenters = /* @__PURE__ */ new Map([
  [34, 1],
  [134, 2],
  [385, 3],
  [783, 4],
  [1484, 5],
  [2313, 6]
]);
function benchmarkGflops(gl) {
  return __awaiter(this, void 0, void 0, function* () {
    const { program, cleanupBenchmark } = prepareBenchmark(gl);
    const gflops = yield runBenchmark(gl, program);
    cleanupBenchmark();
    return { name: "gflops", value: gflops };
  });
}

// node_modules/@snap/camera-kit/dist/benchmark/estimateLensPerformanceCluster.js
var findNearest = (n2, arr) => arr.reduce((a2, b2) => Math.abs(a2 - n2) <= Math.abs(b2 - n2) ? a2 : b2);
var webglContextAttributes = {
  alpha: false,
  antialias: false,
  premultipliedAlpha: false,
  preserveDrawingBuffer: false,
  depth: false,
  stencil: false,
  failIfMajorPerformanceCaveat: false,
  powerPreference: "high-performance"
};
function estimateLensPerformance() {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const canvas = document.createElement("canvas");
    const gl = canvas.getContext("webgl2", webglContextAttributes);
    if (!gl)
      throw benchmarkError("WebGL2 is required to compute performance, but it is not supported.");
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const webglRendererInfo = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
    const gflops = yield benchmarkGflops(gl);
    const nearestGflopsClusterCenter = findNearest(gflops.value, Array.from(gflopsClusterCenters.keys()));
    const gflopsCluster = (_a = gflopsClusterCenters.get(nearestGflopsClusterCenter)) !== null && _a !== void 0 ? _a : 0;
    return {
      cluster: gflopsCluster,
      benchmarks: [gflops],
      webglRendererInfo
    };
  });
}

// node_modules/@snap/camera-kit/dist/handlers/arrayBufferParsingHandler.js
var createArrayBufferParsingHandler = () => (next) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
  const response = yield next(req, metadata);
  let buffer2;
  try {
    buffer2 = yield response.arrayBuffer();
  } catch (_) {
    buffer2 = new ArrayBuffer(0);
  }
  return [buffer2, response];
});

// node_modules/@snap/camera-kit/dist/handlers/HandlerChainBuilder.js
var HandlerChainBuilder = class _HandlerChainBuilder {
  constructor(inner) {
    this.inner = inner;
  }
  get handler() {
    return this.inner;
  }
  map(outer) {
    const outerHandler = (req, metadata) => {
      var _a;
      const abort = new AbortController();
      const signal = abort.signal;
      let innerCompleted = false;
      const maybeAbort = () => {
        var _a2;
        if (signal.aborted || innerCompleted)
          return;
        abort.abort();
        (_a2 = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", maybeAbort);
      };
      (_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", maybeAbort);
      const innerHandler = new Proxy(this.inner, {
        apply: (target, thisArg, args) => {
          const [req2, metadata2] = args;
          if (metadata2 === null || metadata2 === void 0 ? void 0 : metadata2.isSideEffect)
            innerCompleted = true;
          const abortListeners = [];
          signal.addEventListener = new Proxy(signal.addEventListener, {
            apply: (target2, thisArg2, args2) => {
              abortListeners.push(args2[1]);
              return Reflect.apply(target2, thisArg2, args2);
            }
          });
          const cleanupAndMarkComplete = () => {
            var _a2;
            (_a2 = metadata2 === null || metadata2 === void 0 ? void 0 : metadata2.signal) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener("abort", maybeAbort);
            abortListeners.forEach((listener) => signal.removeEventListener("abort", listener));
            innerCompleted = true;
          };
          const innerResponse = Reflect.apply(target, thisArg, [
            req2,
            Object.assign(Object.assign({}, metadata2), { isSideEffect: false, signal })
          ]);
          innerResponse.catch(() => {
          }).then(cleanupAndMarkComplete);
          return innerResponse;
        }
      });
      const outerResponse = outer(innerHandler)(req, metadata);
      outerResponse.catch(() => {
      }).then(maybeAbort);
      return outerResponse;
    };
    return new _HandlerChainBuilder(outerHandler);
  }
};

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
      return i + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values2(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e2) {
          errors = e2 instanceof UnsubscriptionError ? e2.errors : [e2];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values2(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent) {
    var _parentage = this._parentage;
    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
  };
  Subscription2.prototype._addParent = function(parent) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
  };
  Subscription2.prototype._removeParent = function(parent) {
    var _parentage = this._parentage;
    if (_parentage === parent) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipe() {
  var fns = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }
  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now : timestamp2,
            elapsed: now - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values2(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now = _timestampProvider.now();
      var last3 = 0;
      for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
        last3 = i;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay3);
    }
    this.pending = true;
    this.delay = delay3;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay3);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay3);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && this.delay === delay3 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay3) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay3);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e2) {
      errored = true;
      errorValue = e2 ? e2 : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now) {
    if (now === void 0) {
      now = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now;
  }
  Scheduler2.prototype.schedule = function(work, delay3, state) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay3);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 > 0) {
      return _super.prototype.schedule.call(this, state, delay3);
    }
    this.delay = delay3;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay3) {
    return delay3 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay3) : this._execute(state, delay3);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null && delay3 > 0 || delay3 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 !== null && delay3 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay3);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    var _a;
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (delay3 != null ? delay3 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay3);
    }
    var actions = scheduler.actions;
    if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    if (Number.isFinite(delay3)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay3);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay3);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    this.delay = scheduler.frame + delay3;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay3) {
    if (delay3 === void 0) {
      delay3 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay3) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay3);
    }
  };
  VirtualAction2.sortActions = function(a2, b2) {
    if (a2.delay === b2.delay) {
      if (a2.index === b2.index) {
        return 0;
      } else if (a2.index > b2.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a2.delay > b2.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i = 0; i < array.length && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values2(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay3, repeat2) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay3));
    } else {
      this.unsubscribe();
    }
  }, delay3);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay3);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay3);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay3);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay3) {
  if (delay3 === void 0) {
    delay3 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay3));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i = 0;
    return scheduler.schedule(function() {
      if (i === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i) {
    return result[key] = values[i], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i2) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i2], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i2] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i = 0; i < length; i++) {
        _loop_1(i);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand2, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand2 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand2) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a2, i) {
      return map(function(b2, ii) {
        return resultSelector(a2, b2, i, ii);
      })(innerFrom(project(a2, i)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/forkJoin.js
function forkJoin() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;
  var result = new Observable(function(subscriber) {
    var length = sources.length;
    if (!length) {
      subscriber.complete();
      return;
    }
    var values = new Array(length);
    var remainingCompletions = length;
    var remainingEmissions = length;
    var _loop_1 = function(sourceIndex2) {
      var hasValue = false;
      innerFrom(sources[sourceIndex2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (!hasValue) {
          hasValue = true;
          remainingEmissions--;
        }
        values[sourceIndex2] = value;
      }, function() {
        return remainingCompletions--;
      }, void 0, function() {
        if (!remainingCompletions || !hasValue) {
          if (!remainingEmissions) {
            subscriber.next(keys ? createObject(keys, values) : values);
          }
          subscriber.complete();
        }
      }));
    };
    for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {
      _loop_1(sourceIndex);
    }
  });
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}

// node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
var nodeEventEmitterMethods = ["addListener", "removeListener"];
var eventTargetMethods = ["addEventListener", "removeEventListener"];
var jqueryMethods = ["on", "off"];
function fromEvent(target, eventName, options, resultSelector) {
  if (isFunction(options)) {
    resultSelector = options;
    options = void 0;
  }
  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
  }
  var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler, options);
    };
  }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a[0], remove = _a[1];
  if (!add) {
    if (isArrayLike(target)) {
      return mergeMap(function(subTarget) {
        return fromEvent(subTarget, eventName, options);
      })(innerFrom(target));
    }
  }
  if (!add) {
    throw new TypeError("Invalid event target");
  }
  return new Observable(function(subscriber) {
    var handler = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return subscriber.next(1 < args.length ? args : args[0]);
    };
    add(handler);
    return function() {
      return remove(handler);
    };
  });
}
function toCommonHandlerRegistry(target, eventName) {
  return function(methodName) {
    return function(handler) {
      return target[methodName](eventName, handler);
    };
  };
}
function isNodeStyleEventEmitter(target) {
  return isFunction(target.addListener) && isFunction(target.removeListener);
}
function isJQueryStyleEventEmitter(target) {
  return isFunction(target.on) && isFunction(target.off);
}
function isEventTarget(target) {
  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n2 = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n2++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;
function argsOrArgArray(args) {
  return args.length === 1 && isArray3(args[0]) ? args[0] : args;
}

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/race.js
function raceInit(sources) {
  return function(subscriber) {
    var subscriptions = [];
    var _loop_1 = function(i2) {
      subscriptions.push(innerFrom(sources[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (subscriptions) {
          for (var s2 = 0; s2 < subscriptions.length; s2++) {
            s2 !== i2 && subscriptions[s2].unsubscribe();
          }
          subscriptions = null;
        }
        subscriber.next(value);
      })));
    };
    for (var i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {
      _loop_1(i);
    }
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/buffer.js
function buffer(closingNotifier) {
  return operate(function(source, subscriber) {
    var currentBuffer = [];
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return currentBuffer.push(value);
    }, function() {
      subscriber.next(currentBuffer);
      subscriber.complete();
    }));
    innerFrom(closingNotifier).subscribe(createOperatorSubscriber(subscriber, function() {
      var b2 = currentBuffer;
      currentBuffer = [];
      subscriber.next(b2);
    }, noop));
    return function() {
      currentBuffer = null;
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i = index++;
      state = hasState ? accumulator(state, value, i) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatest.js
function combineLatest2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var resultSelector = popResultSelector(args);
  return resultSelector ? pipe(combineLatest2.apply(void 0, __spreadArray([], __read(args))), mapOneOrManyArgs(resultSelector)) : operate(function(source, subscriber) {
    combineLatestInit(__spreadArray([source], __read(argsOrArgArray(args))))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/combineLatestWith.js
function combineLatestWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return combineLatest2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/operators/debounceTime.js
function debounceTime(dueTime, scheduler) {
  if (scheduler === void 0) {
    scheduler = asyncScheduler;
  }
  return operate(function(source, subscriber) {
    var activeTask = null;
    var lastValue = null;
    var lastTime = null;
    var emit = function() {
      if (activeTask) {
        activeTask.unsubscribe();
        activeTask = null;
        var value = lastValue;
        lastValue = null;
        subscriber.next(value);
      }
    };
    function emitWhenIdle() {
      var targetTime = lastTime + dueTime;
      var now = scheduler.now();
      if (now < targetTime) {
        activeTask = this.schedule(void 0, targetTime - now);
        subscriber.add(activeTask);
        return;
      }
      emit();
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      lastValue = value;
      lastTime = scheduler.now();
      if (!activeTask) {
        activeTask = scheduler.schedule(emitWhenIdle, dueTime);
        subscriber.add(activeTask);
      }
    }, function() {
      emit();
      subscriber.complete();
    }, void 0, function() {
      lastValue = activeTask = null;
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/exhaustMap.js
function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function(source) {
      return source.pipe(exhaustMap(function(a2, i) {
        return innerFrom(project(a2, i)).pipe(map(function(b2, ii) {
          return resultSelector(a2, b2, i, ii);
        }));
      }));
    };
  }
  return operate(function(source, subscriber) {
    var index = 0;
    var innerSub = null;
    var isComplete = false;
    source.subscribe(createOperatorSubscriber(subscriber, function(outerValue) {
      if (!innerSub) {
        innerSub = createOperatorSubscriber(subscriber, void 0, function() {
          innerSub = null;
          isComplete && subscriber.complete();
        });
        innerFrom(project(outerValue, index++)).subscribe(innerSub);
      }
    }, function() {
      isComplete = true;
      !innerSub && subscriber.complete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/raceWith.js
function raceWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return !otherSources.length ? identity : operate(function(source, subscriber) {
    raceInit(__spreadArray([source], __read(otherSources)))(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/retry.js
function retry(configOrCount) {
  if (configOrCount === void 0) {
    configOrCount = Infinity;
  }
  var config2;
  if (configOrCount && typeof configOrCount === "object") {
    config2 = configOrCount;
  } else {
    config2 = {
      count: configOrCount
    };
  }
  var _a = config2.count, count2 = _a === void 0 ? Infinity : _a, delay3 = config2.delay, _b = config2.resetOnSuccess, resetOnSuccess = _b === void 0 ? false : _b;
  return count2 <= 0 ? identity : operate(function(source, subscriber) {
    var soFar = 0;
    var innerSub;
    var subscribeForRetry = function() {
      var syncUnsub = false;
      innerSub = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (resetOnSuccess) {
          soFar = 0;
        }
        subscriber.next(value);
      }, void 0, function(err) {
        if (soFar++ < count2) {
          var resub_1 = function() {
            if (innerSub) {
              innerSub.unsubscribe();
              innerSub = null;
              subscribeForRetry();
            } else {
              syncUnsub = true;
            }
          };
          if (delay3 != null) {
            var notifier = typeof delay3 === "number" ? timer(delay3) : innerFrom(delay3(err, soFar));
            var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
              notifierSubscriber_1.unsubscribe();
              resub_1();
            }, function() {
              subscriber.complete();
            });
            notifier.subscribe(notifierSubscriber_1);
          } else {
            resub_1();
          }
        } else {
          subscriber.error(err);
        }
      }));
      if (syncUnsub) {
        innerSub.unsubscribe();
        innerSub = null;
        subscribeForRetry();
      }
    };
    subscribeForRetry();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
function shareReplay(configOrBufferSize, windowTime2, scheduler) {
  var _a, _b, _c;
  var bufferSize;
  var refCount2 = false;
  if (configOrBufferSize && typeof configOrBufferSize === "object") {
    _a = configOrBufferSize.bufferSize, bufferSize = _a === void 0 ? Infinity : _a, _b = configOrBufferSize.windowTime, windowTime2 = _b === void 0 ? Infinity : _b, _c = configOrBufferSize.refCount, refCount2 = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
  } else {
    bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
  }
  return share({
    connector: function() {
      return new ReplaySubject(bufferSize, windowTime2, scheduler);
    },
    resetOnError: true,
    resetOnComplete: false,
    resetOnRefCountZero: refCount2
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/startWith.js
function startWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var scheduler = popScheduler(values);
  return operate(function(source, subscriber) {
    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/rxjs/dist/esm5/internal/operators/withLatestFrom.js
function withLatestFrom() {
  var inputs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    inputs[_i] = arguments[_i];
  }
  var project = popResultSelector(inputs);
  return operate(function(source, subscriber) {
    var len = inputs.length;
    var otherValues = new Array(len);
    var hasValue = inputs.map(function() {
      return false;
    });
    var ready = false;
    var _loop_1 = function(i2) {
      innerFrom(inputs[i2]).subscribe(createOperatorSubscriber(subscriber, function(value) {
        otherValues[i2] = value;
        if (!ready && !hasValue[i2]) {
          hasValue[i2] = true;
          (ready = hasValue.every(identity)) && (hasValue = null);
        }
      }, noop));
    };
    for (var i = 0; i < len; i++) {
      _loop_1(i);
    }
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (ready) {
        var values = __spreadArray([value], __read(otherValues));
        subscriber.next(project ? project.apply(void 0, __spreadArray([], __read(values))) : values);
      }
    }));
  });
}

// node_modules/@snap/camera-kit/dist/common/entries.js
var entries2 = (o) => Object.entries(o);
var fromEntries = (entries3) => Object.fromEntries(entries3);

// node_modules/@snap/camera-kit/dist/logger/logger.js
var logEntriesSubject = new Subject();
var logLevelMap = {
  error: 3,
  warn: 2,
  log: 1,
  info: 1,
  debug: 0
};
function resetLogger() {
  return logEntriesSubject = new Subject();
}
function getLogger(module) {
  return entries2(logLevelMap).reduce((logger28, [level]) => {
    logger28[level] = (...messages) => {
      logEntriesSubject.next({
        time: /* @__PURE__ */ new Date(),
        module,
        level,
        messages
      });
    };
    return logger28;
  }, {});
}

// node_modules/@snap/camera-kit/dist/handlers/retryingHandler.js
var logger = getLogger("retryingHandler");
var logRetry = (responseOrError, sleep3) => {
  logger.warn(`Retrying handler got failed response:`, responseOrError, `Waited ${sleep3} millis, attempting retry now.`);
};
var sleep = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
var randomInRange = (min2, max2) => Math.round(Math.random() * (max2 - min2) + min2);
var defaultOptions = {
  backoffMultiple: 3,
  baseSleep: 500,
  maxSleep: 5 * 1e3,
  maxRetries: 10,
  retryPredicate: (responseOrError) => responseOrError instanceof Response ? !responseOrError.ok : true
};
function ensureClonedRequest(input) {
  return input instanceof Request ? input.clone() : input;
}
var createRetryingHandler = (options = {}) => {
  const definedOptions = copyDefinedProperties(options);
  const { backoffMultiple, baseSleep, maxSleep, maxRetries, retryPredicate } = Object.assign(Object.assign({}, defaultOptions), definedOptions);
  let retryCount = -1;
  const jitterSleep = (priorSleep) => __awaiter(void 0, void 0, void 0, function* () {
    const nextSleep = Math.min(maxSleep, randomInRange(baseSleep, priorSleep * backoffMultiple));
    yield sleep(nextSleep);
    return nextSleep;
  });
  const makeRequestAttempt = (next, priorSleep = baseSleep) => (req, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    retryCount++;
    try {
      const response = yield next(ensureClonedRequest(req), metadata);
      if (retryCount < maxRetries && retryPredicate(response, retryCount)) {
        const nextSleep = yield jitterSleep(priorSleep);
        if ((_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.aborted)
          return response;
        logRetry(response, nextSleep);
        return makeRequestAttempt(next, nextSleep)(req, metadata);
      }
      return response;
    } catch (error) {
      if (!(error instanceof Error)) {
        throw new Error(`Invalid type caught by retrying handler. Handlers may only throw Errors. Got ${JSON.stringify(error)}`);
      }
      if (error.name === "AbortError")
        throw error;
      if (retryCount < maxRetries && retryPredicate(error, retryCount)) {
        const nextSleep = yield jitterSleep(priorSleep);
        if ((_b = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _b === void 0 ? void 0 : _b.aborted)
          throw error;
        logRetry(error, nextSleep);
        return makeRequestAttempt(next, nextSleep)(req, metadata);
      }
      throw error;
    }
  });
  return (next) => makeRequestAttempt(next);
};

// node_modules/@snap/camera-kit/dist/handlers/noCorsRetryingFetchHandler.js
var logger2 = getLogger("noCorsRetryingFetchHandler");
var logRetry2 = (error) => {
  logger2.warn(`NoCorsRetrying handler got failed response:`, error, `Retrying request with {mode: "no-cors"}.`);
};
var createNoCorsRetryingFetchHandler = () => {
  const noCorsRequests = /* @__PURE__ */ new Map();
  return (next) => (input, init = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let requestKey = typeof input === "string" ? input : input.url;
    try {
      requestKey = new URL(requestKey, location.origin).host;
    } catch (_) {
    }
    try {
      return yield next(ensureClonedRequest(input), init);
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError")
        throw error;
      logRetry2(error);
      const noCorsRequest = (_a = noCorsRequests.get(requestKey)) !== null && _a !== void 0 ? _a : next(ensureClonedRequest(input), Object.assign(Object.assign({}, init), { mode: "no-cors" }));
      noCorsRequests.set(requestKey, noCorsRequest);
      yield noCorsRequest;
      noCorsRequests.delete(requestKey);
      return next(ensureClonedRequest(input), init);
    }
  });
};

// node_modules/@snap/camera-kit/dist/common/typeguards.js
function isString(value) {
  return typeof value === "string";
}
function isSafeString(value) {
  return isString(value) && encodeURIComponent(value) === value;
}
function isNumber(value) {
  return typeof value === "number";
}
function isValidNumber(value) {
  return isNumber(value) && !Number.isNaN(value) && Number.isFinite(value);
}
function isValidNumberOrUndefined(value) {
  return isUndefined(value) || isValidNumber(value);
}
function isArrayOfType(elementTypeGuard, value) {
  return Array.isArray(value) && value.every((id) => elementTypeGuard(id));
}
function isSafeStringArray(value) {
  return isArrayOfType(isSafeString, value);
}
function isStringOrUndefined(value) {
  return isUndefined(value) || isString(value);
}
function isArrayBuffer(value) {
  return value instanceof ArrayBuffer;
}
function isTypedArray(value) {
  return value instanceof Object.getPrototypeOf(Uint8Array);
}
function isUndefined(value) {
  return typeof value === "undefined";
}
function isEmptyString(value) {
  return value === "";
}
function isRecord(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function isFunction2(value) {
  return typeof value === "function";
}
function isDate(value) {
  return value instanceof Date;
}
function isDateOrUndefined(value) {
  return isUndefined(value) || isDate(value);
}
function predicateRecordValues(predicate) {
  return (value) => {
    for (const v2 of Object.values(value))
      if (!predicate(v2))
        return false;
    return true;
  };
}
function isEmptyOrSafeUrl(urlString) {
  if (!urlString)
    return true;
  try {
    const url = new URL(urlString);
    return url.protocol === "https:" || url.protocol === "http:";
  } catch (_a) {
    return false;
  }
}
function isPromise2(value) {
  if (!value)
    return false;
  const maybePromise = value;
  return typeof maybePromise.then === "function" && typeof maybePromise.catch === "function";
}

// node_modules/@snap/camera-kit/dist/handlers/timeoutHandler.js
var sleep2 = (millis) => new Promise((resolve) => setTimeout(resolve, millis));
var defaultOptions2 = {
  createError: (request) => {
    const destination = isString(request) ? `for ${request}` : request instanceof Request ? `for ${request.url}` : "";
    return new Error(`Request ${destination} timed out by client timeout handler.`);
  },
  timeout: 30 * 1e3
};
var createTimeoutHandler = (options = {}) => {
  const definedOptions = copyDefinedProperties(options);
  const { createError, timeout: timeout2 } = Object.assign(Object.assign({}, defaultOptions2), definedOptions);
  return (next) => (req, meta) => Promise.race([next(req, meta), sleep2(timeout2).then(() => Promise.reject(createError(req, meta)))]);
};

// node_modules/@snap/camera-kit/dist/handlers/defaultFetchHandler.js
var defaultFetchHandlerFactory = Injectable("defaultFetchHandler", () => {
  return new HandlerChainBuilder(fetch).map(createTimeoutHandler({ timeout: 20 * 1e3 })).map(createNoCorsRetryingFetchHandler()).map(createRetryingHandler({
    maxRetries: 3,
    retryPredicate: (responseOrError) => {
      if (responseOrError instanceof Response) {
        if (responseOrError.ok)
          return false;
        if (responseOrError.status % 400 < 100)
          return false;
      }
      return true;
    }
  })).handler;
});

// node_modules/@snap/camera-kit/dist/handlers/utils.js
function withRequestPriority(request, lowPriority) {
  if (lowPriority) {
    return Object.assign(Object.assign({}, request), { priority: "low" });
  }
  return request;
}

// node_modules/@snap/camera-kit/dist/lens/assets/remoteMediaAssetLoaderFactory.js
var remoteMediaAssetLoaderFactory = Injectable("remoteMediaAssetLoader", [defaultFetchHandlerFactory.token], (fetchHandler) => {
  const handler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return function remoteMediaAssetLoader({ assetDescriptor: { assetId }, lowPriority }) {
    return __awaiter(this, void 0, void 0, function* () {
      const [buffer2, response] = yield handler(assetId, withRequestPriority({ cache: "force-cache" }, lowPriority));
      if (!response.ok)
        throw response;
      return buffer2;
    });
  };
});

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/namespace.js
var Namespace;
(function(Namespace2) {
  Namespace2[Namespace2["DEFAULT"] = 0] = "DEFAULT";
  Namespace2[Namespace2["LENS_CORE"] = 64] = "LENS_CORE";
  Namespace2[Namespace2["CAMERA_KIT_CORE"] = 65] = "CAMERA_KIT_CORE";
  Namespace2[Namespace2["LENS_CORE_CONFIG"] = 143] = "LENS_CORE_CONFIG";
  Namespace2[Namespace2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Namespace || (Namespace = {}));

// node_modules/@bufbuild/protobuf/dist/esm/wire/varint.js
function varint64read() {
  let lowBits = 0;
  let highBits = 0;
  for (let shift = 0; shift < 28; shift += 7) {
    let b2 = this.buf[this.pos++];
    lowBits |= (b2 & 127) << shift;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  let middleByte = this.buf[this.pos++];
  lowBits |= (middleByte & 15) << 28;
  highBits = (middleByte & 112) >> 4;
  if ((middleByte & 128) == 0) {
    this.assertBounds();
    return [lowBits, highBits];
  }
  for (let shift = 3; shift <= 31; shift += 7) {
    let b2 = this.buf[this.pos++];
    highBits |= (b2 & 127) << shift;
    if ((b2 & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
  }
  throw new Error("invalid varint");
}
function varint64write(lo, hi, bytes) {
  for (let i = 0; i < 28; i = i + 7) {
    const shift = lo >>> i;
    const hasNext = !(shift >>> 7 == 0 && hi == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
  const hasMoreBits = !(hi >> 3 == 0);
  bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
  if (!hasMoreBits) {
    return;
  }
  for (let i = 3; i < 31; i = i + 7) {
    const shift = hi >>> i;
    const hasNext = !(shift >>> 7 == 0);
    const byte = (hasNext ? shift | 128 : shift) & 255;
    bytes.push(byte);
    if (!hasNext) {
      return;
    }
  }
  bytes.push(hi >>> 31 & 1);
}
var TWO_PWR_32_DBL = 4294967296;
function int64FromString(dec) {
  const minus = dec[0] === "-";
  if (minus) {
    dec = dec.slice(1);
  }
  const base = 1e6;
  let lowBits = 0;
  let highBits = 0;
  function add1e6digit(begin, end) {
    const digit1e6 = Number(dec.slice(begin, end));
    highBits *= base;
    lowBits = lowBits * base + digit1e6;
    if (lowBits >= TWO_PWR_32_DBL) {
      highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
      lowBits = lowBits % TWO_PWR_32_DBL;
    }
  }
  add1e6digit(-24, -18);
  add1e6digit(-18, -12);
  add1e6digit(-12, -6);
  add1e6digit(-6);
  return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
}
function int64ToString(lo, hi) {
  let bits = newBits(lo, hi);
  const negative = bits.hi & 2147483648;
  if (negative) {
    bits = negate(bits.lo, bits.hi);
  }
  const result = uInt64ToString(bits.lo, bits.hi);
  return negative ? "-" + result : result;
}
function uInt64ToString(lo, hi) {
  ({ lo, hi } = toUnsigned(lo, hi));
  if (hi <= 2097151) {
    return String(TWO_PWR_32_DBL * hi + lo);
  }
  const low = lo & 16777215;
  const mid = (lo >>> 24 | hi << 8) & 16777215;
  const high = hi >> 16 & 65535;
  let digitA = low + mid * 6777216 + high * 6710656;
  let digitB = mid + high * 8147497;
  let digitC = high * 2;
  const base = 1e7;
  if (digitA >= base) {
    digitB += Math.floor(digitA / base);
    digitA %= base;
  }
  if (digitB >= base) {
    digitC += Math.floor(digitB / base);
    digitB %= base;
  }
  return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
}
function toUnsigned(lo, hi) {
  return { lo: lo >>> 0, hi: hi >>> 0 };
}
function newBits(lo, hi) {
  return { lo: lo | 0, hi: hi | 0 };
}
function negate(lowBits, highBits) {
  highBits = ~highBits;
  if (lowBits) {
    lowBits = ~lowBits + 1;
  } else {
    highBits += 1;
  }
  return newBits(lowBits, highBits);
}
var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
  const partial = String(digit1e7);
  return "0000000".slice(partial.length) + partial;
};
function varint32write(value, bytes) {
  if (value >= 0) {
    while (value > 127) {
      bytes.push(value & 127 | 128);
      value = value >>> 7;
    }
    bytes.push(value);
  } else {
    for (let i = 0; i < 9; i++) {
      bytes.push(value & 127 | 128);
      value = value >> 7;
    }
    bytes.push(1);
  }
}
function varint32read() {
  let b2 = this.buf[this.pos++];
  let result = b2 & 127;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 7;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 14;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 127) << 21;
  if ((b2 & 128) == 0) {
    this.assertBounds();
    return result;
  }
  b2 = this.buf[this.pos++];
  result |= (b2 & 15) << 28;
  for (let readBytes = 5; (b2 & 128) !== 0 && readBytes < 10; readBytes++)
    b2 = this.buf[this.pos++];
  if ((b2 & 128) != 0)
    throw new Error("invalid varint");
  this.assertBounds();
  return result >>> 0;
}

// node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
var protoInt64 = makeInt64Support();
function makeInt64Support() {
  const dv = new DataView(new ArrayBuffer(8));
  const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
  if (ok) {
    const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
    return {
      zero: BigInt(0),
      supported: true,
      parse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > MAX || bi < MIN) {
          throw new Error(`invalid int64: ${value}`);
        }
        return bi;
      },
      uParse(value) {
        const bi = typeof value == "bigint" ? value : BigInt(value);
        if (bi > UMAX || bi < UMIN) {
          throw new Error(`invalid uint64: ${value}`);
        }
        return bi;
      },
      enc(value) {
        dv.setBigInt64(0, this.parse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      uEnc(value) {
        dv.setBigInt64(0, this.uParse(value), true);
        return {
          lo: dv.getInt32(0, true),
          hi: dv.getInt32(4, true)
        };
      },
      dec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigInt64(0, true);
      },
      uDec(lo, hi) {
        dv.setInt32(0, lo, true);
        dv.setInt32(4, hi, true);
        return dv.getBigUint64(0, true);
      }
    };
  }
  return {
    zero: "0",
    supported: false,
    parse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return value;
    },
    uParse(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return value;
    },
    enc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertInt64String(value);
      return int64FromString(value);
    },
    uEnc(value) {
      if (typeof value != "string") {
        value = value.toString();
      }
      assertUInt64String(value);
      return int64FromString(value);
    },
    dec(lo, hi) {
      return int64ToString(lo, hi);
    },
    uDec(lo, hi) {
      return uInt64ToString(lo, hi);
    }
  };
}
function assertInt64String(value) {
  if (!/^-?[0-9]+$/.test(value)) {
    throw new Error("invalid int64: " + value);
  }
}
function assertUInt64String(value) {
  if (!/^[0-9]+$/.test(value)) {
    throw new Error("invalid uint64: " + value);
  }
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/text-encoding.js
var symbol = Symbol.for("@bufbuild/protobuf/text-encoding");
function getTextEncoding() {
  if (globalThis[symbol] == void 0) {
    const te = new globalThis.TextEncoder();
    const td = new globalThis.TextDecoder();
    globalThis[symbol] = {
      encodeUtf8(text) {
        return te.encode(text);
      },
      decodeUtf8(bytes) {
        return td.decode(bytes);
      },
      checkUtf8(text) {
        try {
          encodeURIComponent(text);
          return true;
        } catch (e2) {
          return false;
        }
      }
    };
  }
  return globalThis[symbol];
}

// node_modules/@bufbuild/protobuf/dist/esm/wire/binary-encoding.js
var WireType;
(function(WireType2) {
  WireType2[WireType2["Varint"] = 0] = "Varint";
  WireType2[WireType2["Bit64"] = 1] = "Bit64";
  WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
  WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
  WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
  WireType2[WireType2["Bit32"] = 5] = "Bit32";
})(WireType || (WireType = {}));
var FLOAT32_MAX = 34028234663852886e22;
var FLOAT32_MIN = -34028234663852886e22;
var UINT32_MAX = 4294967295;
var INT32_MAX = 2147483647;
var INT32_MIN = -2147483648;
var BinaryWriter = class {
  constructor(encodeUtf8 = getTextEncoding().encodeUtf8) {
    this.encodeUtf8 = encodeUtf8;
    this.stack = [];
    this.chunks = [];
    this.buf = [];
  }
  /**
   * Return all bytes written and reset this writer.
   */
  finish() {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    let len = 0;
    for (let i = 0; i < this.chunks.length; i++)
      len += this.chunks[i].length;
    let bytes = new Uint8Array(len);
    let offset = 0;
    for (let i = 0; i < this.chunks.length; i++) {
      bytes.set(this.chunks[i], offset);
      offset += this.chunks[i].length;
    }
    this.chunks = [];
    return bytes;
  }
  /**
   * Start a new fork for length-delimited data like a message
   * or a packed repeated field.
   *
   * Must be joined later with `join()`.
   */
  fork() {
    this.stack.push({ chunks: this.chunks, buf: this.buf });
    this.chunks = [];
    this.buf = [];
    return this;
  }
  /**
   * Join the last fork. Write its length and bytes, then
   * return to the previous state.
   */
  join() {
    let chunk = this.finish();
    let prev = this.stack.pop();
    if (!prev)
      throw new Error("invalid state, fork stack empty");
    this.chunks = prev.chunks;
    this.buf = prev.buf;
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Writes a tag (field number and wire type).
   *
   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
   *
   * Generated code should compute the tag ahead of time and call `uint32()`.
   */
  tag(fieldNo, type) {
    return this.uint32((fieldNo << 3 | type) >>> 0);
  }
  /**
   * Write a chunk of raw bytes.
   */
  raw(chunk) {
    if (this.buf.length) {
      this.chunks.push(new Uint8Array(this.buf));
      this.buf = [];
    }
    this.chunks.push(chunk);
    return this;
  }
  /**
   * Write a `uint32` value, an unsigned 32 bit varint.
   */
  uint32(value) {
    assertUInt32(value);
    while (value > 127) {
      this.buf.push(value & 127 | 128);
      value = value >>> 7;
    }
    this.buf.push(value);
    return this;
  }
  /**
   * Write a `int32` value, a signed 32 bit varint.
   */
  int32(value) {
    assertInt32(value);
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `bool` value, a variant.
   */
  bool(value) {
    this.buf.push(value ? 1 : 0);
    return this;
  }
  /**
   * Write a `bytes` value, length-delimited arbitrary data.
   */
  bytes(value) {
    this.uint32(value.byteLength);
    return this.raw(value);
  }
  /**
   * Write a `string` value, length-delimited data converted to UTF-8 text.
   */
  string(value) {
    let chunk = this.encodeUtf8(value);
    this.uint32(chunk.byteLength);
    return this.raw(chunk);
  }
  /**
   * Write a `float` value, 32-bit floating point number.
   */
  float(value) {
    assertFloat32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setFloat32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `double` value, a 64-bit floating point number.
   */
  double(value) {
    let chunk = new Uint8Array(8);
    new DataView(chunk.buffer).setFloat64(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
   */
  fixed32(value) {
    assertUInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setUint32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
   */
  sfixed32(value) {
    assertInt32(value);
    let chunk = new Uint8Array(4);
    new DataView(chunk.buffer).setInt32(0, value, true);
    return this.raw(chunk);
  }
  /**
   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
   */
  sint32(value) {
    assertInt32(value);
    value = (value << 1 ^ value >> 31) >>> 0;
    varint32write(value, this.buf);
    return this;
  }
  /**
   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
   */
  sfixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
   */
  fixed64(value) {
    let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
    view.setInt32(0, tc.lo, true);
    view.setInt32(4, tc.hi, true);
    return this.raw(chunk);
  }
  /**
   * Write a `int64` value, a signed 64-bit varint.
   */
  int64(value) {
    let tc = protoInt64.enc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
  /**
   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64(value) {
    let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
    varint64write(lo, hi, this.buf);
    return this;
  }
  /**
   * Write a `uint64` value, an unsigned 64-bit varint.
   */
  uint64(value) {
    let tc = protoInt64.uEnc(value);
    varint64write(tc.lo, tc.hi, this.buf);
    return this;
  }
};
var BinaryReader = class {
  constructor(buf, decodeUtf8 = getTextEncoding().decodeUtf8) {
    this.decodeUtf8 = decodeUtf8;
    this.varint64 = varint64read;
    this.uint32 = varint32read;
    this.buf = buf;
    this.len = buf.length;
    this.pos = 0;
    this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  /**
   * Reads a tag - field number and wire type.
   */
  tag() {
    let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
    if (fieldNo <= 0 || wireType < 0 || wireType > 5)
      throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
    return [fieldNo, wireType];
  }
  /**
   * Skip one element and return the skipped data.
   *
   * When skipping StartGroup, provide the tags field number to check for
   * matching field number in the EndGroup tag.
   */
  skip(wireType, fieldNo) {
    let start = this.pos;
    switch (wireType) {
      case WireType.Varint:
        while (this.buf[this.pos++] & 128) {
        }
        break;
      case WireType.Bit64:
        this.pos += 4;
      case WireType.Bit32:
        this.pos += 4;
        break;
      case WireType.LengthDelimited:
        let len = this.uint32();
        this.pos += len;
        break;
      case WireType.StartGroup:
        for (; ; ) {
          const [fn, wt] = this.tag();
          if (wt === WireType.EndGroup) {
            if (fieldNo !== void 0 && fn !== fieldNo) {
              throw new Error("invalid end group tag");
            }
            break;
          }
          this.skip(wt, fn);
        }
        break;
      default:
        throw new Error("cant skip wire type " + wireType);
    }
    this.assertBounds();
    return this.buf.subarray(start, this.pos);
  }
  /**
   * Throws error if position in byte array is out of range.
   */
  assertBounds() {
    if (this.pos > this.len)
      throw new RangeError("premature EOF");
  }
  /**
   * Read a `int32` field, a signed 32 bit varint.
   */
  int32() {
    return this.uint32() | 0;
  }
  /**
   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
   */
  sint32() {
    let zze = this.uint32();
    return zze >>> 1 ^ -(zze & 1);
  }
  /**
   * Read a `int64` field, a signed 64-bit varint.
   */
  int64() {
    return protoInt64.dec(...this.varint64());
  }
  /**
   * Read a `uint64` field, an unsigned 64-bit varint.
   */
  uint64() {
    return protoInt64.uDec(...this.varint64());
  }
  /**
   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
   */
  sint64() {
    let [lo, hi] = this.varint64();
    let s2 = -(lo & 1);
    lo = (lo >>> 1 | (hi & 1) << 31) ^ s2;
    hi = hi >>> 1 ^ s2;
    return protoInt64.dec(lo, hi);
  }
  /**
   * Read a `bool` field, a variant.
   */
  bool() {
    let [lo, hi] = this.varint64();
    return lo !== 0 || hi !== 0;
  }
  /**
   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
   */
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
   */
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
   */
  fixed64() {
    return protoInt64.uDec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
   */
  sfixed64() {
    return protoInt64.dec(this.sfixed32(), this.sfixed32());
  }
  /**
   * Read a `float` field, 32-bit floating point number.
   */
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, true);
  }
  /**
   * Read a `double` field, a 64-bit floating point number.
   */
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, true);
  }
  /**
   * Read a `bytes` field, length-delimited arbitrary data.
   */
  bytes() {
    let len = this.uint32(), start = this.pos;
    this.pos += len;
    this.assertBounds();
    return this.buf.subarray(start, start + len);
  }
  /**
   * Read a `string` field, length-delimited data converted to UTF-8 text.
   */
  string() {
    return this.decodeUtf8(this.bytes());
  }
};
function assertInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid int32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
    throw new Error("invalid int32: " + arg);
}
function assertUInt32(arg) {
  if (typeof arg == "string") {
    arg = Number(arg);
  } else if (typeof arg != "number") {
    throw new Error("invalid uint32: " + typeof arg);
  }
  if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
    throw new Error("invalid uint32: " + arg);
}
function assertFloat32(arg) {
  if (typeof arg == "string") {
    const o = arg;
    arg = Number(arg);
    if (isNaN(arg) && o !== "NaN") {
      throw new Error("invalid float32: " + o);
    }
  } else if (typeof arg != "number") {
    throw new Error("invalid float32: " + typeof arg);
  }
  if (Number.isFinite(arg) && (arg > FLOAT32_MAX || arg < FLOAT32_MIN))
    throw new Error("invalid float32: " + arg);
}

// node_modules/@bufbuild/protobuf/dist/esm/descriptors.js
var ScalarType;
(function(ScalarType2) {
  ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
  ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
  ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
  ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
  ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
  ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
  ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
  ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
  ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
  ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
  ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
  ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
  ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
  ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
  ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
})(ScalarType || (ScalarType = {}));

// node_modules/@bufbuild/protobuf/dist/esm/reflect/unsafe.js
var unsafeLocal = Symbol.for("reflect unsafe local");

// node_modules/@bufbuild/protobuf/dist/esm/create.js
var tokenZeroMessageField = Symbol();

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/google/protobuf/any.js
function createBaseAny() {
  return { typeUrl: "", value: new Uint8Array(0) };
}
var Any = {
  encode(message, writer = new BinaryWriter()) {
    if (message.typeUrl !== "") {
      writer.uint32(10).string(message.typeUrl);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAny();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.typeUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Any.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseAny();
    message.typeUrl = (_a = object.typeUrl) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array(0);
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/business_events.js
var CameraKitFlavor;
(function(CameraKitFlavor3) {
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_UNSET"] = 0] = "CAMERA_KIT_FLAVOR_UNSET";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_DEBUG"] = 1] = "CAMERA_KIT_FLAVOR_DEBUG";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_RELEASE"] = 2] = "CAMERA_KIT_FLAVOR_RELEASE";
  CameraKitFlavor3[CameraKitFlavor3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitFlavor || (CameraKitFlavor = {}));
var CameraKitConnectivityType;
(function(CameraKitConnectivityType3) {
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNSET"] = 0] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNSET";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_WIFI"] = 1] = "CAMERA_KIT_CONNECTIVITY_TYPE_WIFI";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE"] = 2] = "CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE"] = 3] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH"] = 4] = "CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH";
  CameraKitConnectivityType3[CameraKitConnectivityType3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitConnectivityType || (CameraKitConnectivityType = {}));
var CameraKitEnvironment;
(function(CameraKitEnvironment3) {
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_UNSET"] = 0] = "CAMERA_KIT_ENVIRONMENT_UNSET";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_STAGING"] = 1] = "CAMERA_KIT_ENVIRONMENT_STAGING";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_PRODUCTION"] = 2] = "CAMERA_KIT_ENVIRONMENT_PRODUCTION";
  CameraKitEnvironment3[CameraKitEnvironment3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitEnvironment || (CameraKitEnvironment = {}));
function createBaseExtensionEventBase() {
  return {
    extensionName: "",
    extensionVersion: "",
    deviceCluster: "0",
    cameraKitVersion: "",
    lensCoreVersion: "",
    deviceModel: "",
    cameraKitFlavor: 0,
    appId: "",
    deviceConnectivity: 0,
    sessionId: "",
    cameraKitEnvironment: 0
  };
}
var ExtensionEventBase = {
  encode(message, writer = new BinaryWriter()) {
    if (message.extensionName !== "") {
      writer.uint32(10).string(message.extensionName);
    }
    if (message.extensionVersion !== "") {
      writer.uint32(18).string(message.extensionVersion);
    }
    if (message.deviceCluster !== "0") {
      writer.uint32(24).int64(message.deviceCluster);
    }
    if (message.cameraKitVersion !== "") {
      writer.uint32(34).string(message.cameraKitVersion);
    }
    if (message.lensCoreVersion !== "") {
      writer.uint32(42).string(message.lensCoreVersion);
    }
    if (message.deviceModel !== "") {
      writer.uint32(50).string(message.deviceModel);
    }
    if (message.cameraKitFlavor !== 0) {
      writer.uint32(56).int32(message.cameraKitFlavor);
    }
    if (message.appId !== "") {
      writer.uint32(66).string(message.appId);
    }
    if (message.deviceConnectivity !== 0) {
      writer.uint32(72).int32(message.deviceConnectivity);
    }
    if (message.sessionId !== "") {
      writer.uint32(82).string(message.sessionId);
    }
    if (message.cameraKitEnvironment !== 0) {
      writer.uint32(88).int32(message.cameraKitEnvironment);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionEventBase();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.extensionName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.extensionVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.deviceCluster = reader.int64().toString();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.cameraKitVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.lensCoreVersion = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.deviceModel = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.cameraKitFlavor = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.appId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.deviceConnectivity = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.cameraKitEnvironment = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ExtensionEventBase.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = createBaseExtensionEventBase();
    message.extensionName = (_a = object.extensionName) !== null && _a !== void 0 ? _a : "";
    message.extensionVersion = (_b = object.extensionVersion) !== null && _b !== void 0 ? _b : "";
    message.deviceCluster = (_c = object.deviceCluster) !== null && _c !== void 0 ? _c : "0";
    message.cameraKitVersion = (_d = object.cameraKitVersion) !== null && _d !== void 0 ? _d : "";
    message.lensCoreVersion = (_e = object.lensCoreVersion) !== null && _e !== void 0 ? _e : "";
    message.deviceModel = (_f = object.deviceModel) !== null && _f !== void 0 ? _f : "";
    message.cameraKitFlavor = (_g = object.cameraKitFlavor) !== null && _g !== void 0 ? _g : 0;
    message.appId = (_h = object.appId) !== null && _h !== void 0 ? _h : "";
    message.deviceConnectivity = (_j = object.deviceConnectivity) !== null && _j !== void 0 ? _j : 0;
    message.sessionId = (_k = object.sessionId) !== null && _k !== void 0 ? _k : "";
    message.cameraKitEnvironment = (_l = object.cameraKitEnvironment) !== null && _l !== void 0 ? _l : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/google/protobuf/timestamp.js
function createBaseTimestamp() {
  return { seconds: "0", nanos: 0 };
}
var Timestamp = {
  encode(message, writer = new BinaryWriter()) {
    if (message.seconds !== "0") {
      writer.uint32(8).int64(message.seconds);
    }
    if (message.nanos !== 0) {
      writer.uint32(16).int32(message.nanos);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseTimestamp();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.seconds = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.nanos = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Timestamp.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseTimestamp();
    message.seconds = (_a = object.seconds) !== null && _a !== void 0 ? _a : "0";
    message.nanos = (_b = object.nanos) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/legal_prompt.js
var LegalDocument_Type;
(function(LegalDocument_Type2) {
  LegalDocument_Type2[LegalDocument_Type2["UNSET"] = 0] = "UNSET";
  LegalDocument_Type2[LegalDocument_Type2["TERMS_OF_SERVICE"] = 1] = "TERMS_OF_SERVICE";
  LegalDocument_Type2[LegalDocument_Type2["PRIVACY_POLICY"] = 2] = "PRIVACY_POLICY";
  LegalDocument_Type2[LegalDocument_Type2["LEARN_MORE"] = 3] = "LEARN_MORE";
  LegalDocument_Type2[LegalDocument_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LegalDocument_Type || (LegalDocument_Type = {}));
function createBaseLegalPrompt() {
  return { documents: [], disabled: false };
}
var LegalPrompt = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.documents) {
      LegalDocument.encode(v2, writer.uint32(10).fork()).join();
    }
    if (message.disabled !== false) {
      writer.uint32(16).bool(message.disabled);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLegalPrompt();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.documents.push(LegalDocument.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.disabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return LegalPrompt.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLegalPrompt();
    message.documents = ((_a = object.documents) === null || _a === void 0 ? void 0 : _a.map((e2) => LegalDocument.fromPartial(e2))) || [];
    message.disabled = (_b = object.disabled) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};
function createBaseLegalDocument() {
  return { type: 0, webUrl: "", version: "", timestamp: void 0 };
}
var LegalDocument = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.webUrl !== "") {
      writer.uint32(18).string(message.webUrl);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLegalDocument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.webUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return LegalDocument.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseLegalDocument();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
    message.webUrl = (_b = object.webUrl) !== null && _b !== void 0 ? _b : "";
    message.version = (_c = object.version) !== null && _c !== void 0 ? _c : "";
    message.timestamp = (_d = object.timestamp) !== null && _d !== void 0 ? _d : void 0;
    return message;
  }
};
function toTimestamp(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp(t2) {
  let millis = (globalThis.Number(t2.seconds) || 0) * 1e3;
  millis += (t2.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/lens.js
var Lens_CameraFacing;
(function(Lens_CameraFacing2) {
  Lens_CameraFacing2[Lens_CameraFacing2["CAMERA_FACING_UNSET"] = 0] = "CAMERA_FACING_UNSET";
  Lens_CameraFacing2[Lens_CameraFacing2["CAMERA_FACING_FRONT"] = 1] = "CAMERA_FACING_FRONT";
  Lens_CameraFacing2[Lens_CameraFacing2["CAMERA_FACING_BACK"] = 2] = "CAMERA_FACING_BACK";
  Lens_CameraFacing2[Lens_CameraFacing2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Lens_CameraFacing || (Lens_CameraFacing = {}));
var LensAssetManifestItem_Type;
(function(LensAssetManifestItem_Type2) {
  LensAssetManifestItem_Type2[LensAssetManifestItem_Type2["DEVICE_DEPENDENT_ASSET_UNSET"] = 0] = "DEVICE_DEPENDENT_ASSET_UNSET";
  LensAssetManifestItem_Type2[LensAssetManifestItem_Type2["ASSET"] = 1] = "ASSET";
  LensAssetManifestItem_Type2[LensAssetManifestItem_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LensAssetManifestItem_Type || (LensAssetManifestItem_Type = {}));
var LensAssetManifestItem_RequestTiming;
(function(LensAssetManifestItem_RequestTiming2) {
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["PRELOAD_UNSET"] = 0] = "PRELOAD_UNSET";
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["ON_DEMAND"] = 1] = "ON_DEMAND";
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["REQUIRED"] = 2] = "REQUIRED";
  LensAssetManifestItem_RequestTiming2[LensAssetManifestItem_RequestTiming2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LensAssetManifestItem_RequestTiming || (LensAssetManifestItem_RequestTiming = {}));
function createBaseLens() {
  return {
    id: "",
    name: "",
    vendorData: {},
    content: void 0,
    isThirdParty: false,
    cameraFacingPreference: 0,
    featureMetadata: [],
    lensCreator: void 0,
    scannable: void 0
  };
}
var Lens = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    Object.entries(message.vendorData).forEach(([key, value]) => {
      Lens_VendorDataEntry.encode({ key, value }, writer.uint32(26).fork()).join();
    });
    if (message.content !== void 0) {
      Content.encode(message.content, writer.uint32(34).fork()).join();
    }
    if (message.isThirdParty !== false) {
      writer.uint32(40).bool(message.isThirdParty);
    }
    if (message.cameraFacingPreference !== 0) {
      writer.uint32(48).int32(message.cameraFacingPreference);
    }
    for (const v2 of message.featureMetadata) {
      Any.encode(v2, writer.uint32(58).fork()).join();
    }
    if (message.lensCreator !== void 0) {
      LensCreator.encode(message.lensCreator, writer.uint32(66).fork()).join();
    }
    if (message.scannable !== void 0) {
      Scannable.encode(message.scannable, writer.uint32(74).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          const entry3 = Lens_VendorDataEntry.decode(reader, reader.uint32());
          if (entry3.value !== void 0) {
            message.vendorData[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.content = Content.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.isThirdParty = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.cameraFacingPreference = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.featureMetadata.push(Any.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.lensCreator = LensCreator.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.scannable = Scannable.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Lens.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseLens();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.name = (_b = object.name) !== null && _b !== void 0 ? _b : "";
    message.vendorData = Object.entries((_c = object.vendorData) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.content = object.content !== void 0 && object.content !== null ? Content.fromPartial(object.content) : void 0;
    message.isThirdParty = (_d = object.isThirdParty) !== null && _d !== void 0 ? _d : false;
    message.cameraFacingPreference = (_e = object.cameraFacingPreference) !== null && _e !== void 0 ? _e : 0;
    message.featureMetadata = ((_f = object.featureMetadata) === null || _f === void 0 ? void 0 : _f.map((e2) => Any.fromPartial(e2))) || [];
    message.lensCreator = object.lensCreator !== void 0 && object.lensCreator !== null ? LensCreator.fromPartial(object.lensCreator) : void 0;
    message.scannable = object.scannable !== void 0 && object.scannable !== null ? Scannable.fromPartial(object.scannable) : void 0;
    return message;
  }
};
function createBaseLens_VendorDataEntry() {
  return { key: "", value: "" };
}
var Lens_VendorDataEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLens_VendorDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Lens_VendorDataEntry.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseLens_VendorDataEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseContent() {
  return {
    lnsUrl: "",
    lnsSha256: "",
    iconUrl: "",
    preview: void 0,
    assetManifest: [],
    defaultHintId: "",
    hintTranslations: {},
    lnsUrlBolt: "",
    iconUrlBolt: ""
  };
}
var Content = {
  encode(message, writer = new BinaryWriter()) {
    if (message.lnsUrl !== "") {
      writer.uint32(10).string(message.lnsUrl);
    }
    if (message.lnsSha256 !== "") {
      writer.uint32(18).string(message.lnsSha256);
    }
    if (message.iconUrl !== "") {
      writer.uint32(26).string(message.iconUrl);
    }
    if (message.preview !== void 0) {
      Preview.encode(message.preview, writer.uint32(34).fork()).join();
    }
    for (const v2 of message.assetManifest) {
      LensAssetManifestItem.encode(v2, writer.uint32(42).fork()).join();
    }
    if (message.defaultHintId !== "") {
      writer.uint32(50).string(message.defaultHintId);
    }
    Object.entries(message.hintTranslations).forEach(([key, value]) => {
      Content_HintTranslationsEntry.encode({ key, value }, writer.uint32(58).fork()).join();
    });
    if (message.lnsUrlBolt !== "") {
      writer.uint32(66).string(message.lnsUrlBolt);
    }
    if (message.iconUrlBolt !== "") {
      writer.uint32(74).string(message.iconUrlBolt);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lnsUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lnsSha256 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.iconUrl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.preview = Preview.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.assetManifest.push(LensAssetManifestItem.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.defaultHintId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          const entry7 = Content_HintTranslationsEntry.decode(reader, reader.uint32());
          if (entry7.value !== void 0) {
            message.hintTranslations[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.lnsUrlBolt = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.iconUrlBolt = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Content.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseContent();
    message.lnsUrl = (_a = object.lnsUrl) !== null && _a !== void 0 ? _a : "";
    message.lnsSha256 = (_b = object.lnsSha256) !== null && _b !== void 0 ? _b : "";
    message.iconUrl = (_c = object.iconUrl) !== null && _c !== void 0 ? _c : "";
    message.preview = object.preview !== void 0 && object.preview !== null ? Preview.fromPartial(object.preview) : void 0;
    message.assetManifest = ((_d = object.assetManifest) === null || _d === void 0 ? void 0 : _d.map((e2) => LensAssetManifestItem.fromPartial(e2))) || [];
    message.defaultHintId = (_e = object.defaultHintId) !== null && _e !== void 0 ? _e : "";
    message.hintTranslations = Object.entries((_f = object.hintTranslations) !== null && _f !== void 0 ? _f : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.lnsUrlBolt = (_g = object.lnsUrlBolt) !== null && _g !== void 0 ? _g : "";
    message.iconUrlBolt = (_h = object.iconUrlBolt) !== null && _h !== void 0 ? _h : "";
    return message;
  }
};
function createBaseContent_HintTranslationsEntry() {
  return { key: "", value: "" };
}
var Content_HintTranslationsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContent_HintTranslationsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Content_HintTranslationsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseContent_HintTranslationsEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseLensAssetManifestItem() {
  return { type: 0, id: "", requestTiming: 0, assetUrl: "", assetChecksum: "" };
}
var LensAssetManifestItem = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.id !== "") {
      writer.uint32(18).string(message.id);
    }
    if (message.requestTiming !== 0) {
      writer.uint32(24).int32(message.requestTiming);
    }
    if (message.assetUrl !== "") {
      writer.uint32(34).string(message.assetUrl);
    }
    if (message.assetChecksum !== "") {
      writer.uint32(42).string(message.assetChecksum);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensAssetManifestItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.requestTiming = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.assetUrl = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.assetChecksum = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return LensAssetManifestItem.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseLensAssetManifestItem();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
    message.id = (_b = object.id) !== null && _b !== void 0 ? _b : "";
    message.requestTiming = (_c = object.requestTiming) !== null && _c !== void 0 ? _c : 0;
    message.assetUrl = (_d = object.assetUrl) !== null && _d !== void 0 ? _d : "";
    message.assetChecksum = (_e = object.assetChecksum) !== null && _e !== void 0 ? _e : "";
    return message;
  }
};
function createBasePreview() {
  return { imageUrl: "", imageSequenceSize: 0, imageSequenceWebpUrlPattern: "" };
}
var Preview = {
  encode(message, writer = new BinaryWriter()) {
    if (message.imageUrl !== "") {
      writer.uint32(10).string(message.imageUrl);
    }
    if (message.imageSequenceSize !== 0) {
      writer.uint32(16).int32(message.imageSequenceSize);
    }
    if (message.imageSequenceWebpUrlPattern !== "") {
      writer.uint32(26).string(message.imageSequenceWebpUrlPattern);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePreview();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.imageUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.imageSequenceSize = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.imageSequenceWebpUrlPattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Preview.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBasePreview();
    message.imageUrl = (_a = object.imageUrl) !== null && _a !== void 0 ? _a : "";
    message.imageSequenceSize = (_b = object.imageSequenceSize) !== null && _b !== void 0 ? _b : 0;
    message.imageSequenceWebpUrlPattern = (_c = object.imageSequenceWebpUrlPattern) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseLensCreator() {
  return { displayName: "" };
}
var LensCreator = {
  encode(message, writer = new BinaryWriter()) {
    if (message.displayName !== "") {
      writer.uint32(10).string(message.displayName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensCreator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return LensCreator.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLensCreator();
    message.displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseScannable() {
  return { snapcodeImageUrl: "", snapcodeDeeplink: "" };
}
var Scannable = {
  encode(message, writer = new BinaryWriter()) {
    if (message.snapcodeImageUrl !== "") {
      writer.uint32(10).string(message.snapcodeImageUrl);
    }
    if (message.snapcodeDeeplink !== "") {
      writer.uint32(18).string(message.snapcodeDeeplink);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseScannable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snapcodeImageUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.snapcodeDeeplink = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Scannable.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseScannable();
    message.snapcodeImageUrl = (_a = object.snapcodeImageUrl) !== null && _a !== void 0 ? _a : "";
    message.snapcodeDeeplink = (_b = object.snapcodeDeeplink) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/operational_metrics.js
function createBaseOperationalMetric() {
  return { name: "", timestamp: void 0, metric: void 0 };
}
var OperationalMetric = {
  encode(message, writer = new BinaryWriter()) {
    var _a;
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.timestamp !== void 0) {
      Timestamp.encode(toTimestamp2(message.timestamp), writer.uint32(18).fork()).join();
    }
    switch ((_a = message.metric) === null || _a === void 0 ? void 0 : _a.$case) {
      case "count":
        writer.uint32(24).uint64(message.metric.count);
        break;
      case "latencyMillis":
        writer.uint32(32).uint64(message.metric.latencyMillis);
        break;
      case "histogram":
        writer.uint32(40).int64(message.metric.histogram);
        break;
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOperationalMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.timestamp = fromTimestamp2(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.metric = { $case: "count", count: reader.uint64().toString() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.metric = { $case: "latencyMillis", latencyMillis: reader.uint64().toString() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.metric = { $case: "histogram", histogram: reader.int64().toString() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return OperationalMetric.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = createBaseOperationalMetric();
    message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
    message.timestamp = (_b = object.timestamp) !== null && _b !== void 0 ? _b : void 0;
    if (((_c = object.metric) === null || _c === void 0 ? void 0 : _c.$case) === "count" && ((_d = object.metric) === null || _d === void 0 ? void 0 : _d.count) !== void 0 && ((_e = object.metric) === null || _e === void 0 ? void 0 : _e.count) !== null) {
      message.metric = { $case: "count", count: object.metric.count };
    }
    if (((_f = object.metric) === null || _f === void 0 ? void 0 : _f.$case) === "latencyMillis" && ((_g = object.metric) === null || _g === void 0 ? void 0 : _g.latencyMillis) !== void 0 && ((_h = object.metric) === null || _h === void 0 ? void 0 : _h.latencyMillis) !== null) {
      message.metric = { $case: "latencyMillis", latencyMillis: object.metric.latencyMillis };
    }
    if (((_j = object.metric) === null || _j === void 0 ? void 0 : _j.$case) === "histogram" && ((_k = object.metric) === null || _k === void 0 ? void 0 : _k.histogram) !== void 0 && ((_l = object.metric) === null || _l === void 0 ? void 0 : _l.histogram) !== null) {
      message.metric = { $case: "histogram", histogram: object.metric.histogram };
    }
    return message;
  }
};
function createBaseOperationalMetricsBundle() {
  return { metrics: [] };
}
var OperationalMetricsBundle = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.metrics) {
      OperationalMetric.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOperationalMetricsBundle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.metrics.push(OperationalMetric.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return OperationalMetricsBundle.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseOperationalMetricsBundle();
    message.metrics = ((_a = object.metrics) === null || _a === void 0 ? void 0 : _a.map((e2) => OperationalMetric.fromPartial(e2))) || [];
    return message;
  }
};
function toTimestamp2(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp2(t2) {
  let millis = (globalThis.Number(t2.seconds) || 0) * 1e3;
  millis += (t2.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/ranking.js
var RankingData_OSType;
(function(RankingData_OSType2) {
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_UNSET"] = 0] = "OS_TYPE_UNSET";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_ANDROID"] = 1] = "OS_TYPE_ANDROID";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_IOS"] = 2] = "OS_TYPE_IOS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_IPAD_OS"] = 3] = "OS_TYPE_IPAD_OS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_MAC_OS"] = 4] = "OS_TYPE_MAC_OS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_WINDOWS"] = 5] = "OS_TYPE_WINDOWS";
  RankingData_OSType2[RankingData_OSType2["OS_TYPE_LINUX"] = 6] = "OS_TYPE_LINUX";
  RankingData_OSType2[RankingData_OSType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RankingData_OSType || (RankingData_OSType = {}));
var RankingData_ConnectivityType;
(function(RankingData_ConnectivityType2) {
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_UNSET"] = 0] = "CONNECTIVITY_TYPE_UNSET";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_WIFI"] = 1] = "CONNECTIVITY_TYPE_WIFI";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_MOBILE"] = 2] = "CONNECTIVITY_TYPE_MOBILE";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_UNREACHABLE"] = 3] = "CONNECTIVITY_TYPE_UNREACHABLE";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["CONNECTIVITY_TYPE_BLUETOOTH"] = 4] = "CONNECTIVITY_TYPE_BLUETOOTH";
  RankingData_ConnectivityType2[RankingData_ConnectivityType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RankingData_ConnectivityType || (RankingData_ConnectivityType = {}));
function createBaseRankingData() {
  return { sessionId: "", locale: "", osType: 0, connectivityType: 0 };
}
var RankingData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.locale !== "") {
      writer.uint32(18).string(message.locale);
    }
    if (message.osType !== 0) {
      writer.uint32(24).int32(message.osType);
    }
    if (message.connectivityType !== 0) {
      writer.uint32(32).int32(message.connectivityType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRankingData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.locale = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.osType = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.connectivityType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RankingData.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseRankingData();
    message.sessionId = (_a = object.sessionId) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    message.osType = (_c = object.osType) !== null && _c !== void 0 ? _c : 0;
    message.connectivityType = (_d = object.connectivityType) !== null && _d !== void 0 ? _d : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/service.js
function createBaseGetGroupRequest() {
  return { id: "", rankingData: void 0 };
}
var GetGroupRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.rankingData !== void 0) {
      RankingData.encode(message.rankingData, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.rankingData = RankingData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetGroupRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetGroupRequest();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.rankingData = object.rankingData !== void 0 && object.rankingData !== null ? RankingData.fromPartial(object.rankingData) : void 0;
    return message;
  }
};
function createBaseGetGroupResponse() {
  return { id: "", lenses: [] };
}
var GetGroupResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    for (const v2 of message.lenses) {
      Lens.encode(v2, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lenses.push(Lens.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetGroupResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetGroupResponse();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.lenses = ((_b = object.lenses) === null || _b === void 0 ? void 0 : _b.map((e2) => Lens.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetGroupLensRequest() {
  return { lensId: "", groupId: "" };
}
var GetGroupLensRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.lensId !== "") {
      writer.uint32(10).string(message.lensId);
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupLensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lensId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.groupId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetGroupLensRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetGroupLensRequest();
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.groupId = (_b = object.groupId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseGetGroupLensResponse() {
  return { lens: void 0, groupId: "" };
}
var GetGroupLensResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.lens !== void 0) {
      Lens.encode(message.lens, writer.uint32(10).fork()).join();
    }
    if (message.groupId !== "") {
      writer.uint32(18).string(message.groupId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetGroupLensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lens = Lens.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.groupId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetGroupLensResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetGroupLensResponse();
    message.lens = object.lens !== void 0 && object.lens !== null ? Lens.fromPartial(object.lens) : void 0;
    message.groupId = (_a = object.groupId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseBatchGetGroupLensRequest() {
  return { getRequests: [] };
}
var BatchGetGroupLensRequest = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.getRequests) {
      GetGroupLensRequest.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBatchGetGroupLensRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.getRequests.push(GetGroupLensRequest.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BatchGetGroupLensRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBatchGetGroupLensRequest();
    message.getRequests = ((_a = object.getRequests) === null || _a === void 0 ? void 0 : _a.map((e2) => GetGroupLensRequest.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseBatchGetGroupLensResponse() {
  return { getResponses: [] };
}
var BatchGetGroupLensResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.getResponses) {
      GetGroupLensResponse.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBatchGetGroupLensResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.getResponses.push(GetGroupLensResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BatchGetGroupLensResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBatchGetGroupLensResponse();
    message.getResponses = ((_a = object.getResponses) === null || _a === void 0 ? void 0 : _a.map((e2) => GetGroupLensResponse.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetPlaceholderConfigRequest() {
  return {};
}
var GetPlaceholderConfigRequest = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceholderConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetPlaceholderConfigRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseGetPlaceholderConfigRequest();
    return message;
  }
};
function createBaseGetPlaceholderConfigResponse() {
  return { configs: {} };
}
var GetPlaceholderConfigResponse = {
  encode(message, writer = new BinaryWriter()) {
    Object.entries(message.configs).forEach(([key, value]) => {
      GetPlaceholderConfigResponse_ConfigsEntry.encode({ key, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceholderConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          const entry1 = GetPlaceholderConfigResponse_ConfigsEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.configs[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetPlaceholderConfigResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetPlaceholderConfigResponse();
    message.configs = Object.entries((_a = object.configs) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  }
};
function createBaseGetPlaceholderConfigResponse_ConfigsEntry() {
  return { key: "", value: "" };
}
var GetPlaceholderConfigResponse_ConfigsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPlaceholderConfigResponse_ConfigsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetPlaceholderConfigResponse_ConfigsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetPlaceholderConfigResponse_ConfigsEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseGetInitializationConfigRequest() {
  return {};
}
var GetInitializationConfigRequest = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInitializationConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetInitializationConfigRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseGetInitializationConfigRequest();
    return message;
  }
};
function createBaseGetInitializationConfigResponse() {
  return {
    appVendorUuidOptIn: false,
    watermarkEnabled: false,
    childrenProtectionActRestricted: false,
    legalPrompt: void 0
  };
}
var GetInitializationConfigResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.appVendorUuidOptIn !== false) {
      writer.uint32(8).bool(message.appVendorUuidOptIn);
    }
    if (message.watermarkEnabled !== false) {
      writer.uint32(16).bool(message.watermarkEnabled);
    }
    if (message.childrenProtectionActRestricted !== false) {
      writer.uint32(24).bool(message.childrenProtectionActRestricted);
    }
    if (message.legalPrompt !== void 0) {
      LegalPrompt.encode(message.legalPrompt, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetInitializationConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.appVendorUuidOptIn = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.watermarkEnabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.childrenProtectionActRestricted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.legalPrompt = LegalPrompt.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetInitializationConfigResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseGetInitializationConfigResponse();
    message.appVendorUuidOptIn = (_a = object.appVendorUuidOptIn) !== null && _a !== void 0 ? _a : false;
    message.watermarkEnabled = (_b = object.watermarkEnabled) !== null && _b !== void 0 ? _b : false;
    message.childrenProtectionActRestricted = (_c = object.childrenProtectionActRestricted) !== null && _c !== void 0 ? _c : false;
    message.legalPrompt = object.legalPrompt !== void 0 && object.legalPrompt !== null ? LegalPrompt.fromPartial(object.legalPrompt) : void 0;
    return message;
  }
};
function createBaseSetOperationalMetricsRequest() {
  return { metrics: void 0 };
}
var SetOperationalMetricsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.metrics !== void 0) {
      OperationalMetricsBundle.encode(message.metrics, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetOperationalMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.metrics = OperationalMetricsBundle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SetOperationalMetricsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseSetOperationalMetricsRequest();
    message.metrics = object.metrics !== void 0 && object.metrics !== null ? OperationalMetricsBundle.fromPartial(object.metrics) : void 0;
    return message;
  }
};
function createBaseSetOperationalMetricsResponse() {
  return {};
}
var SetOperationalMetricsResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetOperationalMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SetOperationalMetricsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseSetOperationalMetricsResponse();
    return message;
  }
};
function createBaseSetBusinessEventsRequest() {
  return { batchEvents: void 0 };
}
var SetBusinessEventsRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.batchEvents !== void 0) {
      Any.encode(message.batchEvents, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetBusinessEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.batchEvents = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SetBusinessEventsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseSetBusinessEventsRequest();
    message.batchEvents = object.batchEvents !== void 0 && object.batchEvents !== null ? Any.fromPartial(object.batchEvents) : void 0;
    return message;
  }
};
function createBaseSetBusinessEventsResponse() {
  return {};
}
var SetBusinessEventsResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetBusinessEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SetBusinessEventsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseSetBusinessEventsResponse();
    return message;
  }
};
function createBaseSetExtensionBusinessEventsRequest() {
  return { events: [], extensionEventBase: void 0 };
}
var SetExtensionBusinessEventsRequest = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.events) {
      Any.encode(v2, writer.uint32(10).fork()).join();
    }
    if (message.extensionEventBase !== void 0) {
      ExtensionEventBase.encode(message.extensionEventBase, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetExtensionBusinessEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.events.push(Any.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.extensionEventBase = ExtensionEventBase.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SetExtensionBusinessEventsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSetExtensionBusinessEventsRequest();
    message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e2) => Any.fromPartial(e2))) || [];
    message.extensionEventBase = object.extensionEventBase !== void 0 && object.extensionEventBase !== null ? ExtensionEventBase.fromPartial(object.extensionEventBase) : void 0;
    return message;
  }
};
function createBaseSetExtensionBusinessEventsResponse() {
  return {};
}
var SetExtensionBusinessEventsResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSetExtensionBusinessEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SetExtensionBusinessEventsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseSetExtensionBusinessEventsResponse();
    return message;
  }
};
var LensesDefinition = {
  name: "Lenses",
  fullName: "com.snap.camerakit.v3.Lenses",
  methods: {
    getGroup: {
      name: "GetGroup",
      requestType: GetGroupRequest,
      requestStream: false,
      responseType: GetGroupResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS",
        _unknownFields: {
          578365826: [
            new Uint8Array([
              43,
              18,
              41,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              76,
              101,
              110,
              115,
              101,
              115,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              123,
              105,
              100,
              125
            ])
          ]
        }
      }
    },
    getGroupLens: {
      name: "GetGroupLens",
      requestType: GetGroupLensRequest,
      requestStream: false,
      responseType: GetGroupLensResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS",
        _unknownFields: {
          578365826: [
            new Uint8Array([
              66,
              18,
              64,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              76,
              101,
              110,
              115,
              101,
              115,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              47,
              123,
              103,
              114,
              111,
              117,
              112,
              95,
              105,
              100,
              125,
              47,
              108,
              101,
              110,
              115,
              101,
              115,
              47,
              123,
              108,
              101,
              110,
              115,
              95,
              105,
              100,
              125
            ])
          ]
        }
      }
    },
    batchGetGroupLens: {
      name: "BatchGetGroupLens",
      requestType: BatchGetGroupLensRequest,
      requestStream: false,
      responseType: BatchGetGroupLensResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS",
        _unknownFields: {
          578365826: [
            new Uint8Array([
              58,
              34,
              53,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              76,
              101,
              110,
              115,
              101,
              115,
              47,
              103,
              114,
              111,
              117,
              112,
              115,
              95,
              108,
              101,
              110,
              115,
              101,
              115,
              47,
              98,
              97,
              116,
              99,
              104,
              95,
              103,
              101,
              116,
              58,
              1,
              42
            ])
          ]
        }
      }
    },
    getPlaceholderConfig: {
      name: "GetPlaceholderConfig",
      requestType: GetPlaceholderConfigRequest,
      requestStream: false,
      responseType: GetPlaceholderConfigResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS",
        _unknownFields: {
          578365826: [
            new Uint8Array([
              50,
              18,
              48,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              76,
              101,
              110,
              115,
              101,
              115,
              47,
              112,
              108,
              97,
              99,
              101,
              104,
              111,
              108,
              100,
              101,
              114,
              95,
              99,
              111,
              110,
              102,
              105,
              103
            ])
          ]
        }
      }
    }
  }
};
var MetricsDefinition = {
  name: "Metrics",
  fullName: "com.snap.camerakit.v3.Metrics",
  methods: {
    setOperationalMetrics: {
      name: "SetOperationalMetrics",
      requestType: SetOperationalMetricsRequest,
      requestStream: false,
      responseType: SetOperationalMetricsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              63,
              34,
              58,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              77,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              111,
              112,
              101,
              114,
              97,
              116,
              105,
              111,
              110,
              97,
              108,
              95,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              58,
              1,
              42
            ])
          ]
        }
      }
    },
    setBusinessEvents: {
      name: "SetBusinessEvents",
      requestType: SetBusinessEventsRequest,
      requestStream: false,
      responseType: SetBusinessEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              59,
              34,
              54,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              77,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              98,
              117,
              115,
              105,
              110,
              101,
              115,
              115,
              95,
              101,
              118,
              101,
              110,
              116,
              115,
              58,
              1,
              42
            ])
          ]
        }
      }
    },
    setExtensionBusinessEvents: {
      name: "SetExtensionBusinessEvents",
      requestType: SetExtensionBusinessEventsRequest,
      requestStream: false,
      responseType: SetExtensionBusinessEventsResponse,
      responseStream: false,
      options: {
        _unknownFields: {
          578365826: [
            new Uint8Array([
              69,
              34,
              64,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              77,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              101,
              120,
              116,
              101,
              110,
              115,
              105,
              111,
              110,
              95,
              98,
              117,
              115,
              105,
              110,
              101,
              115,
              115,
              95,
              101,
              118,
              101,
              110,
              116,
              115,
              58,
              1,
              42
            ])
          ]
        }
      }
    },
    getInitializationConfig: {
      name: "GetInitializationConfig",
      requestType: GetInitializationConfigRequest,
      requestStream: false,
      responseType: GetInitializationConfigResponse,
      responseStream: false,
      options: {
        idempotencyLevel: "NO_SIDE_EFFECTS",
        _unknownFields: {
          578365826: [
            new Uint8Array([
              62,
              18,
              60,
              47,
              99,
              111,
              109,
              46,
              115,
              110,
              97,
              112,
              46,
              99,
              97,
              109,
              101,
              114,
              97,
              107,
              105,
              116,
              46,
              118,
              51,
              46,
              77,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              109,
              101,
              116,
              114,
              105,
              99,
              115,
              47,
              105,
              110,
              105,
              116,
              105,
              97,
              108,
              105,
              122,
              97,
              116,
              105,
              111,
              110,
              95,
              99,
              111,
              110,
              102,
              105,
              103
            ])
          ]
        }
      }
    }
  }
};

// node_modules/@snap/camera-kit/dist/clients/grpcHandler.js
var import_grpc_web = __toESM(require_grpc_web_client_umd());

// node_modules/@snap/camera-kit/dist/common/result.js
var OkResult = class _OkResult {
  constructor(value) {
    this.value = value;
    this.ok = true;
  }
  unwrap() {
    return this.value;
  }
  unwrapErr() {
    throw new Error("Ok Result cannot unwrapErr.");
  }
  map(m2) {
    return new _OkResult(m2(this.value));
  }
  flatMap(m2) {
    return m2(this.value);
  }
};
var Ok = (value) => new OkResult(value);
var ErrResult = class {
  constructor(value) {
    this.value = value;
    this.ok = false;
  }
  unwrap() {
    throw this.value;
  }
  unwrapErr() {
    return this.value;
  }
  map() {
    return this;
  }
  flatMap() {
    return this;
  }
};
var Err = (value) => new ErrResult(value);

// node_modules/@snap/camera-kit/dist/common/memoize.js
function memoize2(delegate) {
  let memo;
  const memoized = (...args) => {
    if (typeof memo !== "undefined")
      return memo;
    memo = delegate(...args);
    return memo;
  };
  memoized.delegate = delegate;
  return memoized;
}

// node_modules/@snap/camera-kit/dist/environment.js
var environment_default = { PACKAGE_VERSION: "1.4.0" };

// node_modules/@snap/camera-kit/dist/lensCoreWasmVersions.js
var lensCoreWasmVersions_default = {
  version: "305",
  buildNumber: "574",
  baseUrl: "https://cf-st.sc-cdn.net/d/mJaVaSIsblEzSy0An5Tei?go=IgsKCTIBBEgBUFxgAQ%3D%3D&uc=92"
};

// node_modules/@snap/camera-kit/dist/platform/platformInfo.js
function isNavigatorUAData(value) {
  return isRecord(value) && Array.isArray(value["brands"]) && value["brands"].every((brand) => {
    return isRecord(brand) && typeof brand["brand"] === "string" && typeof brand["version"] === "string";
  }) && typeof value["mobile"] === "boolean" && typeof value["platform"] === "string";
}
function parseDeviceModel(userAgent) {
  const userAgentWithModel = userAgent.match(/;[^;]+?;([^\)]+?)\)/);
  if (userAgentWithModel) {
    return userAgentWithModel[1].trim();
  }
  const userAgentWithModel2 = userAgent.match(/\(([^;]+);/);
  if (userAgentWithModel2) {
    return userAgentWithModel2[1].trim();
  }
  return "unknown";
}
function parseOrigin() {
  var _a, _b, _c;
  if (location.hostname !== "")
    return location.hostname;
  const possibleOrigins = location.ancestorOrigins === void 0 && typeof window !== "undefined" ? [window.parent.origin, (_b = (_a = window.top) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : ""] : (_c = location.ancestorOrigins) !== null && _c !== void 0 ? _c : [];
  for (let origin of possibleOrigins) {
    try {
      origin = new URL(origin).hostname;
      if (origin)
        return origin;
    } catch (_) {
    }
  }
  return "unknown";
}
function parseOSName(userAgent) {
  const knownPlatforms = /* @__PURE__ */ new Map([
    ["android", "android"],
    ["linux", "linux"],
    ["iphone os", "ios"],
    ["ipad", "ipados"],
    ["mac os", "macos"],
    ["macos", "macos"],
    ["windows", "windows"]
  ]);
  const normalizedUserAgent = userAgent.toLowerCase();
  for (const [match, platform] of knownPlatforms.entries()) {
    if (normalizedUserAgent.includes(match))
      return platform;
  }
  return "unknown";
}
function parseOSVersion(userAgent) {
  const versionMatch = userAgent.match(/\s([\d][\d_.]*[\d])(;|\)|\s)/);
  if (versionMatch != null) {
    return versionMatch[1].replace(/_/g, ".");
  }
  return "";
}
function parseUserAgentData(userAgent) {
  let brand;
  if (/Chrome/.test(userAgent)) {
    const versionMatch = userAgent.match(/Chrome\/([\d.]+)/);
    brand = {
      brand: "Chrome",
      version: versionMatch !== null ? versionMatch[1] : "unknown"
    };
  } else if (/Safari/.test(userAgent)) {
    let versionMatch = userAgent.match(/Version\/([\d.]+)/);
    if (versionMatch === null)
      versionMatch = userAgent.match(/Safari\/([\d.]+)/);
    brand = {
      brand: "Safari",
      version: versionMatch !== null ? versionMatch[1] : "unknown"
    };
  } else {
    brand = {
      brand: "Firefox",
      version: "0"
    };
  }
  const mobile = false;
  const platform = parseOSName(userAgent);
  return {
    brands: [brand],
    mobile,
    platform
  };
}
function normalizeBrands(brands) {
  const knownBrands = /* @__PURE__ */ new Map([
    ["Google Chrome", "Chrome"],
    ["Chrome", "Chrome"],
    ["Chromium", "Chrome"],
    ["Firefox", "Firefox"],
    ["Microsoft Edge", "Chrome"],
    ["Safari", "Safari"]
  ]);
  const normalizedBrands = brands.filter(({ brand }) => knownBrands.has(brand)).map((brand) => {
    return {
      brand: knownBrands.get(brand.brand),
      version: brand.version
    };
  });
  if (normalizedBrands.length === 0)
    return [{ brand: "Firefox", version: "0" }];
  return normalizedBrands;
}
function normalizeUserAgentData(userAgentData) {
  return {
    brands: normalizeBrands(userAgentData.brands),
    mobile: userAgentData.mobile,
    platform: parseOSName(userAgentData.platform)
  };
}
var getPlatformInfo = memoize2(function getPlatformInfo2() {
  var _a, _b, _c;
  const userAgent = navigator.userAgent;
  const userAgentData = isNavigatorUAData(navigator.userAgentData) ? normalizeUserAgentData(navigator.userAgentData) : parseUserAgentData(userAgent);
  const osVersion = parseOSVersion(userAgent);
  const deviceModel = parseDeviceModel(userAgent);
  const sdkShortVersion = environment_default.PACKAGE_VERSION.replace(/[-+]\S+$/, "");
  const locale = navigator.language;
  const fullLocale = ((_a = navigator.languages) !== null && _a !== void 0 ? _a : []).map((lang, index) => {
    const qvalue = Math.max(0, (10 - index) / 10);
    return `${lang};q=${qvalue.toFixed(1)}`;
  }).join(", ") || locale;
  return {
    sdkShortVersion,
    sdkLongVersion: environment_default.PACKAGE_VERSION,
    lensCore: lensCoreWasmVersions_default,
    browser: userAgentData.brands[0],
    osName: userAgentData.platform,
    osVersion,
    deviceModel,
    locale,
    fullLocale,
    origin: parseOrigin(),
    connectionType: (_c = (_b = navigator.connection) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : "unknown"
  };
});

// node_modules/@snap/camera-kit/dist/platform/cameraKitUserAgent.js
var getCameraKitUserAgent = memoize2(function getCameraKitUserAgent2() {
  var _a;
  const { browser, deviceModel, origin, osName, osVersion, sdkShortVersion, lensCore } = getPlatformInfo();
  const { userAgentFlavor } = (_a = getConfigurationOverrides()) !== null && _a !== void 0 ? _a : { userAgentFlavor: "release" };
  const flavor = userAgentFlavor === "release" ? "" : "DEBUG ";
  return `CameraKitWeb/${sdkShortVersion} ${flavor}(${deviceModel}; ${osName} ${osVersion}) ${browser.brand}/${browser.version} Core/${lensCore.version} AppId/${origin}`;
});

// node_modules/@snap/camera-kit/dist/handlers/headersModifyingFetchHandler.js
var createHeadersModifyingFetchHandler = (modifyHeaders) => (next) => (input, init) => {
  const headers = init && init.headers ? new Headers(init.headers) : typeof input === "string" ? new Headers() : input.headers;
  const modifiedHeaders = modifyHeaders(headers);
  return next(input, Object.assign(Object.assign({}, init), { headers: modifiedHeaders }));
};

// node_modules/@snap/camera-kit/dist/handlers/cameraKitServiceFetchHandlerFactory.js
var cameraKitServiceFetchHandlerFactory = Injectable("cameraKitServiceFetchHandler", [configurationToken, defaultFetchHandlerFactory.token], ({ apiToken }, defaultFetchHandler) => {
  return new HandlerChainBuilder(defaultFetchHandler).map(createHeadersModifyingFetchHandler((headers) => {
    headers.append("x-snap-client-user-agent", getCameraKitUserAgent());
    headers.append("authorization", `Bearer ${apiToken}`);
    return headers;
  })).handler;
});

// node_modules/@snap/camera-kit/dist/common/errorHelpers.js
function stringifyError(error) {
  var _a;
  const outer = (_a = error.stack) !== null && _a !== void 0 ? _a : "";
  return error.cause ? `${outer}
Caused by:
	${stringifyError(ensureError(error.cause))}` : outer;
}
function stringifyErrorMessage(error) {
  const cause = error.cause ? `; Caused by ${stringifyErrorMessage(ensureError(error.cause))}` : "";
  return `${error.name}: ${error.message}${cause}`;
}
function ensureError(error) {
  if (error instanceof Error)
    return error;
  try {
    return new Error(`Non-Error type exception thrown. Serialized error value: ${JSON.stringify(error)}`);
  } catch (_) {
    return new Error("Non-Error type exception thrown. Original error value could not be serialized.");
  }
}

// node_modules/@snap/camera-kit/dist/events/TypedCustomEvent.js
var TypedCustomEvent = class extends CustomEvent {
  constructor(type, detail, eventInitDict = {}) {
    super(type, Object.assign(Object.assign({}, eventInitDict), { detail }));
  }
};

// node_modules/@snap/camera-kit/dist/events/TypedEventTarget.js
var TypedEventTarget = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Map();
    this.options = /* @__PURE__ */ new Map();
  }
  addEventListener(type, callback, options) {
    var _a;
    const listener = callback;
    const listeners = (_a = this.listeners.get(type)) !== null && _a !== void 0 ? _a : [];
    this.listeners.set(type, [...listeners, listener]);
    if (options)
      this.options.set(listener, options);
  }
  dispatchEvent(event) {
    const listeners = this.listeners.get(event.type);
    if (!listeners)
      return true;
    listeners.forEach((listener) => {
      var _a;
      const options = (_a = this.options.get(listener)) !== null && _a !== void 0 ? _a : {};
      try {
        listener(event);
      } catch (error) {
        if (window)
          window.dispatchEvent(new CustomEvent("error", { detail: error }));
      }
      if (options.once)
        this.removeEventListener(event.type, listener);
    });
    return true;
  }
  removeEventListener(type, callback) {
    const listener = callback;
    const listeners = this.listeners.get(type);
    if (!listeners)
      return;
    this.listeners.set(type, listeners.filter((l2) => l2 !== listener));
    this.options.delete(listener);
  }
};

// node_modules/@snap/camera-kit/dist/common/time.js
var getTimeMs = () => performance.now();
var convertDaysToSeconds = (days) => days * 24 * 60 * 60;

// node_modules/@snap/camera-kit/dist/metrics/operational/Metric.js
var nameDelimiter = "_";
var dimensionDelimiter = ".";
var delimiterRegex = new RegExp(`^${nameDelimiter}+|${nameDelimiter}+$`, "g");
var Metric = class {
  constructor(name, dimensions = {}) {
    this.name = name;
    this.dimensions = dimensions;
  }
  child(constructor, name, dimensions = {}) {
    return new constructor(`${this.name}${nameDelimiter}${name}`, dimensions);
  }
};
function joinMetricNames(names) {
  return names.join(nameDelimiter).replace(delimiterRegex, "");
}
function serializeMetricDimensions(dimensions) {
  if (Object.keys(dimensions).length === 0)
    return "";
  return `${dimensionDelimiter}${Array.from(Object.entries(dimensions)).map((d2) => d2.join(dimensionDelimiter)).join(dimensionDelimiter)}`;
}

// node_modules/@snap/camera-kit/dist/metrics/operational/Timer.js
var Timer = class _Timer extends Metric {
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.startTime = getTimeMs();
    this.stopped = false;
    this.marks = /* @__PURE__ */ new Set();
    this.measures = /* @__PURE__ */ new Set();
  }
  getMeasures() {
    return Array.from(this.measures.values()).concat(...Array.from(this.marks.values()).map((mark) => mark.getMeasures()));
  }
  mark(name, dimensions = {}) {
    const mark = new _Timer(joinMetricNames([this.name, name]), dimensions);
    if (this.stopped)
      mark.stop();
    this.marks.add(mark);
    return mark;
  }
  measure(nameOrDimensions, maybeDimensions) {
    if (this.stopped)
      return void 0;
    const name = typeof nameOrDimensions === "string" ? nameOrDimensions : "";
    const dimensions = typeof nameOrDimensions === "string" ? maybeDimensions : nameOrDimensions;
    const fullName = joinMetricNames([this.name, name]);
    const measure = {
      name: fullName,
      duration: getTimeMs() - this.startTime,
      dimensions: dimensions !== null && dimensions !== void 0 ? dimensions : this.dimensions
    };
    this.measures.add(measure);
    return measure;
  }
  clear() {
    this.measures.clear();
    this.marks.forEach((mark) => mark.clear());
  }
  stop() {
    this.stopped = true;
    this.marks.forEach((mark) => mark.stop());
  }
  stopAndReport(client) {
    return __awaiter(this, void 0, void 0, function* () {
      client.setOperationalMetrics(this);
      this.stop();
      this.clear();
    });
  }
  toOperationalMetric() {
    const timestamp2 = /* @__PURE__ */ new Date();
    return this.getMeasures().map((measure) => ({
      name: `${measure.name}${serializeMetricDimensions(measure.dimensions)}`,
      timestamp: timestamp2,
      metric: {
        $case: "latencyMillis",
        latencyMillis: `${Math.ceil(measure.duration)}`
      }
    }));
  }
};

// node_modules/@snap/camera-kit/dist/handlers/requestStateEmittingHandler.js
var requestId = 0;
var safeParseInt = (str) => {
  if (str == null)
    return 0;
  const maybeInt = parseInt(str);
  return isNaN(maybeInt) ? 0 : maybeInt;
};
var dispatchRequestStarted = (requestStateEventTarget, data) => {
  const started = Object.assign(Object.assign({}, data), { requestId: requestId++, timer: new Timer("download_latency") });
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("started", started));
  return started;
};
var dispatchRequestCompleted = (requestStateEventTarget, data) => {
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("completed", data));
  return data;
};
var dispatchRequestErrored = (requestStateEventTarget, data) => {
  requestStateEventTarget.dispatchEvent(new TypedCustomEvent("errored", data));
  return data;
};
var createRequestStateEmittingHandler = (requestStateEventTarget) => (next) => ([request, dimensions], metadata) => __awaiter(void 0, void 0, void 0, function* () {
  const { requestId: requestId2 } = dispatchRequestStarted(requestStateEventTarget, { dimensions });
  try {
    const response = yield next(request, metadata);
    const status = response.status;
    const sizeByte = safeParseInt(response.headers.get("content-length"));
    dispatchRequestCompleted(requestStateEventTarget, { requestId: requestId2, dimensions, status, sizeByte });
    return response;
  } catch (error) {
    dispatchRequestErrored(requestStateEventTarget, { requestId: requestId2, dimensions, error: ensureError(error) });
    throw error;
  }
});
var requestStateEventTargetFactory = Injectable("requestStateEventTarget", () => new TypedEventTarget());

// node_modules/@snap/camera-kit/dist/clients/grpcHandler.js
var GRPC_CALL_REQUEST_TYPE = "grpc_call";
function isMetricsGrpcMethod(method) {
  return method === MetricsDefinition.methods.setOperationalMetrics.name || method === MetricsDefinition.methods.setBusinessEvents.name;
}
var grpcHandlerFactory = Injectable("grpcHandlerFactory", [configurationToken, cameraKitServiceFetchHandlerFactory.token, requestStateEventTargetFactory.token], (configuration, fetchHandler, requestStateEventTarget) => {
  const host = `https://${configuration.apiHostname}`;
  const fetchHandlerWithMetrics = new HandlerChainBuilder(fetchHandler).map(createRequestStateEmittingHandler(requestStateEventTarget)).handler;
  const transport = (options) => {
    let metadata = void 0;
    const controller = globalThis.AbortController ? new AbortController() : void 0;
    let cancelled = false;
    return {
      sendMessage(msgBytes) {
        var _a;
        const requestInit = {
          headers: (_a = metadata === null || metadata === void 0 ? void 0 : metadata.toHeaders()) !== null && _a !== void 0 ? _a : {},
          method: "POST",
          body: msgBytes,
          signal: controller === null || controller === void 0 ? void 0 : controller.signal
        };
        const metricsDimensions = {
          requestType: GRPC_CALL_REQUEST_TYPE,
          methodName: options.methodDefinition.methodName
        };
        const request = isMetricsGrpcMethod(options.methodDefinition.methodName) ? fetchHandler(options.url, requestInit) : fetchHandlerWithMetrics([options.url, metricsDimensions], requestInit);
        request.then((response) => {
          options.onHeaders(new import_grpc_web.grpc.Metadata(response.headers), response.status);
          return response.arrayBuffer();
        }).then((body) => {
          if (cancelled)
            return;
          options.onChunk(new Uint8Array(body));
          options.onEnd();
        }).catch((error) => {
          if (cancelled)
            return;
          cancelled = true;
          options.onEnd(error);
        });
      },
      start(m2) {
        metadata = m2;
      },
      finishSend() {
      },
      cancel() {
        if (cancelled)
          return;
        cancelled = true;
        controller === null || controller === void 0 ? void 0 : controller.abort();
      }
    };
  };
  return (request) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => {
      import_grpc_web.grpc.unary({
        methodName: request.methodName,
        service: { serviceName: request.serviceName },
        requestStream: false,
        responseStream: false,
        requestType: request.requestType,
        responseType: request.responseType
      }, {
        request: new request.requestType(),
        host,
        onEnd: (response) => {
          if (isUnaryOutputOk(response)) {
            resolve(Ok(response));
          } else {
            resolve(Err(response));
          }
        },
        transport
      });
    });
  });
});
function isUnaryOutputOk(value) {
  return value.status === import_grpc_web.grpc.Code.OK;
}

// node_modules/@snap/camera-kit/dist/clients/createTsProtoClient.js
function messageClass(message, data) {
  return class Message {
    constructor() {
      Object.assign(this, message.fromPartial(data));
    }
    static deserializeBinary(data2) {
      return new (messageClass(message, message.decode(data2)))();
    }
    serializeBinary() {
      return message.encode(this).finish();
    }
    toObject() {
      return this;
    }
  };
}
function createTsProtoClient(serviceDefinition, handler) {
  return fromEntries(entries2(serviceDefinition.methods).map(([methodName, methodDefinition]) => {
    return [
      methodName,
      (request) => __awaiter(this, void 0, void 0, function* () {
        const requestType = messageClass(methodDefinition.requestType, request);
        const responseType = messageClass(methodDefinition.responseType, {});
        return handler({
          serviceName: serviceDefinition.fullName,
          methodName: methodDefinition.name,
          requestType,
          responseType
        });
      })
    ];
  }));
}

// node_modules/@snap/camera-kit/dist/remote-configuration/cofHandler.js
var import_browser_headers2 = __toESM(require_browser_headers_umd());

// node_modules/@snap/camera-kit/dist/common/unionBy.js
function unionBy(iteratee, ...arrays) {
  const throwIterateeError = () => {
    throw new Error("Iteratee must be a function or a valid property key of the item");
  };
  const seen = /* @__PURE__ */ new Map();
  for (const item of arrays.flat()) {
    const key = typeof iteratee === "function" ? iteratee(item) : typeof item === "object" && item !== null && iteratee in item ? item[iteratee] : throwIterateeError();
    seen.set(key, item);
  }
  return Array.from(seen.values());
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/circumstance_service.js
var import_grpc_web2 = __toESM(require_grpc_web_client_umd());
var import_browser_headers = __toESM(require_browser_headers_umd());

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/common/ruid.js
var Ruid_Type;
(function(Ruid_Type2) {
  Ruid_Type2[Ruid_Type2["UNSET"] = 0] = "UNSET";
  Ruid_Type2[Ruid_Type2["USER"] = 1] = "USER";
  Ruid_Type2[Ruid_Type2["DEVICE"] = 2] = "DEVICE";
  Ruid_Type2[Ruid_Type2["WEB_CLIENT"] = 3] = "WEB_CLIENT";
  Ruid_Type2[Ruid_Type2["AD_ACCOUNT"] = 4] = "AD_ACCOUNT";
  Ruid_Type2[Ruid_Type2["USERNAME"] = 5] = "USERNAME";
  Ruid_Type2[Ruid_Type2["AD_MODERATION_AD"] = 6] = "AD_MODERATION_AD";
  Ruid_Type2[Ruid_Type2["WEB_SNAPCHAT_USER"] = 7] = "WEB_SNAPCHAT_USER";
  Ruid_Type2[Ruid_Type2["INTERNAL"] = 8] = "INTERNAL";
  Ruid_Type2[Ruid_Type2["AM_ORGANIZATION"] = 9] = "AM_ORGANIZATION";
  Ruid_Type2[Ruid_Type2["AM_MEMBER"] = 10] = "AM_MEMBER";
  Ruid_Type2[Ruid_Type2["AM_SESSION"] = 11] = "AM_SESSION";
  Ruid_Type2[Ruid_Type2["AM_PROFILE"] = 12] = "AM_PROFILE";
  Ruid_Type2[Ruid_Type2["AM_SNAPCHAT_USER"] = 13] = "AM_SNAPCHAT_USER";
  Ruid_Type2[Ruid_Type2["SNAPCHAT_ADVERTISING"] = 14] = "SNAPCHAT_ADVERTISING";
  Ruid_Type2[Ruid_Type2["AM_CLIENT"] = 15] = "AM_CLIENT";
  Ruid_Type2[Ruid_Type2["MISCHIEF"] = 16] = "MISCHIEF";
  Ruid_Type2[Ruid_Type2["ARES_VISITOR"] = 17] = "ARES_VISITOR";
  Ruid_Type2[Ruid_Type2["POD_NAME"] = 18] = "POD_NAME";
  Ruid_Type2[Ruid_Type2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Ruid_Type || (Ruid_Type = {}));
function createBaseRuid() {
  return { type: 0, stringValue: "", loggingIdValue: "" };
}
var Ruid = {
  encode(message, writer = new BinaryWriter()) {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.stringValue !== "") {
      writer.uint32(18).string(message.stringValue);
    }
    if (message.loggingIdValue !== "") {
      writer.uint32(26).string(message.loggingIdValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRuid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.loggingIdValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Ruid.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseRuid();
    message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
    message.stringValue = (_b = object.stringValue) !== null && _b !== void 0 ? _b : "";
    message.loggingIdValue = (_c = object.loggingIdValue) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/google/protobuf/wrappers.js
function createBaseBoolValue() {
  return { value: false };
}
var BoolValue = {
  encode(message, writer = new BinaryWriter()) {
    if (message.value !== false) {
      writer.uint32(8).bool(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBoolValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BoolValue.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBoolValue();
    message.value = (_a = object.value) !== null && _a !== void 0 ? _a : false;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/benchmark.js
function createBaseBenchmarkValue() {
  return { intValue: void 0, longValue: void 0, boolValue: void 0, floatValue: void 0 };
}
var BenchmarkValue = {
  encode(message, writer = new BinaryWriter()) {
    if (message.intValue !== void 0) {
      writer.uint32(8).int32(message.intValue);
    }
    if (message.longValue !== void 0) {
      writer.uint32(16).int64(message.longValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(24).bool(message.boolValue);
    }
    if (message.floatValue !== void 0) {
      writer.uint32(37).float(message.floatValue);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.intValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.longValue = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }
          message.floatValue = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BenchmarkValue.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseBenchmarkValue();
    message.intValue = (_a = object.intValue) !== null && _a !== void 0 ? _a : void 0;
    message.longValue = (_b = object.longValue) !== null && _b !== void 0 ? _b : void 0;
    message.boolValue = (_c = object.boolValue) !== null && _c !== void 0 ? _c : void 0;
    message.floatValue = (_d = object.floatValue) !== null && _d !== void 0 ? _d : void 0;
    return message;
  }
};
function createBaseBenchmarkRequest() {
  return { benchmarkNames: [], expirationTimestamp: void 0 };
}
var BenchmarkRequest = {
  encode(message, writer = new BinaryWriter()) {
    writer.uint32(10).fork();
    for (const v2 of message.benchmarkNames) {
      writer.int32(v2);
    }
    writer.join();
    if (message.expirationTimestamp !== void 0) {
      Timestamp.encode(toTimestamp3(message.expirationTimestamp), writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.benchmarkNames.push(reader.int32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.benchmarkNames.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.expirationTimestamp = fromTimestamp3(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BenchmarkRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseBenchmarkRequest();
    message.benchmarkNames = ((_a = object.benchmarkNames) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.expirationTimestamp = (_b = object.expirationTimestamp) !== null && _b !== void 0 ? _b : void 0;
    return message;
  }
};
function createBaseBenchmarkResult() {
  return { name: 0, value: void 0 };
}
var BenchmarkResult = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== 0) {
      writer.uint32(8).int32(message.name);
    }
    if (message.value !== void 0) {
      BenchmarkValue.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBenchmarkResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.name = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = BenchmarkValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BenchmarkResult.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseBenchmarkResult();
    message.name = (_a = object.name) !== null && _a !== void 0 ? _a : 0;
    message.value = object.value !== void 0 && object.value !== null ? BenchmarkValue.fromPartial(object.value) : void 0;
    return message;
  }
};
function toTimestamp3(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp3(t2) {
  let millis = (globalThis.Number(t2.seconds) || 0) * 1e3;
  millis += (t2.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_request.js
var ConfigTargetingTriggerEventType;
(function(ConfigTargetingTriggerEventType2) {
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["UNKNOWN_EVENT_TYPE"] = 0] = "UNKNOWN_EVENT_TYPE";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["COLD_START"] = 1] = "COLD_START";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["WARM_START"] = 2] = "WARM_START";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["FOREGROUND_TRIGGER"] = 3] = "FOREGROUND_TRIGGER";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["BACKGROUND_TRIGGER"] = 4] = "BACKGROUND_TRIGGER";
  ConfigTargetingTriggerEventType2[ConfigTargetingTriggerEventType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingTriggerEventType || (ConfigTargetingTriggerEventType = {}));
var ConfigTargetingAppState;
(function(ConfigTargetingAppState2) {
  ConfigTargetingAppState2[ConfigTargetingAppState2["UNKNOWN_APP_STATE"] = 0] = "UNKNOWN_APP_STATE";
  ConfigTargetingAppState2[ConfigTargetingAppState2["FOREGROUND"] = 1] = "FOREGROUND";
  ConfigTargetingAppState2[ConfigTargetingAppState2["BACKGROUND"] = 2] = "BACKGROUND";
  ConfigTargetingAppState2[ConfigTargetingAppState2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingAppState || (ConfigTargetingAppState = {}));
var ConfigTargetingInstrumentation;
(function(ConfigTargetingInstrumentation2) {
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["DEFAULT_INSTRUMENTATION"] = 0] = "DEFAULT_INSTRUMENTATION";
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["USER_AUTHENTICATION"] = 1] = "USER_AUTHENTICATION";
  ConfigTargetingInstrumentation2[ConfigTargetingInstrumentation2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigTargetingInstrumentation || (ConfigTargetingInstrumentation = {}));
var Connectivity_NetworkType;
(function(Connectivity_NetworkType2) {
  Connectivity_NetworkType2[Connectivity_NetworkType2["UNKNOWN_NETWORK_TYPE"] = 0] = "UNKNOWN_NETWORK_TYPE";
  Connectivity_NetworkType2[Connectivity_NetworkType2["CELLULAR"] = 1] = "CELLULAR";
  Connectivity_NetworkType2[Connectivity_NetworkType2["WIFI"] = 2] = "WIFI";
  Connectivity_NetworkType2[Connectivity_NetworkType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Connectivity_NetworkType || (Connectivity_NetworkType = {}));
function createBaseConfigTargetingRequest() {
  return {
    configResultsEtag: "",
    namespaces: [],
    ghostId: "",
    countryCode: "",
    screenWidth: 0,
    screenHeight: 0,
    connectivity: void 0,
    maxVideoWidthPx: 0,
    maxVideoHeightPx: 0,
    benchmarkResults: [],
    deltaSync: false,
    userAgent: "",
    triggerEventType: 0,
    appState: 0,
    locale: "",
    deviceId: "",
    userId: "",
    clientIp: "",
    isUnAuthorized: false,
    appLocale: "",
    instrumentation: 0,
    lastSuccessfulSync: "0",
    isLogout: false,
    packageInstaller: "",
    syncTriggerBlizzardSessionId: "",
    syncExecutionBlizzardSessionId: "",
    cofSyncTriggerDelayFromStartupMs: 0,
    cofSyncExecutionDelayFromStartupMs: 0,
    syncTriggerTime: "0",
    decoderEncoderAvailability: void 0,
    snapkitAppId: "",
    lenscoreVersion: 0,
    ruid: void 0,
    configNames: [],
    includeTestUserTreatments: false,
    disableExposureLogging: false,
    lensClusterOrig4: 0,
    clientId: "",
    propertyOverrides: void 0,
    forLockscreenMode: false,
    osBuildVersion: ""
  };
}
var ConfigTargetingRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.configResultsEtag !== "") {
      writer.uint32(10).string(message.configResultsEtag);
    }
    writer.uint32(18).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.join();
    if (message.ghostId !== "") {
      writer.uint32(26).string(message.ghostId);
    }
    if (message.countryCode !== "") {
      writer.uint32(34).string(message.countryCode);
    }
    if (message.screenWidth !== 0) {
      writer.uint32(40).int32(message.screenWidth);
    }
    if (message.screenHeight !== 0) {
      writer.uint32(48).int32(message.screenHeight);
    }
    if (message.connectivity !== void 0) {
      Connectivity.encode(message.connectivity, writer.uint32(58).fork()).join();
    }
    if (message.maxVideoWidthPx !== 0) {
      writer.uint32(64).int32(message.maxVideoWidthPx);
    }
    if (message.maxVideoHeightPx !== 0) {
      writer.uint32(72).int32(message.maxVideoHeightPx);
    }
    for (const v2 of message.benchmarkResults) {
      BenchmarkResult.encode(v2, writer.uint32(82).fork()).join();
    }
    if (message.deltaSync !== false) {
      writer.uint32(88).bool(message.deltaSync);
    }
    if (message.userAgent !== "") {
      writer.uint32(98).string(message.userAgent);
    }
    if (message.triggerEventType !== 0) {
      writer.uint32(104).int32(message.triggerEventType);
    }
    if (message.appState !== 0) {
      writer.uint32(112).int32(message.appState);
    }
    if (message.locale !== "") {
      writer.uint32(122).string(message.locale);
    }
    if (message.deviceId !== "") {
      writer.uint32(130).string(message.deviceId);
    }
    if (message.userId !== "") {
      writer.uint32(138).string(message.userId);
    }
    if (message.clientIp !== "") {
      writer.uint32(146).string(message.clientIp);
    }
    if (message.isUnAuthorized !== false) {
      writer.uint32(152).bool(message.isUnAuthorized);
    }
    if (message.appLocale !== "") {
      writer.uint32(162).string(message.appLocale);
    }
    if (message.instrumentation !== 0) {
      writer.uint32(168).int32(message.instrumentation);
    }
    if (message.lastSuccessfulSync !== "0") {
      writer.uint32(176).int64(message.lastSuccessfulSync);
    }
    if (message.isLogout !== false) {
      writer.uint32(184).bool(message.isLogout);
    }
    if (message.packageInstaller !== "") {
      writer.uint32(194).string(message.packageInstaller);
    }
    if (message.syncTriggerBlizzardSessionId !== "") {
      writer.uint32(202).string(message.syncTriggerBlizzardSessionId);
    }
    if (message.syncExecutionBlizzardSessionId !== "") {
      writer.uint32(210).string(message.syncExecutionBlizzardSessionId);
    }
    if (message.cofSyncTriggerDelayFromStartupMs !== 0) {
      writer.uint32(216).int32(message.cofSyncTriggerDelayFromStartupMs);
    }
    if (message.cofSyncExecutionDelayFromStartupMs !== 0) {
      writer.uint32(224).int32(message.cofSyncExecutionDelayFromStartupMs);
    }
    if (message.syncTriggerTime !== "0") {
      writer.uint32(232).int64(message.syncTriggerTime);
    }
    if (message.decoderEncoderAvailability !== void 0) {
      DecoderEncoderAvailablity.encode(message.decoderEncoderAvailability, writer.uint32(242).fork()).join();
    }
    if (message.snapkitAppId !== "") {
      writer.uint32(250).string(message.snapkitAppId);
    }
    if (message.lenscoreVersion !== 0) {
      writer.uint32(256).int32(message.lenscoreVersion);
    }
    if (message.ruid !== void 0) {
      Ruid.encode(message.ruid, writer.uint32(266).fork()).join();
    }
    for (const v2 of message.configNames) {
      writer.uint32(274).string(v2);
    }
    if (message.includeTestUserTreatments !== false) {
      writer.uint32(288).bool(message.includeTestUserTreatments);
    }
    if (message.disableExposureLogging !== false) {
      writer.uint32(296).bool(message.disableExposureLogging);
    }
    if (message.lensClusterOrig4 !== 0) {
      writer.uint32(304).int32(message.lensClusterOrig4);
    }
    if (message.clientId !== "") {
      writer.uint32(314).string(message.clientId);
    }
    if (message.propertyOverrides !== void 0) {
      PropertyOverrides.encode(message.propertyOverrides, writer.uint32(322).fork()).join();
    }
    if (message.forLockscreenMode !== false) {
      writer.uint32(328).bool(message.forLockscreenMode);
    }
    if (message.osBuildVersion !== "") {
      writer.uint32(338).string(message.osBuildVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configResultsEtag = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.namespaces.push(reader.int32());
            continue;
          }
          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.ghostId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.countryCode = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.screenWidth = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.screenHeight = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.connectivity = Connectivity.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.maxVideoWidthPx = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.maxVideoHeightPx = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.benchmarkResults.push(BenchmarkResult.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.deltaSync = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.userAgent = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.triggerEventType = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }
          message.appState = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.locale = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.deviceId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.clientIp = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }
          message.isUnAuthorized = reader.bool();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }
          message.appLocale = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }
          message.instrumentation = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }
          message.lastSuccessfulSync = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }
          message.isLogout = reader.bool();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }
          message.packageInstaller = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }
          message.syncTriggerBlizzardSessionId = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }
          message.syncExecutionBlizzardSessionId = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }
          message.cofSyncTriggerDelayFromStartupMs = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }
          message.cofSyncExecutionDelayFromStartupMs = reader.int32();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }
          message.syncTriggerTime = reader.int64().toString();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }
          message.decoderEncoderAvailability = DecoderEncoderAvailablity.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }
          message.snapkitAppId = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }
          message.lenscoreVersion = reader.int32();
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }
          message.ruid = Ruid.decode(reader, reader.uint32());
          continue;
        }
        case 34: {
          if (tag !== 274) {
            break;
          }
          message.configNames.push(reader.string());
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }
          message.includeTestUserTreatments = reader.bool();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }
          message.disableExposureLogging = reader.bool();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }
          message.lensClusterOrig4 = reader.int32();
          continue;
        }
        case 39: {
          if (tag !== 314) {
            break;
          }
          message.clientId = reader.string();
          continue;
        }
        case 40: {
          if (tag !== 322) {
            break;
          }
          message.propertyOverrides = PropertyOverrides.decode(reader, reader.uint32());
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }
          message.forLockscreenMode = reader.bool();
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }
          message.osBuildVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigTargetingRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12;
    const message = createBaseConfigTargetingRequest();
    message.configResultsEtag = (_a = object.configResultsEtag) !== null && _a !== void 0 ? _a : "";
    message.namespaces = ((_b = object.namespaces) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.ghostId = (_c = object.ghostId) !== null && _c !== void 0 ? _c : "";
    message.countryCode = (_d = object.countryCode) !== null && _d !== void 0 ? _d : "";
    message.screenWidth = (_e = object.screenWidth) !== null && _e !== void 0 ? _e : 0;
    message.screenHeight = (_f = object.screenHeight) !== null && _f !== void 0 ? _f : 0;
    message.connectivity = object.connectivity !== void 0 && object.connectivity !== null ? Connectivity.fromPartial(object.connectivity) : void 0;
    message.maxVideoWidthPx = (_g = object.maxVideoWidthPx) !== null && _g !== void 0 ? _g : 0;
    message.maxVideoHeightPx = (_h = object.maxVideoHeightPx) !== null && _h !== void 0 ? _h : 0;
    message.benchmarkResults = ((_j = object.benchmarkResults) === null || _j === void 0 ? void 0 : _j.map((e2) => BenchmarkResult.fromPartial(e2))) || [];
    message.deltaSync = (_k = object.deltaSync) !== null && _k !== void 0 ? _k : false;
    message.userAgent = (_l = object.userAgent) !== null && _l !== void 0 ? _l : "";
    message.triggerEventType = (_m = object.triggerEventType) !== null && _m !== void 0 ? _m : 0;
    message.appState = (_o = object.appState) !== null && _o !== void 0 ? _o : 0;
    message.locale = (_p = object.locale) !== null && _p !== void 0 ? _p : "";
    message.deviceId = (_q = object.deviceId) !== null && _q !== void 0 ? _q : "";
    message.userId = (_r = object.userId) !== null && _r !== void 0 ? _r : "";
    message.clientIp = (_s = object.clientIp) !== null && _s !== void 0 ? _s : "";
    message.isUnAuthorized = (_t = object.isUnAuthorized) !== null && _t !== void 0 ? _t : false;
    message.appLocale = (_u = object.appLocale) !== null && _u !== void 0 ? _u : "";
    message.instrumentation = (_v = object.instrumentation) !== null && _v !== void 0 ? _v : 0;
    message.lastSuccessfulSync = (_w = object.lastSuccessfulSync) !== null && _w !== void 0 ? _w : "0";
    message.isLogout = (_x = object.isLogout) !== null && _x !== void 0 ? _x : false;
    message.packageInstaller = (_y = object.packageInstaller) !== null && _y !== void 0 ? _y : "";
    message.syncTriggerBlizzardSessionId = (_z = object.syncTriggerBlizzardSessionId) !== null && _z !== void 0 ? _z : "";
    message.syncExecutionBlizzardSessionId = (_0 = object.syncExecutionBlizzardSessionId) !== null && _0 !== void 0 ? _0 : "";
    message.cofSyncTriggerDelayFromStartupMs = (_1 = object.cofSyncTriggerDelayFromStartupMs) !== null && _1 !== void 0 ? _1 : 0;
    message.cofSyncExecutionDelayFromStartupMs = (_2 = object.cofSyncExecutionDelayFromStartupMs) !== null && _2 !== void 0 ? _2 : 0;
    message.syncTriggerTime = (_3 = object.syncTriggerTime) !== null && _3 !== void 0 ? _3 : "0";
    message.decoderEncoderAvailability = object.decoderEncoderAvailability !== void 0 && object.decoderEncoderAvailability !== null ? DecoderEncoderAvailablity.fromPartial(object.decoderEncoderAvailability) : void 0;
    message.snapkitAppId = (_4 = object.snapkitAppId) !== null && _4 !== void 0 ? _4 : "";
    message.lenscoreVersion = (_5 = object.lenscoreVersion) !== null && _5 !== void 0 ? _5 : 0;
    message.ruid = object.ruid !== void 0 && object.ruid !== null ? Ruid.fromPartial(object.ruid) : void 0;
    message.configNames = ((_6 = object.configNames) === null || _6 === void 0 ? void 0 : _6.map((e2) => e2)) || [];
    message.includeTestUserTreatments = (_7 = object.includeTestUserTreatments) !== null && _7 !== void 0 ? _7 : false;
    message.disableExposureLogging = (_8 = object.disableExposureLogging) !== null && _8 !== void 0 ? _8 : false;
    message.lensClusterOrig4 = (_9 = object.lensClusterOrig4) !== null && _9 !== void 0 ? _9 : 0;
    message.clientId = (_10 = object.clientId) !== null && _10 !== void 0 ? _10 : "";
    message.propertyOverrides = object.propertyOverrides !== void 0 && object.propertyOverrides !== null ? PropertyOverrides.fromPartial(object.propertyOverrides) : void 0;
    message.forLockscreenMode = (_11 = object.forLockscreenMode) !== null && _11 !== void 0 ? _11 : false;
    message.osBuildVersion = (_12 = object.osBuildVersion) !== null && _12 !== void 0 ? _12 : "";
    return message;
  }
};
function createBasePropertyOverrides() {
  return { isWeb: false };
}
var PropertyOverrides = {
  encode(message, writer = new BinaryWriter()) {
    if (message.isWeb !== false) {
      writer.uint32(8).bool(message.isWeb);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePropertyOverrides();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.isWeb = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PropertyOverrides.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBasePropertyOverrides();
    message.isWeb = (_a = object.isWeb) !== null && _a !== void 0 ? _a : false;
    return message;
  }
};
function createBaseConnectivity() {
  return { networkType: 0, isMetered: void 0, isRoaming: void 0, carrier: "" };
}
var Connectivity = {
  encode(message, writer = new BinaryWriter()) {
    if (message.networkType !== 0) {
      writer.uint32(8).int32(message.networkType);
    }
    if (message.isMetered !== void 0) {
      BoolValue.encode({ value: message.isMetered }, writer.uint32(18).fork()).join();
    }
    if (message.isRoaming !== void 0) {
      BoolValue.encode({ value: message.isRoaming }, writer.uint32(26).fork()).join();
    }
    if (message.carrier !== "") {
      writer.uint32(34).string(message.carrier);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConnectivity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.networkType = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.isMetered = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.isRoaming = BoolValue.decode(reader, reader.uint32()).value;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.carrier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Connectivity.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseConnectivity();
    message.networkType = (_a = object.networkType) !== null && _a !== void 0 ? _a : 0;
    message.isMetered = (_b = object.isMetered) !== null && _b !== void 0 ? _b : void 0;
    message.isRoaming = (_c = object.isRoaming) !== null && _c !== void 0 ? _c : void 0;
    message.carrier = (_d = object.carrier) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseDecoderEncoderAvailablity() {
  return { isSnapVp9DecoderAvailable: false, isSnapAv1DecoderAvailable: false };
}
var DecoderEncoderAvailablity = {
  encode(message, writer = new BinaryWriter()) {
    if (message.isSnapVp9DecoderAvailable !== false) {
      writer.uint32(8).bool(message.isSnapVp9DecoderAvailable);
    }
    if (message.isSnapAv1DecoderAvailable !== false) {
      writer.uint32(16).bool(message.isSnapAv1DecoderAvailable);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDecoderEncoderAvailablity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.isSnapVp9DecoderAvailable = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.isSnapAv1DecoderAvailable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return DecoderEncoderAvailablity.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseDecoderEncoderAvailablity();
    message.isSnapVp9DecoderAvailable = (_a = object.isSnapVp9DecoderAvailable) !== null && _a !== void 0 ? _a : false;
    message.isSnapAv1DecoderAvailable = (_b = object.isSnapAv1DecoderAvailable) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/common/value.js
function createBaseMapRecord() {
  return { key: "", value: "" };
}
var MapRecord = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MapRecord.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMapRecord();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseMapRecords() {
  return { records: [] };
}
var MapRecords = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.records) {
      MapRecord.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMapRecords();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.records.push(MapRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MapRecords.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMapRecords();
    message.records = ((_a = object.records) === null || _a === void 0 ? void 0 : _a.map((e2) => MapRecord.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseStringArray() {
  return { value: [] };
}
var StringArray = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.value) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseStringArray();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.value.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return StringArray.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseStringArray();
    message.value = ((_a = object.value) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseValue() {
  return {
    intValue: void 0,
    longValue: void 0,
    floatValue: void 0,
    doubleValue: void 0,
    boolValue: void 0,
    stringValue: void 0,
    anyValue: void 0,
    mapValue: void 0,
    intPairValue: void 0,
    stringArrayValue: void 0
  };
}
var Value = {
  encode(message, writer = new BinaryWriter()) {
    if (message.intValue !== void 0) {
      writer.uint32(8).int32(message.intValue);
    }
    if (message.longValue !== void 0) {
      writer.uint32(16).int64(message.longValue);
    }
    if (message.floatValue !== void 0) {
      writer.uint32(29).float(message.floatValue);
    }
    if (message.doubleValue !== void 0) {
      writer.uint32(73).double(message.doubleValue);
    }
    if (message.boolValue !== void 0) {
      writer.uint32(32).bool(message.boolValue);
    }
    if (message.stringValue !== void 0) {
      writer.uint32(42).string(message.stringValue);
    }
    if (message.anyValue !== void 0) {
      Any.encode(message.anyValue, writer.uint32(50).fork()).join();
    }
    if (message.mapValue !== void 0) {
      MapRecords.encode(message.mapValue, writer.uint32(58).fork()).join();
    }
    if (message.intPairValue !== void 0) {
      writer.uint32(65).fixed64(message.intPairValue);
    }
    if (message.stringArrayValue !== void 0) {
      StringArray.encode(message.stringArrayValue, writer.uint32(82).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.intValue = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.longValue = reader.int64().toString();
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }
          message.floatValue = reader.float();
          continue;
        }
        case 9: {
          if (tag !== 73) {
            break;
          }
          message.doubleValue = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.boolValue = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.stringValue = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.anyValue = Any.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.mapValue = MapRecords.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }
          message.intPairValue = reader.fixed64().toString();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.stringArrayValue = StringArray.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Value.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseValue();
    message.intValue = (_a = object.intValue) !== null && _a !== void 0 ? _a : void 0;
    message.longValue = (_b = object.longValue) !== null && _b !== void 0 ? _b : void 0;
    message.floatValue = (_c = object.floatValue) !== null && _c !== void 0 ? _c : void 0;
    message.doubleValue = (_d = object.doubleValue) !== null && _d !== void 0 ? _d : void 0;
    message.boolValue = (_e = object.boolValue) !== null && _e !== void 0 ? _e : void 0;
    message.stringValue = (_f = object.stringValue) !== null && _f !== void 0 ? _f : void 0;
    message.anyValue = object.anyValue !== void 0 && object.anyValue !== null ? Any.fromPartial(object.anyValue) : void 0;
    message.mapValue = object.mapValue !== void 0 && object.mapValue !== null ? MapRecords.fromPartial(object.mapValue) : void 0;
    message.intPairValue = (_g = object.intPairValue) !== null && _g !== void 0 ? _g : void 0;
    message.stringArrayValue = object.stringArrayValue !== void 0 && object.stringArrayValue !== null ? StringArray.fromPartial(object.stringArrayValue) : void 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_result.js
var ConfigResult_ServePlatform;
(function(ConfigResult_ServePlatform2) {
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["UNKNOWN_CONTEXT_PLATFORM"] = 0] = "UNKNOWN_CONTEXT_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["IOS_PLATFORM"] = 1] = "IOS_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["ANDROID_PLATFORM"] = 2] = "ANDROID_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["SERVER_PLATFORM"] = 3] = "SERVER_PLATFORM";
  ConfigResult_ServePlatform2[ConfigResult_ServePlatform2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ConfigResult_ServePlatform || (ConfigResult_ServePlatform = {}));
var ClientTargetingExpression_Operator;
(function(ClientTargetingExpression_Operator2) {
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["UNKNOWN_OPERATOR"] = 0] = "UNKNOWN_OPERATOR";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["AND"] = 1] = "AND";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["OR"] = 2] = "OR";
  ClientTargetingExpression_Operator2[ClientTargetingExpression_Operator2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_Operator || (ClientTargetingExpression_Operator = {}));
var ClientTargetingExpression_PredicateOperator;
(function(ClientTargetingExpression_PredicateOperator2) {
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["UNKNOWN_PREDICATE_OPERATOR"] = 0] = "UNKNOWN_PREDICATE_OPERATOR";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["EQUAL"] = 1] = "EQUAL";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["NOT_EQUAL"] = 2] = "NOT_EQUAL";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["GREATER_THAN_OR_EQUAL_TO"] = 3] = "GREATER_THAN_OR_EQUAL_TO";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["LESS_THAN_OR_EQUAL_TO"] = 4] = "LESS_THAN_OR_EQUAL_TO";
  ClientTargetingExpression_PredicateOperator2[ClientTargetingExpression_PredicateOperator2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_PredicateOperator || (ClientTargetingExpression_PredicateOperator = {}));
var ClientTargetingExpression_EvaluationSite;
(function(ClientTargetingExpression_EvaluationSite2) {
  ClientTargetingExpression_EvaluationSite2[ClientTargetingExpression_EvaluationSite2["UNSET"] = 0] = "UNSET";
  ClientTargetingExpression_EvaluationSite2[ClientTargetingExpression_EvaluationSite2["CLIENT"] = 1] = "CLIENT";
  ClientTargetingExpression_EvaluationSite2[ClientTargetingExpression_EvaluationSite2["SERVER"] = 2] = "SERVER";
  ClientTargetingExpression_EvaluationSite2[ClientTargetingExpression_EvaluationSite2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_EvaluationSite || (ClientTargetingExpression_EvaluationSite = {}));
var ClientTargetingExpression_Property;
(function(ClientTargetingExpression_Property2) {
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UNKNOWN_PROPERTY"] = 0] = "UNKNOWN_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BATTERY_LEVEL"] = 1] = "BATTERY_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_OFFLINE"] = 2] = "IS_OFFLINE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_CHARGING"] = 3] = "IS_CHARGING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BANDWIDTH"] = 4] = "BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DISK_SIZE"] = 5] = "DISK_SIZE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DISK_AVAILABLE"] = 6] = "DISK_AVAILABLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_TYPE_DEPRECATED"] = 7] = "MEDIA_TYPE_DEPRECATED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_PUBLIC_STORY"] = 8] = "IS_PUBLIC_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_OFFICIAL_STORY"] = 9] = "IS_OFFICIAL_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_DIRECTION"] = 10] = "CAMERA_DIRECTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_CONTEXT"] = 11] = "CAMERA_CONTEXT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_API"] = 12] = "CAMERA_API";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_FLASH_STATE"] = 13] = "CAMERA_FLASH_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_SOURCE"] = 14] = "SNAP_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LEGACY_MUSHROOM_CONTENT_TYPE"] = 15] = "LEGACY_MUSHROOM_CONTENT_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UPLOAD_BANDWIDTH"] = 16] = "UPLOAD_BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_LEVEL"] = 17] = "CAMERA2_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_NIGHT_MODE_STATE"] = 18] = "CAMERA_NIGHT_MODE_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_LANGUAGE"] = 19] = "USER_LANGUAGE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["VIDEO_DURATION"] = 20] = "VIDEO_DURATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_MOBILE_NETWORK_GENERATION"] = 21] = "REALTIME_MOBILE_NETWORK_GENERATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_TYPE"] = 22] = "REALTIME_NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_IS_METERED"] = 23] = "REALTIME_NETWORK_IS_METERED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REALTIME_NETWORK_IS_ROAMING"] = 24] = "REALTIME_NETWORK_IS_ROAMING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA_IS_FIRST_CAPTURE"] = 25] = "CAMERA_IS_FIRST_CAPTURE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PICTURE_MODE"] = 26] = "PICTURE_MODE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_USE_CASE"] = 27] = "BOLT_USE_CASE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_CDN_EXPERIMENTATION_ID"] = 28] = "BOLT_CDN_EXPERIMENTATION_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINS_SINCE_LAST_LENS_ACTIVATION"] = 29] = "MINS_SINCE_LAST_LENS_ACTIVATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINS_SINCE_LAST_SNAPPABLE_LENS_ACTIVATION"] = 30] = "MINS_SINCE_LAST_SNAPPABLE_LENS_ACTIVATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_LOGIN_OR_OPEN"] = 31] = "DAYS_SINCE_LAST_LOGIN_OR_OPEN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPECTACLES_VERSION"] = 32] = "SPECTACLES_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STICKY_MAX_CONNECTION_TYPE"] = 33] = "STICKY_MAX_CONNECTION_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WITH_ANIMATED_OVERLAY"] = 34] = "WITH_ANIMATED_OVERLAY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ESTIMATED_DURATION_FOR_EVENT_MS"] = 35] = "ESTIMATED_DURATION_FOR_EVENT_MS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["URL"] = 36] = "URL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_SOURCE"] = 37] = "MEDIA_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ASSET_TYPE"] = 38] = "ASSET_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_IS_CONTENT_POPULAR"] = 39] = "BOLT_IS_CONTENT_POPULAR";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAPTURE_MODE"] = 40] = "CAPTURE_MODE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["VP9_SOFTWARE_DECODING_SUPPORTED"] = 41] = "VP9_SOFTWARE_DECODING_SUPPORTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_SOFTWARE_DECODING_SUPPORTED"] = 42] = "AV1_SOFTWARE_DECODING_SUPPORTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WITH_MUSIC"] = 43] = "WITH_MUSIC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FEATURE_PROVIDED_SIZE"] = 44] = "FEATURE_PROVIDED_SIZE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_TYPE"] = 45] = "MEDIA_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCANNED_CATEGORY_IDS"] = 46] = "SCANNED_CATEGORY_IDS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTENT_VIEW_SOURCE"] = 47] = "CONTENT_VIEW_SOURCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RECIPIENTS_SUPPORT_HEVC"] = 48] = "RECIPIENTS_SUPPORT_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COGNAC_APP_ID"] = 49] = "COGNAC_APP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["EMAIL_VERIFIED"] = 50] = "EMAIL_VERIFIED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PHONE_VERIFIED"] = 51] = "PHONE_VERIFIED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NOTIFICATION_PERM_GRANTED"] = 52] = "NOTIFICATION_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_GRANTED"] = 53] = "CONTACT_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTUAL_FRIENDS_COUNT"] = 54] = "MUTUAL_FRIENDS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GROUPS_COUNT"] = 55] = "GROUPS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_NON_TEAM_SNAPCHAT_CONVERSATIONS"] = 56] = "HAS_NON_TEAM_SNAPCHAT_CONVERSATIONS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PLAYBACK_ITEM_TYPE"] = 57] = "PLAYBACK_ITEM_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_BOOLEAN_PROPERTY"] = 58] = "SUP_BOOLEAN_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_INTEGER_PROPERTY"] = 59] = "SUP_INTEGER_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_LONG_PROPERTY"] = 60] = "SUP_LONG_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_STRING_PROPERTY"] = 61] = "SUP_STRING_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_DOUBLE_PROPERTY"] = 62] = "SUP_DOUBLE_PROPERTY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_MILLIS_PROPERTY_TO_NOW"] = 63] = "SUP_MILLIS_PROPERTY_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_USED_SPECTACLES"] = 64] = "HAS_USED_SPECTACLES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_SECS_PROPERTY_TO_NOW"] = 65] = "SUP_SECS_PROPERTY_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BOLT_CLIENT_APP_STATE"] = 66] = "BOLT_CLIENT_APP_STATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["EMAIL_SET"] = 67] = "EMAIL_SET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BITMOJI_SET"] = 68] = "BITMOJI_SET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["QUICK_TAP_CAMERA_SUPPORTED_ENABLED"] = 69] = "QUICK_TAP_CAMERA_SUPPORTED_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ADD_FRIENDS_REQUEST"] = 70] = "HAS_ADD_FRIENDS_REQUEST";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LAUNCH_FROM_PUSH"] = 71] = "APP_LAUNCH_FROM_PUSH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LAUNCH_TYPE"] = 72] = "APP_LAUNCH_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_IMPRESSION_COUNT"] = 73] = "BILLBOARD_CAMPAIGN_LOCAL_IMPRESSION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_IMPRESSION_TIME_SECS_TO_NOW"] = 74] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_CONTINUOUS_DISMISS_COUNT"] = 75] = "BILLBOARD_CAMPAIGN_LOCAL_CONTINUOUS_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_NUM_IN_APP_WARNINGS"] = 76] = "FST_NUM_IN_APP_WARNINGS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_SHOULD_CHANGE_PASSWORD"] = 77] = "FST_SHOULD_CHANGE_PASSWORD";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_IS_BACKGROUND_CHECK"] = 78] = "FST_IS_BACKGROUND_CHECK";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AUDIO_RECORD_PERM_GRANTED"] = 79] = "AUDIO_RECORD_PERM_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTUAL_FRIENDS_WITH_BIRTHDAY_COUNT"] = 80] = "MUTUAL_FRIENDS_WITH_BIRTHDAY_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_DISMISS_COUNT"] = 81] = "BILLBOARD_CAMPAIGN_LOCAL_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USE_VERTICAL_NAVIGATION"] = 82] = "USE_VERTICAL_NAVIGATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FREEABLE_DISK_AVAILABLE"] = 83] = "FREEABLE_DISK_AVAILABLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEMORIES_COUNT"] = 84] = "MEMORIES_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_MODEL"] = 85] = "DEVICE_MODEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COUNTRY"] = 86] = "COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["OS"] = 87] = "OS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["OS_VERSION"] = 88] = "OS_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_VERSION"] = 89] = "APP_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_FLAVOR"] = 90] = "BUILD_FLAVOR";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_ID"] = 91] = "USER_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LOCALE"] = 92] = "LOCALE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_CLUSTER"] = 93] = "DEVICE_CLUSTER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_BRAND"] = 94] = "DEVICE_BRAND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_EMPLOYEE"] = 95] = "IS_EMPLOYEE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USERNAME"] = 96] = "USERNAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_TEST_USER"] = 97] = "IS_TEST_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PROFILE"] = 98] = "USER_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_WIDTH"] = 99] = "SCREEN_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_HEIGHT"] = 100] = "SCREEN_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_SUPPORT"] = 101] = "HEVC_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NETWORK_TYPE"] = 102] = "NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MAX_VIDEO_WIDTH"] = 103] = "MAX_VIDEO_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MAX_VIDEO_HEIGHT"] = 104] = "MAX_VIDEO_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_NETWORK_METERED"] = 105] = "IS_NETWORK_METERED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ROAMING"] = 106] = "IS_ROAMING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_ENGAGEMENT_LEVEL"] = 107] = "APP_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNICATION_ENGAGEMENT_LEVEL"] = 108] = "COMMUNICATION_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FRIEND_STORY_ENGAGEMENT_LEVEL"] = 109] = "FRIEND_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PUBLIC_USER_STORY_ENGAGEMENT_LEVEL"] = 110] = "PUBLIC_USER_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PUBLISHER_STORY_ENGAGEMENT_LEVEL"] = 111] = "PUBLISHER_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_ENGAGEMENT_LEVEL"] = 112] = "LENS_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NON_FRIEND_STORY_ENGAGEMENT_LEVEL"] = 113] = "NON_FRIEND_STORY_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FOLLOWER_SIZE_LEVEL"] = 114] = "FOLLOWER_SIZE_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_CREATION"] = 115] = "DAYS_SINCE_CREATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PERSONA"] = 116] = "USER_PERSONA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_CREATION_TIME"] = 117] = "USER_CREATION_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MOBILE_NETWORK_TYPE"] = 118] = "MOBILE_NETWORK_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AGGREGATED_USER_BANDWIDTH"] = 119] = "AGGREGATED_USER_BANDWIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_BIASED"] = 120] = "LENS_CLUSTER_BIASED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_LOG"] = 121] = "LENS_CLUSTER_LOG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_ORIG"] = 122] = "LENS_CLUSTER_ORIG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_ORIG_4"] = 123] = "LENS_CLUSTER_ORIG_4";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_BIASED_LOG"] = 124] = "LENS_CLUSTER_BIASED_LOG";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_LOCALE"] = 125] = "APP_LOCALE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_COMMON_NAME"] = 126] = "DEVICE_COMMON_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_FRIEND_COUNT"] = 127] = "USER_FRIEND_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["L90_COUNTRY"] = 128] = "L90_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STUB"] = 129] = "STUB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_TRUE"] = 130] = "IS_TRUE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_RATIO"] = 131] = "STORY_POST_RATIO";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GENDER"] = 132] = "GENDER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["INFERRED_AGE_BUCKET"] = 133] = "INFERRED_AGE_BUCKET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORIES"] = 134] = "STORIES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SENDS"] = 135] = "SENDS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_CREATE_L7"] = 136] = "SNAP_CREATE_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_L7"] = 137] = "STORY_POST_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNICATION_L7"] = 138] = "COMMUNICATION_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DF_L7"] = 139] = "DF_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_L7"] = 140] = "APP_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_CREATION_BUCKET"] = 141] = "DAYS_SINCE_CREATION_BUCKET";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BIDIRECTIONAL_FRIEND_STATUS"] = 142] = "BIDIRECTIONAL_FRIEND_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_POST_PREDICTION"] = 143] = "STORY_POST_PREDICTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPENS"] = 144] = "APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SWIPES"] = 145] = "LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SNAPS"] = 146] = "LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_OPS"] = 147] = "LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_APP_OPENS"] = 148] = "W1_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_SWIPES"] = 149] = "W1_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_SNAPS"] = 150] = "W1_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W1_LENS_OPS"] = 151] = "W1_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_APP_OPENS"] = 152] = "W2_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_SWIPES"] = 153] = "W2_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_SNAPS"] = 154] = "W2_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W2_LENS_OPS"] = 155] = "W2_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_APP_OPENS"] = 156] = "W34_APP_OPENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_SWIPES"] = 157] = "W34_LENS_SWIPES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_SNAPS"] = 158] = "W34_LENS_SNAPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["W34_LENS_OPS"] = 159] = "W34_LENS_OPS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_SWIPES_PREDICTION"] = 160] = "LENS_SWIPES_PREDICTION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REGISTRATION_COUNTRY"] = 161] = "REGISTRATION_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_ASN"] = 162] = "IP_ASN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_REGION"] = 163] = "IP_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IP_CITY"] = 164] = "IP_CITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_USER_ID"] = 165] = "HAS_USER_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_BITMOJI"] = 166] = "HAS_BITMOJI";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_APP_OPENS_LAST_8_DAYS"] = 167] = "NUM_APP_OPENS_LAST_8_DAYS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_FEATURE_STORY_VIEW_DAYS_L7"] = 168] = "NUM_FEATURE_STORY_VIEW_DAYS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_FEATURE_STORY_SYNC_DAYS_L7"] = 169] = "NUM_FEATURE_STORY_SYNC_DAYS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEXAGON_NN_SUPPORTED_VERSION"] = 170] = "HEXAGON_NN_SUPPORTED_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NETWORK_QUALITY"] = 171] = "NETWORK_QUALITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_MEMORY_MB"] = 172] = "DEVICE_MEMORY_MB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_GL_VERSION"] = 173] = "DEVICE_GL_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PRO_STATUS"] = 174] = "SNAP_PRO_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_VP9_DECODING_SUPPORT"] = 175] = "DEVICE_VP9_DECODING_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AVG_FRIEND_STORY_VIEW_COUNT_L7"] = 176] = "AVG_FRIEND_STORY_VIEW_COUNT_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GAME_JOIN_TIME"] = 177] = "GAME_JOIN_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GAME_LAST_ACTIVE_TIME"] = 178] = "GAME_LAST_ACTIVE_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_GAME_ACTIVITY"] = 179] = "DAYS_SINCE_FIRST_GAME_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_GAME_ACTIVITY"] = 180] = "DAYS_SINCE_LAST_GAME_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PF_PAGE_SESSIONS_WITH_LONG_IMP"] = 181] = "PF_PAGE_SESSIONS_WITH_LONG_IMP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WIRELESS_CARRIER"] = 182] = "WIRELESS_CARRIER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINIS_JOIN_TIME"] = 183] = "MINIS_JOIN_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MINIS_LAST_ACTIVE_TIME"] = 184] = "MINIS_LAST_ACTIVE_TIME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_MINIS_ACTIVITY"] = 185] = "DAYS_SINCE_FIRST_MINIS_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_MINIS_ACTIVITY"] = 186] = "DAYS_SINCE_LAST_MINIS_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DEVICE_AV1_DECODING_SUPPORT"] = 187] = "DEVICE_AV1_DECODING_SUPPORT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_PACKAGE_INSTALLER"] = 188] = "APP_PACKAGE_INSTALLER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STORY_VIEWS_5TH_TAB_ENGAGEMENT_LEVEL"] = 189] = "STORY_VIEWS_5TH_TAB_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REPORTED_AGE"] = 190] = "REPORTED_AGE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ANDROID_MOBILE_SERVICES_PROVIDER"] = 191] = "ANDROID_MOBILE_SERVICES_PROVIDER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ACQUIRED_USER"] = 192] = "IS_ACQUIRED_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["YDPI"] = 193] = "YDPI";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BIDIRECTIONAL_FRIEND_STATUS_VELLUM"] = 194] = "BIDIRECTIONAL_FRIEND_STATUS_VELLUM";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORIGIN"] = 195] = "ORIGIN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENSCORE_VERSION"] = 196] = "LENSCORE_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPKIT_APP_ID"] = 197] = "SNAPKIT_APP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GPU"] = 198] = "GPU";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHIPSET_NAME"] = 199] = "CHIPSET_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHIPSET_VERSION"] = 200] = "CHIPSET_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ZERO_IDFA"] = 201] = "HAS_ZERO_IDFA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LIMIT_AD_TRACKING"] = 202] = "LIMIT_AD_TRACKING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ATT_AUTH_STATUS"] = 203] = "ATT_AUTH_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_FRONT_SS_GAIN_OVER_TPA"] = 204] = "CAMERA2_FRONT_SS_GAIN_OVER_TPA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ATTACHMENT_TOOL_V2"] = 205] = "ATTACHMENT_TOOL_V2";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_PERSONA_V3"] = 206] = "USER_PERSONA_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPS_SEND_WITH_HEVC"] = 207] = "SNAPS_SEND_WITH_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAPS_SEND_WITHOUT_HEVC"] = 208] = "SNAPS_SEND_WITHOUT_HEVC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_NATIVE_CRASH_OVER_CAMERA1"] = 209] = "CAMERA2_NATIVE_CRASH_OVER_CAMERA1";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMERA2_G2S_LATENCY_OVER_CAMERA1"] = 210] = "CAMERA2_G2S_LATENCY_OVER_CAMERA1";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_INTERNAL"] = 211] = "IS_INTERNAL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_WEB"] = 212] = "IS_WEB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_MAP"] = 213] = "APP_OPEN_TO_MAP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_FRIENDSFEED"] = 214] = "APP_OPEN_TO_FRIENDSFEED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_LENSES"] = 215] = "APP_OPEN_TO_LENSES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_MEMORIES"] = 216] = "APP_OPEN_TO_MEMORIES";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_COMMUNITY"] = 217] = "APP_OPEN_TO_COMMUNITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["APP_OPEN_TO_SPOTLIGHT"] = 218] = "APP_OPEN_TO_SPOTLIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_IMPACTED_BY_PINC_893"] = 219] = "IS_IMPACTED_BY_PINC_893";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_BEFORE_BIRTHDAY"] = 220] = "DAYS_BEFORE_BIRTHDAY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_BIPA"] = 221] = "HAS_BIPA";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_STORY_ENGAGEMENT_STATUS"] = 222] = "SPOTLIGHT_STORY_ENGAGEMENT_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["INCLUSION_PANEL_MEMBER"] = 223] = "INCLUSION_PANEL_MEMBER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_HW_DECODER"] = 224] = "HEVC_HW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HEVC_SW_DECODER"] = 225] = "HEVC_SW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HASH_MURMUR3_128_MOD_100"] = 226] = "HASH_MURMUR3_128_MOD_100";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_ACTIVE_SNAPCHAT_PLUS"] = 227] = "HAS_ACTIVE_SNAPCHAT_PLUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_KIT_OAUTH_ID"] = 228] = "SNAP_KIT_OAUTH_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORGANIZATION_TYPE"] = 229] = "ORGANIZATION_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHUNK_UPLOAD_SUPPORT_REQUIRED"] = 230] = "CHUNK_UPLOAD_SUPPORT_REQUIRED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CLOUDFRONT_POP"] = 231] = "CLOUDFRONT_POP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_IMPRESSION_TIME_SECS_TO_NOW"] = 232] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_CLICK_COUNT"] = 233] = "BILLBOARD_CAMPAIGN_LOCAL_CLICK_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_INTERACTION_COUNT"] = 234] = "BILLBOARD_CAMPAIGN_LOCAL_INTERACTION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_INTERACTION_TIME_SECS_TO_NOW"] = 235] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FST_LOCK_SCREEN_WIDGET_BILLBOARD_LAUNCHED_FROM_PUSH"] = 236] = "FST_LOCK_SCREEN_WIDGET_BILLBOARD_LAUNCHED_FROM_PUSH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEB_SCREEN_WIDTH"] = 237] = "WEB_SCREEN_WIDTH";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEB_SCREEN_HEIGHT"] = 238] = "WEB_SCREEN_HEIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_IOS_LOCK_SCREEN_WIDGET_ENABLED"] = 239] = "SUP_IOS_LOCK_SCREEN_WIDGET_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PRIVACY"] = 240] = "SNAP_PRIVACY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ADS_INTERFACES_IS_NEW_ORGANIZATION"] = 241] = "ADS_INTERFACES_IS_NEW_ORGANIZATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SERVER_ONLY"] = 242] = "SERVER_ONLY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_ORGANIZATION"] = 243] = "GHE_ORGANIZATION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_REPOSITORY"] = 244] = "GHE_REPOSITORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GHE_USER_EMAIL"] = 245] = "GHE_USER_EMAIL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_DEFINITION_ID"] = 246] = "BUILD_DEFINITION_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUILD_DEFINITION_NAME"] = 247] = "BUILD_DEFINITION_NAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LCA_PRINCIPAL"] = 248] = "LCA_PRINCIPAL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MEDIA_PERFORMANCE_CLASS"] = 249] = "MEDIA_PERFORMANCE_CLASS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNITY_COUNT"] = 250] = "COMMUNITY_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RECIPIENTS_SUPPORT_FMP4"] = 251] = "RECIPIENTS_SUPPORT_FMP4";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SCREEN_ASPECT_RATIO"] = 252] = "SCREEN_ASPECT_RATIO";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_GROUP"] = 253] = "USER_GROUP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["USER_HAS_DENIED_CAMERA_PERM"] = 254] = "USER_HAS_DENIED_CAMERA_PERM";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAMEOS_ENGAGEMENT_LEVEL"] = 255] = "CAMEOS_ENGAGEMENT_LEVEL";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_CAMEOS"] = 256] = "HAS_CAMEOS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_ACTIVE_LENS_VIDEO_CHAT_USER"] = 257] = "IS_ACTIVE_LENS_VIDEO_CHAT_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_SPOTLIGHT_POSTS_L7"] = 258] = "NUM_SPOTLIGHT_POSTS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_MAP_POSTS_L7"] = 259] = "NUM_MAP_POSTS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_CREATED_PUBLIC_PROFILE"] = 260] = "HAS_CREATED_PUBLIC_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_PUBLIC_PROFILE_ACCESS_VIA_ROLE"] = 261] = "HAS_PUBLIC_PROFILE_ACCESS_VIA_ROLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_CAMERA_PERM_DENY"] = 262] = "DAYS_SINCE_LAST_CAMERA_PERM_DENY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_AD_ORG_JOIN"] = 263] = "DAYS_SINCE_AD_ORG_JOIN";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_AD_CREATE"] = 264] = "DAYS_SINCE_FIRST_AD_CREATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ORGANIZATION_COUNTRY"] = 265] = "ORGANIZATION_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_DWEB_VISIT"] = 266] = "DAYS_SINCE_FIRST_DWEB_VISIT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_DWEB_VISIT"] = 267] = "DAYS_SINCE_LAST_DWEB_VISIT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["WEEKS_SINCE_USING_DWEB"] = 268] = "WEEKS_SINCE_USING_DWEB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_LENS"] = 269] = "HAS_LENS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_IMPRESSION_COUNT"] = 270] = "BILLBOARD_SERVER_IMPRESSION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_CLICK_COUNT"] = 271] = "BILLBOARD_SERVER_CLICK_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_DISMISS_COUNT"] = 272] = "BILLBOARD_SERVER_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_INTERACTION_COUNT"] = 273] = "BILLBOARD_SERVER_INTERACTION_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_IMPRESSION_TIME_SECS_TO_NOW"] = 274] = "BILLBOARD_SERVER_FIRST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_IMPRESSION_TIME_SECS_TO_NOW"] = 275] = "BILLBOARD_SERVER_LAST_IMPRESSION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_CLICK_TIME_SECS_TO_NOW"] = 276] = "BILLBOARD_SERVER_FIRST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_CLICK_TIME_SECS_TO_NOW"] = 277] = "BILLBOARD_SERVER_LAST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_DISMISS_TIME_SECS_TO_NOW"] = 278] = "BILLBOARD_SERVER_FIRST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_DISMISS_TIME_SECS_TO_NOW"] = 279] = "BILLBOARD_SERVER_LAST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_FIRST_INTERACTION_TIME_SECS_TO_NOW"] = 280] = "BILLBOARD_SERVER_FIRST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_LAST_INTERACTION_TIME_SECS_TO_NOW"] = 281] = "BILLBOARD_SERVER_LAST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_SERVER_CONTINUOUS_DISMISS_COUNT"] = 282] = "BILLBOARD_SERVER_CONTINUOUS_DISMISS_COUNT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_CLICK_TIME_SECS_TO_NOW"] = 283] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_CLICK_TIME_SECS_TO_NOW"] = 284] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_CLICK_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_DISMISS_TIME_SECS_TO_NOW"] = 285] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_LAST_DISMISS_TIME_SECS_TO_NOW"] = 286] = "BILLBOARD_CAMPAIGN_LOCAL_LAST_DISMISS_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BILLBOARD_CAMPAIGN_LOCAL_FIRST_INTERACTION_TIME_SECS_TO_NOW"] = 287] = "BILLBOARD_CAMPAIGN_LOCAL_FIRST_INTERACTION_TIME_SECS_TO_NOW";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_FIRST_AD_SPEND"] = 288] = "DAYS_SINCE_FIRST_AD_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_AD_SPEND"] = 289] = "DAYS_SINCE_LAST_AD_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_2_PLUS_STORY_SESSION_7D_STATUS_DETAILED"] = 290] = "SPOTLIGHT_2_PLUS_STORY_SESSION_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_5_PLUS_STORY_SESSION_7D_STATUS_DETAILED"] = 291] = "SPOTLIGHT_5_PLUS_STORY_SESSION_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SPOTLIGHT_STORY_VIEW_7D_STATUS_DETAILED"] = 292] = "SPOTLIGHT_STORY_VIEW_7D_STATUS_DETAILED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LAST_USER_ACCEPTED_TOS"] = 293] = "LAST_USER_ACCEPTED_TOS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UPDATED_DEVICE_CLUSTER"] = 294] = "UPDATED_DEVICE_CLUSTER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CREATOR_TIER"] = 295] = "CREATOR_TIER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_SW_DECODER"] = 296] = "AV1_SW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AV1_HW_DECODER"] = 297] = "AV1_HW_DECODER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_EXPLICIT_PUBLIC_PROFILE"] = 298] = "HAS_EXPLICIT_PUBLIC_PROFILE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LARGER_TEXT_DISPLAY_OPTION_ENABLED"] = 299] = "LARGER_TEXT_DISPLAY_OPTION_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_PUBLIC_POSTING_PREFERRED_USER"] = 300] = "IS_PUBLIC_POSTING_PREFERRED_USER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RUID"] = 301] = "RUID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["MUTABLE_USERNAME"] = 302] = "MUTABLE_USERNAME";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BUDGET_GROUP_ID"] = 303] = "BUDGET_GROUP_ID";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AB_POPULATION_RANGE_HASH_FUNC"] = 304] = "AB_POPULATION_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AB_TREATMENT_RANGE_HASH_FUNC"] = 305] = "AB_TREATMENT_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REGISTRATION_IP_REGION"] = 306] = "REGISTRATION_IP_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["RUID_TYPE"] = 307] = "RUID_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["PLUS_INTERNAL_ONLY"] = 308] = "PLUS_INTERNAL_ONLY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COF_ROLLOUT_RANGE_HASH_FUNC"] = 309] = "COF_ROLLOUT_RANGE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_HAS_AI_SELFIE"] = 341] = "SUP_HAS_AI_SELFIE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SUP_HAS_DREAMS"] = 342] = "SUP_HAS_DREAMS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DAYS_SINCE_LAST_ACTIVITY"] = 343] = "DAYS_SINCE_LAST_ACTIVITY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_OS_GRANTED"] = 344] = "CONTACT_PERM_OS_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_PERM_USER_GRANTED"] = 345] = "CONTACT_PERM_USER_GRANTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["LENS_CLUSTER_GPU_V2"] = 346] = "LENS_CLUSTER_GPU_V2";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CAN_ACCESS_ADS_TAB"] = 347] = "CAN_ACCESS_ADS_TAB";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GOOGLE_CDN_POP"] = 348] = "GOOGLE_CDN_POP";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_STRONG_RELATIONSHIPS_V3"] = 349] = "NUM_STRONG_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_CLOSE_PLUS_RELATIONSHIPS_V3"] = 350] = "NUM_CLOSE_PLUS_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_ACQUAINTANCE_PLUS_RELATIONSHIPS_V3"] = 351] = "NUM_ACQUAINTANCE_PLUS_RELATIONSHIPS_V3";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DREAMS_ENGAGEMENT_STATUS"] = 352] = "DREAMS_ENGAGEMENT_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_LOW_LIGHT"] = 353] = "IS_LOW_LIGHT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GALLERY_HAS_2023_YEAR_END_STORY"] = 354] = "GALLERY_HAS_2023_YEAR_END_STORY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CHUNK_UPLOAD_PREFERENCE"] = 355] = "CHUNK_UPLOAD_PREFERENCE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ADMIN_USE_ONLY_IN_AB_TRAFFIC_SPLIT"] = 356] = "ADMIN_USE_ONLY_IN_AB_TRAFFIC_SPLIT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_IPHONE"] = 357] = "IS_IPHONE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_S11_COUNTRY"] = 358] = "IS_S11_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_S11_L90_COUNTRY"] = 359] = "IS_S11_L90_COUNTRY";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_ACTIVE_FRIENDS_L7"] = 360] = "NUM_ACTIVE_FRIENDS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["NUM_BIDIRECTIONAL_COMMUNICATION_FRIENDS_L7"] = 361] = "NUM_BIDIRECTIONAL_COMMUNICATION_FRIENDS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["FULLY_ROLLED_OUT_STUDIES_OPTIMIZATION_ENABLED"] = 362] = "FULLY_ROLLED_OUT_STUDIES_OPTIMIZATION_ENABLED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_USER_ONBOARDED"] = 367] = "HAS_USER_ONBOARDED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ADS_STANDARD_AB_HASH_FUNC"] = 368] = "ADS_STANDARD_AB_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_TOP_STORY_POSTER"] = 369] = "IS_TOP_STORY_POSTER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COMMUNITY_COUNT_SERVER"] = 370] = "COMMUNITY_COUNT_SERVER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["REPORT_VOLUME_LAST_14_DAYS"] = 371] = "REPORT_VOLUME_LAST_14_DAYS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_CONCURRENT_CAMERA_SUPPORTED"] = 372] = "IS_CONCURRENT_CAMERA_SUPPORTED";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["CONTACT_AUTHORIZATION_STATUS"] = 373] = "CONTACT_AUTHORIZATION_STATUS";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DISCOVER_FEED_TYPE"] = 374] = "DISCOVER_FEED_TYPE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["JOINED_VIA_USER_INVITE"] = 377] = "JOINED_VIA_USER_INVITE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["STICKY_REGION"] = 378] = "STICKY_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["BIPA_REGION"] = 379] = "BIPA_REGION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["GRADUAL_ROLLOUT_HASH_FUNC"] = 380] = "GRADUAL_ROLLOUT_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_COF_EDGE_CLIENT"] = 381] = "IS_COF_EDGE_CLIENT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["COF_EDGE_CLIENT_VERSION"] = 382] = "COF_EDGE_CLIENT_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_DORMANT"] = 383] = "IS_DORMANT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["HAS_FORMER_PHONE_NUMBER"] = 384] = "HAS_FORMER_PHONE_NUMBER";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["OS_BUILD_VERSION"] = 385] = "OS_BUILD_VERSION";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_DAYS_SINCE_FIRST_AD_CREATE"] = 386] = "SNAP_PROMOTE_DAYS_SINCE_FIRST_AD_CREATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_DAYS_SINCE_LAST_AD_CREATE"] = 387] = "SNAP_PROMOTE_DAYS_SINCE_LAST_AD_CREATE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_DAYS_SINCE_FIRST_SPEND"] = 388] = "SNAP_PROMOTE_DAYS_SINCE_FIRST_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_DAYS_SINCE_LAST_SPEND"] = 389] = "SNAP_PROMOTE_DAYS_SINCE_LAST_SPEND";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_TOTAL_SPEND_USD"] = 390] = "SNAP_PROMOTE_TOTAL_SPEND_USD";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_AVG_DAILY_SPEND_USD"] = 391] = "SNAP_PROMOTE_AVG_DAILY_SPEND_USD";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_LAST_OBJECTIVE"] = 392] = "SNAP_PROMOTE_LAST_OBJECTIVE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["SNAP_PROMOTE_BUDGET_REMAINING"] = 393] = "SNAP_PROMOTE_BUDGET_REMAINING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_MONETIZATION_ELIGIBLE"] = 394] = "IS_MONETIZATION_ELIGIBLE";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["IS_OPTED_IN_DATA_SHARING"] = 395] = "IS_OPTED_IN_DATA_SHARING";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["ADS_BUDGET_AB_MACROSTATE_HASH_FUNC"] = 396] = "ADS_BUDGET_AB_MACROSTATE_HASH_FUNC";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["AB_TREATMENT"] = 397] = "AB_TREATMENT";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["DREAMS_IN_SNAPFEED_VIEW_ACTIVE_DAYS_L7"] = 398] = "DREAMS_IN_SNAPFEED_VIEW_ACTIVE_DAYS_L7";
  ClientTargetingExpression_Property2[ClientTargetingExpression_Property2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_Property || (ClientTargetingExpression_Property = {}));
var ClientTargetingExpression_PropertyMetadata_SignalToHash;
(function(ClientTargetingExpression_PropertyMetadata_SignalToHash2) {
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["UNKNOWN_SIGNAL_TO_HASH"] = 0] = "UNKNOWN_SIGNAL_TO_HASH";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["HASH_SEED_AND_USER_ID"] = 1] = "HASH_SEED_AND_USER_ID";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["HASH_USER_ID_AND_NAMESPACE"] = 2] = "HASH_USER_ID_AND_NAMESPACE";
  ClientTargetingExpression_PropertyMetadata_SignalToHash2[ClientTargetingExpression_PropertyMetadata_SignalToHash2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ClientTargetingExpression_PropertyMetadata_SignalToHash || (ClientTargetingExpression_PropertyMetadata_SignalToHash = {}));
function createBaseConfigResult() {
  return {
    configId: "",
    value: void 0,
    targetingExpression: void 0,
    ttlSeconds: "0",
    configRuleUuidBytes: new Uint8Array(0),
    priority: 0,
    namespace: 0,
    studyName: "",
    experimentId: 0,
    delete: false,
    servePlatforms: [],
    sequenceId: 0,
    ruidType: 0,
    segmentOrdinal: 0,
    generatedFromAbAllowlists: false,
    internalFields: void 0,
    configIntId: 0
  };
}
var ConfigResult = {
  encode(message, writer = new BinaryWriter()) {
    if (message.configId !== "") {
      writer.uint32(10).string(message.configId);
    }
    if (message.value !== void 0) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    if (message.targetingExpression !== void 0) {
      ClientTargetingExpression.encode(message.targetingExpression, writer.uint32(26).fork()).join();
    }
    if (message.ttlSeconds !== "0") {
      writer.uint32(32).int64(message.ttlSeconds);
    }
    if (message.configRuleUuidBytes.length !== 0) {
      writer.uint32(42).bytes(message.configRuleUuidBytes);
    }
    if (message.priority !== 0) {
      writer.uint32(48).int32(message.priority);
    }
    if (message.namespace !== 0) {
      writer.uint32(56).int32(message.namespace);
    }
    if (message.studyName !== "") {
      writer.uint32(66).string(message.studyName);
    }
    if (message.experimentId !== 0) {
      writer.uint32(72).int32(message.experimentId);
    }
    if (message.delete !== false) {
      writer.uint32(80).bool(message.delete);
    }
    writer.uint32(90).fork();
    for (const v2 of message.servePlatforms) {
      writer.int32(v2);
    }
    writer.join();
    if (message.sequenceId !== 0) {
      writer.uint32(96).int32(message.sequenceId);
    }
    if (message.ruidType !== 0) {
      writer.uint32(104).int32(message.ruidType);
    }
    if (message.segmentOrdinal !== 0) {
      writer.uint32(112).int32(message.segmentOrdinal);
    }
    if (message.generatedFromAbAllowlists !== false) {
      writer.uint32(120).bool(message.generatedFromAbAllowlists);
    }
    if (message.internalFields !== void 0) {
      ConfigResult_InternalFields.encode(message.internalFields, writer.uint32(130).fork()).join();
    }
    if (message.configIntId !== 0) {
      writer.uint32(149).sfixed32(message.configIntId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.targetingExpression = ClientTargetingExpression.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.ttlSeconds = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.configRuleUuidBytes = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.priority = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.namespace = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.studyName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.experimentId = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.delete = reader.bool();
          continue;
        }
        case 11: {
          if (tag === 88) {
            message.servePlatforms.push(reader.int32());
            continue;
          }
          if (tag === 90) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.servePlatforms.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }
          message.sequenceId = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.ruidType = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }
          message.segmentOrdinal = reader.int32();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }
          message.generatedFromAbAllowlists = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.internalFields = ConfigResult_InternalFields.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 149) {
            break;
          }
          message.configIntId = reader.sfixed32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigResult.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const message = createBaseConfigResult();
    message.configId = (_a = object.configId) !== null && _a !== void 0 ? _a : "";
    message.value = object.value !== void 0 && object.value !== null ? Value.fromPartial(object.value) : void 0;
    message.targetingExpression = object.targetingExpression !== void 0 && object.targetingExpression !== null ? ClientTargetingExpression.fromPartial(object.targetingExpression) : void 0;
    message.ttlSeconds = (_b = object.ttlSeconds) !== null && _b !== void 0 ? _b : "0";
    message.configRuleUuidBytes = (_c = object.configRuleUuidBytes) !== null && _c !== void 0 ? _c : new Uint8Array(0);
    message.priority = (_d = object.priority) !== null && _d !== void 0 ? _d : 0;
    message.namespace = (_e = object.namespace) !== null && _e !== void 0 ? _e : 0;
    message.studyName = (_f = object.studyName) !== null && _f !== void 0 ? _f : "";
    message.experimentId = (_g = object.experimentId) !== null && _g !== void 0 ? _g : 0;
    message.delete = (_h = object.delete) !== null && _h !== void 0 ? _h : false;
    message.servePlatforms = ((_j = object.servePlatforms) === null || _j === void 0 ? void 0 : _j.map((e2) => e2)) || [];
    message.sequenceId = (_k = object.sequenceId) !== null && _k !== void 0 ? _k : 0;
    message.ruidType = (_l = object.ruidType) !== null && _l !== void 0 ? _l : 0;
    message.segmentOrdinal = (_m = object.segmentOrdinal) !== null && _m !== void 0 ? _m : 0;
    message.generatedFromAbAllowlists = (_o = object.generatedFromAbAllowlists) !== null && _o !== void 0 ? _o : false;
    message.internalFields = object.internalFields !== void 0 && object.internalFields !== null ? ConfigResult_InternalFields.fromPartial(object.internalFields) : void 0;
    message.configIntId = (_p = object.configIntId) !== null && _p !== void 0 ? _p : 0;
    return message;
  }
};
function createBaseConfigResult_InternalFields() {
  return {
    configBitmapIndex: 0,
    configResultBitmapIndex: 0,
    hasServerPropertiesOnly: false,
    globalPriority: 0,
    sequenceIds: [],
    studySegmentOrdinal: 0,
    experimentGuid: "0",
    isAbStudyStatusCompleted: false,
    gradualRolloutId: "",
    gradualRolloutIsControl: false,
    gradualRolloutIsDeleted: false
  };
}
var ConfigResult_InternalFields = {
  encode(message, writer = new BinaryWriter()) {
    if (message.configBitmapIndex !== 0) {
      writer.uint32(8).int32(message.configBitmapIndex);
    }
    if (message.configResultBitmapIndex !== 0) {
      writer.uint32(16).int32(message.configResultBitmapIndex);
    }
    if (message.hasServerPropertiesOnly !== false) {
      writer.uint32(24).bool(message.hasServerPropertiesOnly);
    }
    if (message.globalPriority !== 0) {
      writer.uint32(32).int32(message.globalPriority);
    }
    for (const v2 of message.sequenceIds) {
      ConfigResult_InternalFields_SequenceIdCandidate.encode(v2, writer.uint32(42).fork()).join();
    }
    if (message.studySegmentOrdinal !== 0) {
      writer.uint32(48).int32(message.studySegmentOrdinal);
    }
    if (message.experimentGuid !== "0") {
      writer.uint32(56).uint64(message.experimentGuid);
    }
    if (message.isAbStudyStatusCompleted !== false) {
      writer.uint32(64).bool(message.isAbStudyStatusCompleted);
    }
    if (message.gradualRolloutId !== "") {
      writer.uint32(74).string(message.gradualRolloutId);
    }
    if (message.gradualRolloutIsControl !== false) {
      writer.uint32(80).bool(message.gradualRolloutIsControl);
    }
    if (message.gradualRolloutIsDeleted !== false) {
      writer.uint32(88).bool(message.gradualRolloutIsDeleted);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult_InternalFields();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.configBitmapIndex = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.configResultBitmapIndex = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.hasServerPropertiesOnly = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.globalPriority = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.sequenceIds.push(ConfigResult_InternalFields_SequenceIdCandidate.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.studySegmentOrdinal = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.experimentGuid = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.isAbStudyStatusCompleted = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.gradualRolloutId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.gradualRolloutIsControl = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.gradualRolloutIsDeleted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigResult_InternalFields.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = createBaseConfigResult_InternalFields();
    message.configBitmapIndex = (_a = object.configBitmapIndex) !== null && _a !== void 0 ? _a : 0;
    message.configResultBitmapIndex = (_b = object.configResultBitmapIndex) !== null && _b !== void 0 ? _b : 0;
    message.hasServerPropertiesOnly = (_c = object.hasServerPropertiesOnly) !== null && _c !== void 0 ? _c : false;
    message.globalPriority = (_d = object.globalPriority) !== null && _d !== void 0 ? _d : 0;
    message.sequenceIds = ((_e = object.sequenceIds) === null || _e === void 0 ? void 0 : _e.map((e2) => ConfigResult_InternalFields_SequenceIdCandidate.fromPartial(e2))) || [];
    message.studySegmentOrdinal = (_f = object.studySegmentOrdinal) !== null && _f !== void 0 ? _f : 0;
    message.experimentGuid = (_g = object.experimentGuid) !== null && _g !== void 0 ? _g : "0";
    message.isAbStudyStatusCompleted = (_h = object.isAbStudyStatusCompleted) !== null && _h !== void 0 ? _h : false;
    message.gradualRolloutId = (_j = object.gradualRolloutId) !== null && _j !== void 0 ? _j : "";
    message.gradualRolloutIsControl = (_k = object.gradualRolloutIsControl) !== null && _k !== void 0 ? _k : false;
    message.gradualRolloutIsDeleted = (_l = object.gradualRolloutIsDeleted) !== null && _l !== void 0 ? _l : false;
    return message;
  }
};
function createBaseConfigResult_InternalFields_SequenceIdCandidate() {
  return { targetingExpression: void 0, sequenceId: 0 };
}
var ConfigResult_InternalFields_SequenceIdCandidate = {
  encode(message, writer = new BinaryWriter()) {
    if (message.targetingExpression !== void 0) {
      ClientTargetingExpression.encode(message.targetingExpression, writer.uint32(10).fork()).join();
    }
    if (message.sequenceId !== 0) {
      writer.uint32(16).int32(message.sequenceId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResult_InternalFields_SequenceIdCandidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.targetingExpression = ClientTargetingExpression.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.sequenceId = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigResult_InternalFields_SequenceIdCandidate.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigResult_InternalFields_SequenceIdCandidate();
    message.targetingExpression = object.targetingExpression !== void 0 && object.targetingExpression !== null ? ClientTargetingExpression.fromPartial(object.targetingExpression) : void 0;
    message.sequenceId = (_a = object.sequenceId) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};
function createBaseClientTargetingExpression() {
  return {
    operator: 0,
    children: [],
    property: 0,
    predicateOperator: 0,
    value: void 0,
    propertyMetadata: void 0
  };
}
var ClientTargetingExpression = {
  encode(message, writer = new BinaryWriter()) {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    for (const v2 of message.children) {
      ClientTargetingExpression.encode(v2, writer.uint32(18).fork()).join();
    }
    if (message.property !== 0) {
      writer.uint32(24).int32(message.property);
    }
    if (message.predicateOperator !== 0) {
      writer.uint32(32).int32(message.predicateOperator);
    }
    if (message.value !== void 0) {
      Value.encode(message.value, writer.uint32(42).fork()).join();
    }
    if (message.propertyMetadata !== void 0) {
      ClientTargetingExpression_PropertyMetadata.encode(message.propertyMetadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientTargetingExpression();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.operator = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.children.push(ClientTargetingExpression.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.property = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.predicateOperator = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.propertyMetadata = ClientTargetingExpression_PropertyMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ClientTargetingExpression.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseClientTargetingExpression();
    message.operator = (_a = object.operator) !== null && _a !== void 0 ? _a : 0;
    message.children = ((_b = object.children) === null || _b === void 0 ? void 0 : _b.map((e2) => ClientTargetingExpression.fromPartial(e2))) || [];
    message.property = (_c = object.property) !== null && _c !== void 0 ? _c : 0;
    message.predicateOperator = (_d = object.predicateOperator) !== null && _d !== void 0 ? _d : 0;
    message.value = object.value !== void 0 && object.value !== null ? Value.fromPartial(object.value) : void 0;
    message.propertyMetadata = object.propertyMetadata !== void 0 && object.propertyMetadata !== null ? ClientTargetingExpression_PropertyMetadata.fromPartial(object.propertyMetadata) : void 0;
    return message;
  }
};
function createBaseClientTargetingExpression_PropertyMetadata() {
  return {
    itemId: 0,
    signalToHash: 0,
    abNamespaceForHashing: "",
    abSeedForHashing: "",
    ruidType: void 0,
    cofRolloutSeedForHashing: "",
    adsNonBudgetSegmentLayer: 0,
    adsBudgetAbMacrostateName: ""
  };
}
var ClientTargetingExpression_PropertyMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.itemId !== 0) {
      writer.uint32(8).int32(message.itemId);
    }
    if (message.signalToHash !== 0) {
      writer.uint32(16).int32(message.signalToHash);
    }
    if (message.abNamespaceForHashing !== "") {
      writer.uint32(26).string(message.abNamespaceForHashing);
    }
    if (message.abSeedForHashing !== "") {
      writer.uint32(34).string(message.abSeedForHashing);
    }
    if (message.ruidType !== void 0) {
      writer.uint32(40).int32(message.ruidType);
    }
    if (message.cofRolloutSeedForHashing !== "") {
      writer.uint32(50).string(message.cofRolloutSeedForHashing);
    }
    if (message.adsNonBudgetSegmentLayer !== 0) {
      writer.uint32(56).int32(message.adsNonBudgetSegmentLayer);
    }
    if (message.adsBudgetAbMacrostateName !== "") {
      writer.uint32(66).string(message.adsBudgetAbMacrostateName);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseClientTargetingExpression_PropertyMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.itemId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.signalToHash = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.abNamespaceForHashing = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.abSeedForHashing = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.ruidType = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.cofRolloutSeedForHashing = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.adsNonBudgetSegmentLayer = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.adsBudgetAbMacrostateName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ClientTargetingExpression_PropertyMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const message = createBaseClientTargetingExpression_PropertyMetadata();
    message.itemId = (_a = object.itemId) !== null && _a !== void 0 ? _a : 0;
    message.signalToHash = (_b = object.signalToHash) !== null && _b !== void 0 ? _b : 0;
    message.abNamespaceForHashing = (_c = object.abNamespaceForHashing) !== null && _c !== void 0 ? _c : "";
    message.abSeedForHashing = (_d = object.abSeedForHashing) !== null && _d !== void 0 ? _d : "";
    message.ruidType = (_e = object.ruidType) !== null && _e !== void 0 ? _e : void 0;
    message.cofRolloutSeedForHashing = (_f = object.cofRolloutSeedForHashing) !== null && _f !== void 0 ? _f : "";
    message.adsNonBudgetSegmentLayer = (_g = object.adsNonBudgetSegmentLayer) !== null && _g !== void 0 ? _g : 0;
    message.adsBudgetAbMacrostateName = (_h = object.adsBudgetAbMacrostateName) !== null && _h !== void 0 ? _h : "";
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/config_response.js
function createBaseConfigTargetingResponseDebugData() {
  return { abResultChecksumInput: "" };
}
var ConfigTargetingResponseDebugData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.abResultChecksumInput !== "") {
      writer.uint32(10).string(message.abResultChecksumInput);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingResponseDebugData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.abResultChecksumInput = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigTargetingResponseDebugData.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigTargetingResponseDebugData();
    message.abResultChecksumInput = (_a = object.abResultChecksumInput) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseConfigTargetingResponse() {
  return {
    configResults: [],
    configResultsEtag: "",
    benchmarkRequest: void 0,
    fullResults: false,
    abResultChecksum: 0,
    iso3166Alpha2CountryCodeFromRequestIp: "",
    debugData: void 0,
    cofGrapheneContext: new Uint8Array(0)
  };
}
var ConfigTargetingResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).join();
    }
    if (message.configResultsEtag !== "") {
      writer.uint32(18).string(message.configResultsEtag);
    }
    if (message.benchmarkRequest !== void 0) {
      BenchmarkRequest.encode(message.benchmarkRequest, writer.uint32(26).fork()).join();
    }
    if (message.fullResults !== false) {
      writer.uint32(32).bool(message.fullResults);
    }
    if (message.abResultChecksum !== 0) {
      writer.uint32(40).int32(message.abResultChecksum);
    }
    if (message.iso3166Alpha2CountryCodeFromRequestIp !== "") {
      writer.uint32(50).string(message.iso3166Alpha2CountryCodeFromRequestIp);
    }
    if (message.debugData !== void 0) {
      ConfigTargetingResponseDebugData.encode(message.debugData, writer.uint32(58).fork()).join();
    }
    if (message.cofGrapheneContext.length !== 0) {
      writer.uint32(106).bytes(message.cofGrapheneContext);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigTargetingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.configResultsEtag = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.benchmarkRequest = BenchmarkRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.fullResults = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.abResultChecksum = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.iso3166Alpha2CountryCodeFromRequestIp = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.debugData = ConfigTargetingResponseDebugData.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }
          message.cofGrapheneContext = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigTargetingResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseConfigTargetingResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    message.configResultsEtag = (_b = object.configResultsEtag) !== null && _b !== void 0 ? _b : "";
    message.benchmarkRequest = object.benchmarkRequest !== void 0 && object.benchmarkRequest !== null ? BenchmarkRequest.fromPartial(object.benchmarkRequest) : void 0;
    message.fullResults = (_c = object.fullResults) !== null && _c !== void 0 ? _c : false;
    message.abResultChecksum = (_d = object.abResultChecksum) !== null && _d !== void 0 ? _d : 0;
    message.iso3166Alpha2CountryCodeFromRequestIp = (_e = object.iso3166Alpha2CountryCodeFromRequestIp) !== null && _e !== void 0 ? _e : "";
    message.debugData = object.debugData !== void 0 && object.debugData !== null ? ConfigTargetingResponseDebugData.fromPartial(object.debugData) : void 0;
    message.cofGrapheneContext = (_f = object.cofGrapheneContext) !== null && _f !== void 0 ? _f : new Uint8Array(0);
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/debug_info.js
var AbStep;
(function(AbStep2) {
  AbStep2[AbStep2["USER_WHITELISTED"] = 0] = "USER_WHITELISTED";
  AbStep2[AbStep2["USER_GROUP_WHITELISTED"] = 1] = "USER_GROUP_WHITELISTED";
  AbStep2[AbStep2["FILTER_CONDITIONS"] = 2] = "FILTER_CONDITIONS";
  AbStep2[AbStep2["SLICE_RANGE"] = 3] = "SLICE_RANGE";
  AbStep2[AbStep2["TRAFFIC_ALLOCATED"] = 4] = "TRAFFIC_ALLOCATED";
  AbStep2[AbStep2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AbStep || (AbStep = {}));
var CofStep;
(function(CofStep2) {
  CofStep2[CofStep2["VALIDATE_REQUEST"] = 0] = "VALIDATE_REQUEST";
  CofStep2[CofStep2["REQUEST_ATLAS"] = 1] = "REQUEST_ATLAS";
  CofStep2[CofStep2["BUILD_TARGETING_INFO"] = 2] = "BUILD_TARGETING_INFO";
  CofStep2[CofStep2["QUERY_INDEX"] = 3] = "QUERY_INDEX";
  CofStep2[CofStep2["REQUEST_AB"] = 4] = "REQUEST_AB";
  CofStep2[CofStep2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CofStep || (CofStep = {}));
function createBaseAbStepInfo() {
  return { abStep: 0, info: "" };
}
var AbStepInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.abStep !== 0) {
      writer.uint32(8).int32(message.abStep);
    }
    if (message.info !== "") {
      writer.uint32(18).string(message.info);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAbStepInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.abStep = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.info = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return AbStepInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseAbStepInfo();
    message.abStep = (_a = object.abStep) !== null && _a !== void 0 ? _a : 0;
    message.info = (_b = object.info) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseCofStepInfo() {
  return { cofStep: 0, info: "" };
}
var CofStepInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cofStep !== 0) {
      writer.uint32(8).int32(message.cofStep);
    }
    if (message.info !== "") {
      writer.uint32(18).string(message.info);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCofStepInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.cofStep = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.info = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return CofStepInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCofStepInfo();
    message.cofStep = (_a = object.cofStep) !== null && _a !== void 0 ? _a : 0;
    message.info = (_b = object.info) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseDebugTrace() {
  return { lastCofStep: void 0, lastAbStep: void 0, budgetGroupId: 0 };
}
var DebugTrace = {
  encode(message, writer = new BinaryWriter()) {
    if (message.lastCofStep !== void 0) {
      CofStepInfo.encode(message.lastCofStep, writer.uint32(10).fork()).join();
    }
    if (message.lastAbStep !== void 0) {
      AbStepInfo.encode(message.lastAbStep, writer.uint32(18).fork()).join();
    }
    if (message.budgetGroupId !== 0) {
      writer.uint32(24).uint32(message.budgetGroupId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDebugTrace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lastCofStep = CofStepInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lastAbStep = AbStepInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.budgetGroupId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return DebugTrace.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseDebugTrace();
    message.lastCofStep = object.lastCofStep !== void 0 && object.lastCofStep !== null ? CofStepInfo.fromPartial(object.lastCofStep) : void 0;
    message.lastAbStep = object.lastAbStep !== void 0 && object.lastAbStep !== null ? AbStepInfo.fromPartial(object.lastAbStep) : void 0;
    message.budgetGroupId = (_a = object.budgetGroupId) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/content/media_reference.js
var VideoDescription_MediaQualityType;
(function(VideoDescription_MediaQualityType2) {
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_UNKNOWN"] = 0] = "MEDIA_QUALITY_TYPE_UNKNOWN";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_1"] = 100] = "MEDIA_QUALITY_TYPE_LEVEL_1";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_2"] = 200] = "MEDIA_QUALITY_TYPE_LEVEL_2";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_3"] = 300] = "MEDIA_QUALITY_TYPE_LEVEL_3";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_4"] = 400] = "MEDIA_QUALITY_TYPE_LEVEL_4";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_5"] = 500] = "MEDIA_QUALITY_TYPE_LEVEL_5";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_6"] = 600] = "MEDIA_QUALITY_TYPE_LEVEL_6";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_7"] = 700] = "MEDIA_QUALITY_TYPE_LEVEL_7";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_MAX"] = 5e3] = "MEDIA_QUALITY_TYPE_LEVEL_MAX";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_4_5"] = 450] = "MEDIA_QUALITY_TYPE_LEVEL_4_5";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_2_1"] = 210] = "MEDIA_QUALITY_TYPE_LEVEL_2_1";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_2_2"] = 220] = "MEDIA_QUALITY_TYPE_LEVEL_2_2";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_2_5"] = 250] = "MEDIA_QUALITY_TYPE_LEVEL_2_5";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_3_2"] = 320] = "MEDIA_QUALITY_TYPE_LEVEL_3_2";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_3_5"] = 350] = "MEDIA_QUALITY_TYPE_LEVEL_3_5";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_2_7"] = 270] = "MEDIA_QUALITY_TYPE_LEVEL_2_7";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["MEDIA_QUALITY_TYPE_LEVEL_6_5"] = 650] = "MEDIA_QUALITY_TYPE_LEVEL_6_5";
  VideoDescription_MediaQualityType2[VideoDescription_MediaQualityType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VideoDescription_MediaQualityType || (VideoDescription_MediaQualityType = {}));
var VideoDescription_VideoPlaybackType;
(function(VideoDescription_VideoPlaybackType2) {
  VideoDescription_VideoPlaybackType2[VideoDescription_VideoPlaybackType2["UNKNOWN_VIDEO_PLAYBACK_TYPE"] = 0] = "UNKNOWN_VIDEO_PLAYBACK_TYPE";
  VideoDescription_VideoPlaybackType2[VideoDescription_VideoPlaybackType2["FASTSTART_DISABLED"] = 1] = "FASTSTART_DISABLED";
  VideoDescription_VideoPlaybackType2[VideoDescription_VideoPlaybackType2["FASTSTART_ENABLED"] = 2] = "FASTSTART_ENABLED";
  VideoDescription_VideoPlaybackType2[VideoDescription_VideoPlaybackType2["HTTP_STREAMING_DASH"] = 3] = "HTTP_STREAMING_DASH";
  VideoDescription_VideoPlaybackType2[VideoDescription_VideoPlaybackType2["HTTP_STREAMING_HLS"] = 4] = "HTTP_STREAMING_HLS";
  VideoDescription_VideoPlaybackType2[VideoDescription_VideoPlaybackType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VideoDescription_VideoPlaybackType || (VideoDescription_VideoPlaybackType = {}));
var MediaReference_ClaimBehavior;
(function(MediaReference_ClaimBehavior2) {
  MediaReference_ClaimBehavior2[MediaReference_ClaimBehavior2["CAN_EXTEND_MEDIA_CLAIM"] = 0] = "CAN_EXTEND_MEDIA_CLAIM";
  MediaReference_ClaimBehavior2[MediaReference_ClaimBehavior2["DO_NOT_CLAIM"] = 1] = "DO_NOT_CLAIM";
  MediaReference_ClaimBehavior2[MediaReference_ClaimBehavior2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaReference_ClaimBehavior || (MediaReference_ClaimBehavior = {}));
function createBaseVideoDescription() {
  return { mediaQualityType: 0, videoPlaybackType: 0 };
}
var VideoDescription = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mediaQualityType !== 0) {
      writer.uint32(16).int32(message.mediaQualityType);
    }
    if (message.videoPlaybackType !== 0) {
      writer.uint32(8).int32(message.videoPlaybackType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVideoDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.mediaQualityType = reader.int32();
          continue;
        }
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.videoPlaybackType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return VideoDescription.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseVideoDescription();
    message.mediaQualityType = (_a = object.mediaQualityType) !== null && _a !== void 0 ? _a : 0;
    message.videoPlaybackType = (_b = object.videoPlaybackType) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseMediaReference() {
  return {
    mediaListId: "0",
    claimBehavior: 0,
    url: "",
    contentObject: new Uint8Array(0),
    localContentKey: "",
    localCacheKey: "",
    videoDescription: void 0,
    mediaType: 0
  };
}
var MediaReference = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mediaListId !== "0") {
      writer.uint32(48).int64(message.mediaListId);
    }
    if (message.claimBehavior !== 0) {
      writer.uint32(56).int32(message.claimBehavior);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.contentObject.length !== 0) {
      writer.uint32(26).bytes(message.contentObject);
    }
    if (message.localContentKey !== "") {
      writer.uint32(74).string(message.localContentKey);
    }
    if (message.localCacheKey !== "") {
      writer.uint32(82).string(message.localCacheKey);
    }
    if (message.videoDescription !== void 0) {
      VideoDescription.encode(message.videoDescription, writer.uint32(42).fork()).join();
    }
    if (message.mediaType !== 0) {
      writer.uint32(64).int32(message.mediaType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.mediaListId = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.claimBehavior = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.contentObject = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.localContentKey = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }
          message.localCacheKey = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.videoDescription = VideoDescription.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.mediaType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaReference.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseMediaReference();
    message.mediaListId = (_a = object.mediaListId) !== null && _a !== void 0 ? _a : "0";
    message.claimBehavior = (_b = object.claimBehavior) !== null && _b !== void 0 ? _b : 0;
    message.url = (_c = object.url) !== null && _c !== void 0 ? _c : "";
    message.contentObject = (_d = object.contentObject) !== null && _d !== void 0 ? _d : new Uint8Array(0);
    message.localContentKey = (_e = object.localContentKey) !== null && _e !== void 0 ? _e : "";
    message.localCacheKey = (_f = object.localCacheKey) !== null && _f !== void 0 ? _f : "";
    message.videoDescription = object.videoDescription !== void 0 && object.videoDescription !== null ? VideoDescription.fromPartial(object.videoDescription) : void 0;
    message.mediaType = (_g = object.mediaType) !== null && _g !== void 0 ? _g : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/snapdoc/capture_characteristics.js
function createBaseCaptureCharacteristics() {
  return { flashOn: false, frontFacing: false };
}
var CaptureCharacteristics = {
  encode(message, writer = new BinaryWriter()) {
    if (message.flashOn !== false) {
      writer.uint32(8).bool(message.flashOn);
    }
    if (message.frontFacing !== false) {
      writer.uint32(16).bool(message.frontFacing);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCaptureCharacteristics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.flashOn = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.frontFacing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return CaptureCharacteristics.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCaptureCharacteristics();
    message.flashOn = (_a = object.flashOn) !== null && _a !== void 0 ? _a : false;
    message.frontFacing = (_b = object.frontFacing) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/snapdoc/media_id.js
function createBaseMediaId() {
  return { mediaListId: "0" };
}
var MediaId = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mediaListId !== "0") {
      writer.uint32(8).int64(message.mediaListId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.mediaListId = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaId.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMediaId();
    message.mediaListId = (_a = object.mediaListId) !== null && _a !== void 0 ? _a : "0";
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/snapdoc/media.js
var MediaMetadata_Orientation;
(function(MediaMetadata_Orientation2) {
  MediaMetadata_Orientation2[MediaMetadata_Orientation2["VERTICAL"] = 0] = "VERTICAL";
  MediaMetadata_Orientation2[MediaMetadata_Orientation2["HORIZONTAL"] = 1] = "HORIZONTAL";
  MediaMetadata_Orientation2[MediaMetadata_Orientation2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaMetadata_Orientation || (MediaMetadata_Orientation = {}));
var MediaMetadata_DisplayOrientation;
(function(MediaMetadata_DisplayOrientation2) {
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["UNSET"] = 0] = "UNSET";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["UP"] = 1] = "UP";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["DOWN"] = 2] = "DOWN";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["LEFT"] = 3] = "LEFT";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["RIGHT"] = 4] = "RIGHT";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["UP_MIRRORED"] = 5] = "UP_MIRRORED";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["DOWN_MIRRORED"] = 6] = "DOWN_MIRRORED";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["LEFT_MIRRORED"] = 7] = "LEFT_MIRRORED";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["RIGHT_MIRRORED"] = 8] = "RIGHT_MIRRORED";
  MediaMetadata_DisplayOrientation2[MediaMetadata_DisplayOrientation2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaMetadata_DisplayOrientation || (MediaMetadata_DisplayOrientation = {}));
var MediaMetadata_MediaType;
(function(MediaMetadata_MediaType2) {
  MediaMetadata_MediaType2[MediaMetadata_MediaType2["IMAGE"] = 0] = "IMAGE";
  MediaMetadata_MediaType2[MediaMetadata_MediaType2["VIDEO"] = 1] = "VIDEO";
  MediaMetadata_MediaType2[MediaMetadata_MediaType2["GIF"] = 2] = "GIF";
  MediaMetadata_MediaType2[MediaMetadata_MediaType2["AUDIO"] = 3] = "AUDIO";
  MediaMetadata_MediaType2[MediaMetadata_MediaType2["UNKNOWN"] = 4] = "UNKNOWN";
  MediaMetadata_MediaType2[MediaMetadata_MediaType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaMetadata_MediaType || (MediaMetadata_MediaType = {}));
var MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType;
(function(MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2) {
  MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2[MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2["GCS"] = 0] = "GCS";
  MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2[MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2["S3"] = 1] = "S3";
  MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2[MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2["UNRECOGNIZED_VALUE"] = 2] = "UNRECOGNIZED_VALUE";
  MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2[MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType || (MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl_MediaUrlType = {}));
var MediaOriginExternalStorage_ExternalMediaSource;
(function(MediaOriginExternalStorage_ExternalMediaSource2) {
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["UNSET"] = 0] = "UNSET";
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["NONE"] = 1] = "NONE";
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["UNKNOWN"] = 2] = "UNKNOWN";
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["SNAPCHAT"] = 3] = "SNAPCHAT";
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["TIKTOK"] = 4] = "TIKTOK";
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["INSTAGRAM"] = 5] = "INSTAGRAM";
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["CAPCUT"] = 6] = "CAPCUT";
  MediaOriginExternalStorage_ExternalMediaSource2[MediaOriginExternalStorage_ExternalMediaSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaOriginExternalStorage_ExternalMediaSource || (MediaOriginExternalStorage_ExternalMediaSource = {}));
var DreamsMetadata_LensContentType;
(function(DreamsMetadata_LensContentType2) {
  DreamsMetadata_LensContentType2[DreamsMetadata_LensContentType2["UNSET"] = 0] = "UNSET";
  DreamsMetadata_LensContentType2[DreamsMetadata_LensContentType2["NONE"] = 1] = "NONE";
  DreamsMetadata_LensContentType2[DreamsMetadata_LensContentType2["GEN_ML"] = 2] = "GEN_ML";
  DreamsMetadata_LensContentType2[DreamsMetadata_LensContentType2["UCO"] = 3] = "UCO";
  DreamsMetadata_LensContentType2[DreamsMetadata_LensContentType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DreamsMetadata_LensContentType || (DreamsMetadata_LensContentType = {}));
function createBaseAudioMetadata() {
  return { codecFormat: 0 };
}
var AudioMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.codecFormat !== 0) {
      writer.uint32(8).int32(message.codecFormat);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAudioMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.codecFormat = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return AudioMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseAudioMetadata();
    message.codecFormat = (_a = object.codecFormat) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};
function createBaseImageMetadata() {
  return { codecFormat: 0 };
}
var ImageMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.codecFormat !== 0) {
      writer.uint32(8).int32(message.codecFormat);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseImageMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.codecFormat = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ImageMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseImageMetadata();
    message.codecFormat = (_a = object.codecFormat) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};
function createBaseVideoMetadata() {
  return { codecFormat: 0, containerFormat: 0 };
}
var VideoMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.codecFormat !== 0) {
      writer.uint32(8).int32(message.codecFormat);
    }
    if (message.containerFormat !== 0) {
      writer.uint32(16).int32(message.containerFormat);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseVideoMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.codecFormat = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.containerFormat = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return VideoMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseVideoMetadata();
    message.codecFormat = (_a = object.codecFormat) !== null && _a !== void 0 ? _a : 0;
    message.containerFormat = (_b = object.containerFormat) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseMediaMetadata() {
  return {
    orientation: 0,
    dimensions: void 0,
    mediaDurationMs: 0,
    mediaId: void 0,
    encryptionInfoV1: void 0,
    encryptionInfoV2: void 0,
    masterKeyEncryptedEncryptionInfo: void 0,
    assetType: 0,
    captureCharacteristics: void 0,
    mediaOriginCamera: void 0,
    mediaOriginExternalStorage: void 0,
    mediaOriginPixy: void 0,
    mediaOriginSpectacles: void 0,
    mediaOriginAi: void 0,
    dreamsMetadata: void 0,
    additionalOrigins: [],
    displayOrientation: 0,
    audio: void 0,
    image: void 0,
    video: void 0,
    type: 0,
    legacyMediaSource: void 0,
    contentDescriptor: void 0,
    mediaUrl: "",
    hasSound: false,
    zipped: false,
    frontFacing: false,
    mediaReference: void 0
  };
}
var MediaMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.orientation !== 0) {
      writer.uint32(24).int32(message.orientation);
    }
    if (message.dimensions !== void 0) {
      MediaMetadata_MediaDimensions.encode(message.dimensions, writer.uint32(42).fork()).join();
    }
    if (message.mediaDurationMs !== 0) {
      writer.uint32(120).uint32(message.mediaDurationMs);
    }
    if (message.mediaId !== void 0) {
      MediaId.encode(message.mediaId, writer.uint32(146).fork()).join();
    }
    if (message.encryptionInfoV1 !== void 0) {
      MediaMetadata_MediaEncryptionInfo.encode(message.encryptionInfoV1, writer.uint32(34).fork()).join();
    }
    if (message.encryptionInfoV2 !== void 0) {
      MediaMetadata_MediaEncryptionInfo.encode(message.encryptionInfoV2, writer.uint32(154).fork()).join();
    }
    if (message.masterKeyEncryptedEncryptionInfo !== void 0) {
      MediaMetadata_MediaEncryptionInfo.encode(message.masterKeyEncryptedEncryptionInfo, writer.uint32(250).fork()).join();
    }
    if (message.assetType !== 0) {
      writer.uint32(160).int32(message.assetType);
    }
    if (message.captureCharacteristics !== void 0) {
      CaptureCharacteristics.encode(message.captureCharacteristics, writer.uint32(170).fork()).join();
    }
    if (message.mediaOriginCamera !== void 0) {
      MediaOriginCamera.encode(message.mediaOriginCamera, writer.uint32(210).fork()).join();
    }
    if (message.mediaOriginExternalStorage !== void 0) {
      MediaOriginExternalStorage.encode(message.mediaOriginExternalStorage, writer.uint32(218).fork()).join();
    }
    if (message.mediaOriginPixy !== void 0) {
      MediaOriginPixy.encode(message.mediaOriginPixy, writer.uint32(226).fork()).join();
    }
    if (message.mediaOriginSpectacles !== void 0) {
      MediaOriginSpectacles.encode(message.mediaOriginSpectacles, writer.uint32(234).fork()).join();
    }
    if (message.mediaOriginAi !== void 0) {
      MediaOriginAI.encode(message.mediaOriginAi, writer.uint32(242).fork()).join();
    }
    if (message.dreamsMetadata !== void 0) {
      DreamsMetadata.encode(message.dreamsMetadata, writer.uint32(258).fork()).join();
    }
    for (const v2 of message.additionalOrigins) {
      MediaOrigin.encode(v2, writer.uint32(266).fork()).join();
    }
    if (message.displayOrientation !== 0) {
      writer.uint32(176).int32(message.displayOrientation);
    }
    if (message.audio !== void 0) {
      AudioMetadata.encode(message.audio, writer.uint32(186).fork()).join();
    }
    if (message.image !== void 0) {
      ImageMetadata.encode(message.image, writer.uint32(194).fork()).join();
    }
    if (message.video !== void 0) {
      VideoMetadata.encode(message.video, writer.uint32(202).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.legacyMediaSource !== void 0) {
      MediaMetadata_LegacyMediaSource.encode(message.legacyMediaSource, writer.uint32(50).fork()).join();
    }
    if (message.contentDescriptor !== void 0) {
      writer.uint32(58).bytes(message.contentDescriptor);
    }
    if (message.mediaUrl !== "") {
      writer.uint32(74).string(message.mediaUrl);
    }
    if (message.hasSound !== false) {
      writer.uint32(96).bool(message.hasSound);
    }
    if (message.zipped !== false) {
      writer.uint32(104).bool(message.zipped);
    }
    if (message.frontFacing !== false) {
      writer.uint32(112).bool(message.frontFacing);
    }
    if (message.mediaReference !== void 0) {
      MediaReference.encode(message.mediaReference, writer.uint32(138).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.orientation = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.dimensions = MediaMetadata_MediaDimensions.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }
          message.mediaDurationMs = reader.uint32();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.mediaId = MediaId.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.encryptionInfoV1 = MediaMetadata_MediaEncryptionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }
          message.encryptionInfoV2 = MediaMetadata_MediaEncryptionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }
          message.masterKeyEncryptedEncryptionInfo = MediaMetadata_MediaEncryptionInfo.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }
          message.assetType = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }
          message.captureCharacteristics = CaptureCharacteristics.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }
          message.mediaOriginCamera = MediaOriginCamera.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }
          message.mediaOriginExternalStorage = MediaOriginExternalStorage.decode(reader, reader.uint32());
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }
          message.mediaOriginPixy = MediaOriginPixy.decode(reader, reader.uint32());
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }
          message.mediaOriginSpectacles = MediaOriginSpectacles.decode(reader, reader.uint32());
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }
          message.mediaOriginAi = MediaOriginAI.decode(reader, reader.uint32());
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }
          message.dreamsMetadata = DreamsMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }
          message.additionalOrigins.push(MediaOrigin.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }
          message.displayOrientation = reader.int32();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }
          message.audio = AudioMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }
          message.image = ImageMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }
          message.video = VideoMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.legacyMediaSource = MediaMetadata_LegacyMediaSource.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.contentDescriptor = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.mediaUrl = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }
          message.hasSound = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.zipped = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }
          message.frontFacing = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.mediaReference = MediaReference.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const message = createBaseMediaMetadata();
    message.orientation = (_a = object.orientation) !== null && _a !== void 0 ? _a : 0;
    message.dimensions = object.dimensions !== void 0 && object.dimensions !== null ? MediaMetadata_MediaDimensions.fromPartial(object.dimensions) : void 0;
    message.mediaDurationMs = (_b = object.mediaDurationMs) !== null && _b !== void 0 ? _b : 0;
    message.mediaId = object.mediaId !== void 0 && object.mediaId !== null ? MediaId.fromPartial(object.mediaId) : void 0;
    message.encryptionInfoV1 = object.encryptionInfoV1 !== void 0 && object.encryptionInfoV1 !== null ? MediaMetadata_MediaEncryptionInfo.fromPartial(object.encryptionInfoV1) : void 0;
    message.encryptionInfoV2 = object.encryptionInfoV2 !== void 0 && object.encryptionInfoV2 !== null ? MediaMetadata_MediaEncryptionInfo.fromPartial(object.encryptionInfoV2) : void 0;
    message.masterKeyEncryptedEncryptionInfo = object.masterKeyEncryptedEncryptionInfo !== void 0 && object.masterKeyEncryptedEncryptionInfo !== null ? MediaMetadata_MediaEncryptionInfo.fromPartial(object.masterKeyEncryptedEncryptionInfo) : void 0;
    message.assetType = (_c = object.assetType) !== null && _c !== void 0 ? _c : 0;
    message.captureCharacteristics = object.captureCharacteristics !== void 0 && object.captureCharacteristics !== null ? CaptureCharacteristics.fromPartial(object.captureCharacteristics) : void 0;
    message.mediaOriginCamera = object.mediaOriginCamera !== void 0 && object.mediaOriginCamera !== null ? MediaOriginCamera.fromPartial(object.mediaOriginCamera) : void 0;
    message.mediaOriginExternalStorage = object.mediaOriginExternalStorage !== void 0 && object.mediaOriginExternalStorage !== null ? MediaOriginExternalStorage.fromPartial(object.mediaOriginExternalStorage) : void 0;
    message.mediaOriginPixy = object.mediaOriginPixy !== void 0 && object.mediaOriginPixy !== null ? MediaOriginPixy.fromPartial(object.mediaOriginPixy) : void 0;
    message.mediaOriginSpectacles = object.mediaOriginSpectacles !== void 0 && object.mediaOriginSpectacles !== null ? MediaOriginSpectacles.fromPartial(object.mediaOriginSpectacles) : void 0;
    message.mediaOriginAi = object.mediaOriginAi !== void 0 && object.mediaOriginAi !== null ? MediaOriginAI.fromPartial(object.mediaOriginAi) : void 0;
    message.dreamsMetadata = object.dreamsMetadata !== void 0 && object.dreamsMetadata !== null ? DreamsMetadata.fromPartial(object.dreamsMetadata) : void 0;
    message.additionalOrigins = ((_d = object.additionalOrigins) === null || _d === void 0 ? void 0 : _d.map((e2) => MediaOrigin.fromPartial(e2))) || [];
    message.displayOrientation = (_e = object.displayOrientation) !== null && _e !== void 0 ? _e : 0;
    message.audio = object.audio !== void 0 && object.audio !== null ? AudioMetadata.fromPartial(object.audio) : void 0;
    message.image = object.image !== void 0 && object.image !== null ? ImageMetadata.fromPartial(object.image) : void 0;
    message.video = object.video !== void 0 && object.video !== null ? VideoMetadata.fromPartial(object.video) : void 0;
    message.type = (_f = object.type) !== null && _f !== void 0 ? _f : 0;
    message.legacyMediaSource = object.legacyMediaSource !== void 0 && object.legacyMediaSource !== null ? MediaMetadata_LegacyMediaSource.fromPartial(object.legacyMediaSource) : void 0;
    message.contentDescriptor = (_g = object.contentDescriptor) !== null && _g !== void 0 ? _g : void 0;
    message.mediaUrl = (_h = object.mediaUrl) !== null && _h !== void 0 ? _h : "";
    message.hasSound = (_j = object.hasSound) !== null && _j !== void 0 ? _j : false;
    message.zipped = (_k = object.zipped) !== null && _k !== void 0 ? _k : false;
    message.frontFacing = (_l = object.frontFacing) !== null && _l !== void 0 ? _l : false;
    message.mediaReference = object.mediaReference !== void 0 && object.mediaReference !== null ? MediaReference.fromPartial(object.mediaReference) : void 0;
    return message;
  }
};
function createBaseMediaMetadata_MediaDimensions() {
  return { width: 0, height: 0 };
}
var MediaMetadata_MediaDimensions = {
  encode(message, writer = new BinaryWriter()) {
    if (message.width !== 0) {
      writer.uint32(8).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(16).uint32(message.height);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaMetadata_MediaDimensions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.width = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.height = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaMetadata_MediaDimensions.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMediaMetadata_MediaDimensions();
    message.width = (_a = object.width) !== null && _a !== void 0 ? _a : 0;
    message.height = (_b = object.height) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseMediaMetadata_MediaEncryptionInfo() {
  return { key: new Uint8Array(0), iv: new Uint8Array(0) };
}
var MediaMetadata_MediaEncryptionInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    if (message.iv.length !== 0) {
      writer.uint32(18).bytes(message.iv);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaMetadata_MediaEncryptionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.iv = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaMetadata_MediaEncryptionInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMediaMetadata_MediaEncryptionInfo();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array(0);
    message.iv = (_b = object.iv) !== null && _b !== void 0 ? _b : new Uint8Array(0);
    return message;
  }
};
function createBaseMediaMetadata_LegacyMediaSource() {
  return { sourceMediaId: "", directDownloadUrl: void 0 };
}
var MediaMetadata_LegacyMediaSource = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sourceMediaId !== "") {
      writer.uint32(10).string(message.sourceMediaId);
    }
    if (message.directDownloadUrl !== void 0) {
      MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl.encode(message.directDownloadUrl, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaMetadata_LegacyMediaSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.sourceMediaId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.directDownloadUrl = MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaMetadata_LegacyMediaSource.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseMediaMetadata_LegacyMediaSource();
    message.sourceMediaId = (_a = object.sourceMediaId) !== null && _a !== void 0 ? _a : "";
    message.directDownloadUrl = object.directDownloadUrl !== void 0 && object.directDownloadUrl !== null ? MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl.fromPartial(object.directDownloadUrl) : void 0;
    return message;
  }
};
function createBaseMediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl() {
  return { url: "", expirySeconds: "0", type: 0, region: "" };
}
var MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl = {
  encode(message, writer = new BinaryWriter()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    if (message.expirySeconds !== "0") {
      writer.uint32(16).uint64(message.expirySeconds);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.region !== "") {
      writer.uint32(34).string(message.region);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.expirySeconds = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.type = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.region = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseMediaMetadata_LegacyMediaSource_LegacyDirectDownloadUrl();
    message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
    message.expirySeconds = (_b = object.expirySeconds) !== null && _b !== void 0 ? _b : "0";
    message.type = (_c = object.type) !== null && _c !== void 0 ? _c : 0;
    message.region = (_d = object.region) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseMediaOrigin() {
  return {
    mediaOriginCamera: void 0,
    mediaOriginExternalStorage: void 0,
    mediaOriginPixy: void 0,
    mediaOriginSpectacles: void 0,
    mediaOriginAi: void 0,
    dreamsMetadata: void 0
  };
}
var MediaOrigin = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mediaOriginCamera !== void 0) {
      MediaOriginCamera.encode(message.mediaOriginCamera, writer.uint32(10).fork()).join();
    }
    if (message.mediaOriginExternalStorage !== void 0) {
      MediaOriginExternalStorage.encode(message.mediaOriginExternalStorage, writer.uint32(18).fork()).join();
    }
    if (message.mediaOriginPixy !== void 0) {
      MediaOriginPixy.encode(message.mediaOriginPixy, writer.uint32(26).fork()).join();
    }
    if (message.mediaOriginSpectacles !== void 0) {
      MediaOriginSpectacles.encode(message.mediaOriginSpectacles, writer.uint32(34).fork()).join();
    }
    if (message.mediaOriginAi !== void 0) {
      MediaOriginAI.encode(message.mediaOriginAi, writer.uint32(42).fork()).join();
    }
    if (message.dreamsMetadata !== void 0) {
      DreamsMetadata.encode(message.dreamsMetadata, writer.uint32(50).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaOrigin();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.mediaOriginCamera = MediaOriginCamera.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.mediaOriginExternalStorage = MediaOriginExternalStorage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.mediaOriginPixy = MediaOriginPixy.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.mediaOriginSpectacles = MediaOriginSpectacles.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.mediaOriginAi = MediaOriginAI.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.dreamsMetadata = DreamsMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaOrigin.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseMediaOrigin();
    message.mediaOriginCamera = object.mediaOriginCamera !== void 0 && object.mediaOriginCamera !== null ? MediaOriginCamera.fromPartial(object.mediaOriginCamera) : void 0;
    message.mediaOriginExternalStorage = object.mediaOriginExternalStorage !== void 0 && object.mediaOriginExternalStorage !== null ? MediaOriginExternalStorage.fromPartial(object.mediaOriginExternalStorage) : void 0;
    message.mediaOriginPixy = object.mediaOriginPixy !== void 0 && object.mediaOriginPixy !== null ? MediaOriginPixy.fromPartial(object.mediaOriginPixy) : void 0;
    message.mediaOriginSpectacles = object.mediaOriginSpectacles !== void 0 && object.mediaOriginSpectacles !== null ? MediaOriginSpectacles.fromPartial(object.mediaOriginSpectacles) : void 0;
    message.mediaOriginAi = object.mediaOriginAi !== void 0 && object.mediaOriginAi !== null ? MediaOriginAI.fromPartial(object.mediaOriginAi) : void 0;
    message.dreamsMetadata = object.dreamsMetadata !== void 0 && object.dreamsMetadata !== null ? DreamsMetadata.fromPartial(object.dreamsMetadata) : void 0;
    return message;
  }
};
function createBaseMediaOriginCamera() {
  return {};
}
var MediaOriginCamera = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaOriginCamera();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaOriginCamera.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseMediaOriginCamera();
    return message;
  }
};
function createBaseMediaOriginPixy() {
  return {};
}
var MediaOriginPixy = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaOriginPixy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaOriginPixy.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseMediaOriginPixy();
    return message;
  }
};
function createBaseMediaOriginSpectacles() {
  return {};
}
var MediaOriginSpectacles = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaOriginSpectacles();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaOriginSpectacles.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseMediaOriginSpectacles();
    return message;
  }
};
function createBaseMediaOriginExternalStorage() {
  return { creationTimestamp: "0", mediaSource: 0, insecureFileMetadata: void 0, originalLocalIds: [] };
}
var MediaOriginExternalStorage = {
  encode(message, writer = new BinaryWriter()) {
    if (message.creationTimestamp !== "0") {
      writer.uint32(8).uint64(message.creationTimestamp);
    }
    if (message.mediaSource !== 0) {
      writer.uint32(16).int32(message.mediaSource);
    }
    if (message.insecureFileMetadata !== void 0) {
      InsecureFileMetadata.encode(message.insecureFileMetadata, writer.uint32(42).fork()).join();
    }
    for (const v2 of message.originalLocalIds) {
      writer.uint32(50).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaOriginExternalStorage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.creationTimestamp = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.mediaSource = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.insecureFileMetadata = InsecureFileMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.originalLocalIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaOriginExternalStorage.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseMediaOriginExternalStorage();
    message.creationTimestamp = (_a = object.creationTimestamp) !== null && _a !== void 0 ? _a : "0";
    message.mediaSource = (_b = object.mediaSource) !== null && _b !== void 0 ? _b : 0;
    message.insecureFileMetadata = object.insecureFileMetadata !== void 0 && object.insecureFileMetadata !== null ? InsecureFileMetadata.fromPartial(object.insecureFileMetadata) : void 0;
    message.originalLocalIds = ((_c = object.originalLocalIds) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseInsecureFileMetadata() {
  return { lensId: [], musicTrackId: "0" };
}
var InsecureFileMetadata = {
  encode(message, writer = new BinaryWriter()) {
    writer.uint32(10).fork();
    for (const v2 of message.lensId) {
      writer.uint64(v2);
    }
    writer.join();
    if (message.musicTrackId !== "0") {
      writer.uint32(16).uint64(message.musicTrackId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseInsecureFileMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.lensId.push(reader.uint64().toString());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.lensId.push(reader.uint64().toString());
            }
            continue;
          }
          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.musicTrackId = reader.uint64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return InsecureFileMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseInsecureFileMetadata();
    message.lensId = ((_a = object.lensId) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.musicTrackId = (_b = object.musicTrackId) !== null && _b !== void 0 ? _b : "0";
    return message;
  }
};
function createBaseMediaOriginAI() {
  return {};
}
var MediaOriginAI = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaOriginAI();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaOriginAI.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseMediaOriginAI();
    return message;
  }
};
function createBaseDreamsMetadata() {
  return { packId: "", templateId: "", contentType: [] };
}
var DreamsMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.packId !== "") {
      writer.uint32(10).string(message.packId);
    }
    if (message.templateId !== "") {
      writer.uint32(18).string(message.templateId);
    }
    writer.uint32(26).fork();
    for (const v2 of message.contentType) {
      writer.int32(v2);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDreamsMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.packId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.templateId = reader.string();
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.contentType.push(reader.int32());
            continue;
          }
          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.contentType.push(reader.int32());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return DreamsMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseDreamsMetadata();
    message.packId = (_a = object.packId) !== null && _a !== void 0 ? _a : "";
    message.templateId = (_b = object.templateId) !== null && _b !== void 0 ? _b : "";
    message.contentType = ((_c = object.contentType) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/billboard_provided_signals.js
function createBaseBillboardSignals() {
  return {
    emailVerified: false,
    phoneVerified: false,
    notificationPermGranted: false,
    contactPermGranted: false,
    mutualFriendsCount: 0,
    groupsCount: 0,
    hasNonTeamSnapchatConversations: false,
    emailSet: false,
    bitmojiSet: false,
    hasAddFriendsRequest: false,
    appLaunchFromPush: false,
    appLaunchType: 0,
    campaignLocalImpressionCount: 0,
    campaignLocalLastImpressionTimeSecsToNow: "0",
    campaignLocalContinuousDismissCount: 0,
    fstNumInAppWarnings: 0,
    fstShouldChangePassword: false,
    audioRecordPermGranted: false,
    mutualFriendsWithBirthdayCount: 0,
    campaignLocalDismissCount: 0,
    memoriesCount: 0,
    campaignLocalFirstImpressionTimeSecsToNow: "0",
    campaignLocalClickCount: 0,
    campaignLocalInteractionCount: 0,
    campaignLocalLastInteractionTimeSecsToNow: "0",
    lockScreenWidgetAppOpenFromPush: false,
    communityCount: 0,
    campaignLocalFirstClickTimeSecsToNow: "0",
    campaignLocalLastClickTimeSecsToNow: "0",
    campaignLocalFirstDismissTimeSecsToNow: "0",
    campaignLocalLastDismissTimeSecsToNow: "0",
    campaignLocalFirstInteractionTimeSecsToNow: "0",
    serverImpressionCount: 0,
    serverClickCount: 0,
    serverDismissCount: 0,
    serverInteractionCount: 0,
    serverFirstImpressionTimeSecsToNow: "0",
    serverLastImpressionTimeSecsToNow: "0",
    serverFirstClickTimeSecsToNow: "0",
    serverLastClickTimeSecsToNow: "0",
    serverFirstDismissTimeSecsToNow: "0",
    serverLastDismissTimeSecsToNow: "0",
    serverFirstInteractionTimeSecsToNow: "0",
    serverLastInteractionTimeSecsToNow: "0",
    serverContinuousDismissCount: 0,
    contactPermOsGranted: false,
    contactPermUserGranted: false,
    contactPermOsAuthorizationStatus: 0
  };
}
var BillboardSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.emailVerified !== false) {
      writer.uint32(8).bool(message.emailVerified);
    }
    if (message.phoneVerified !== false) {
      writer.uint32(16).bool(message.phoneVerified);
    }
    if (message.notificationPermGranted !== false) {
      writer.uint32(24).bool(message.notificationPermGranted);
    }
    if (message.contactPermGranted !== false) {
      writer.uint32(32).bool(message.contactPermGranted);
    }
    if (message.mutualFriendsCount !== 0) {
      writer.uint32(40).int32(message.mutualFriendsCount);
    }
    if (message.groupsCount !== 0) {
      writer.uint32(48).int32(message.groupsCount);
    }
    if (message.hasNonTeamSnapchatConversations !== false) {
      writer.uint32(56).bool(message.hasNonTeamSnapchatConversations);
    }
    if (message.emailSet !== false) {
      writer.uint32(64).bool(message.emailSet);
    }
    if (message.bitmojiSet !== false) {
      writer.uint32(72).bool(message.bitmojiSet);
    }
    if (message.hasAddFriendsRequest !== false) {
      writer.uint32(80).bool(message.hasAddFriendsRequest);
    }
    if (message.appLaunchFromPush !== false) {
      writer.uint32(88).bool(message.appLaunchFromPush);
    }
    if (message.appLaunchType !== 0) {
      writer.uint32(96).int32(message.appLaunchType);
    }
    if (message.campaignLocalImpressionCount !== 0) {
      writer.uint32(104).int32(message.campaignLocalImpressionCount);
    }
    if (message.campaignLocalLastImpressionTimeSecsToNow !== "0") {
      writer.uint32(112).int64(message.campaignLocalLastImpressionTimeSecsToNow);
    }
    if (message.campaignLocalContinuousDismissCount !== 0) {
      writer.uint32(120).int32(message.campaignLocalContinuousDismissCount);
    }
    if (message.fstNumInAppWarnings !== 0) {
      writer.uint32(128).int32(message.fstNumInAppWarnings);
    }
    if (message.fstShouldChangePassword !== false) {
      writer.uint32(136).bool(message.fstShouldChangePassword);
    }
    if (message.audioRecordPermGranted !== false) {
      writer.uint32(144).bool(message.audioRecordPermGranted);
    }
    if (message.mutualFriendsWithBirthdayCount !== 0) {
      writer.uint32(152).int32(message.mutualFriendsWithBirthdayCount);
    }
    if (message.campaignLocalDismissCount !== 0) {
      writer.uint32(160).int32(message.campaignLocalDismissCount);
    }
    if (message.memoriesCount !== 0) {
      writer.uint32(168).int32(message.memoriesCount);
    }
    if (message.campaignLocalFirstImpressionTimeSecsToNow !== "0") {
      writer.uint32(176).int64(message.campaignLocalFirstImpressionTimeSecsToNow);
    }
    if (message.campaignLocalClickCount !== 0) {
      writer.uint32(184).int32(message.campaignLocalClickCount);
    }
    if (message.campaignLocalInteractionCount !== 0) {
      writer.uint32(192).int32(message.campaignLocalInteractionCount);
    }
    if (message.campaignLocalLastInteractionTimeSecsToNow !== "0") {
      writer.uint32(200).int64(message.campaignLocalLastInteractionTimeSecsToNow);
    }
    if (message.lockScreenWidgetAppOpenFromPush !== false) {
      writer.uint32(208).bool(message.lockScreenWidgetAppOpenFromPush);
    }
    if (message.communityCount !== 0) {
      writer.uint32(216).int32(message.communityCount);
    }
    if (message.campaignLocalFirstClickTimeSecsToNow !== "0") {
      writer.uint32(224).int64(message.campaignLocalFirstClickTimeSecsToNow);
    }
    if (message.campaignLocalLastClickTimeSecsToNow !== "0") {
      writer.uint32(232).int64(message.campaignLocalLastClickTimeSecsToNow);
    }
    if (message.campaignLocalFirstDismissTimeSecsToNow !== "0") {
      writer.uint32(240).int64(message.campaignLocalFirstDismissTimeSecsToNow);
    }
    if (message.campaignLocalLastDismissTimeSecsToNow !== "0") {
      writer.uint32(248).int64(message.campaignLocalLastDismissTimeSecsToNow);
    }
    if (message.campaignLocalFirstInteractionTimeSecsToNow !== "0") {
      writer.uint32(256).int64(message.campaignLocalFirstInteractionTimeSecsToNow);
    }
    if (message.serverImpressionCount !== 0) {
      writer.uint32(264).int32(message.serverImpressionCount);
    }
    if (message.serverClickCount !== 0) {
      writer.uint32(272).int32(message.serverClickCount);
    }
    if (message.serverDismissCount !== 0) {
      writer.uint32(280).int32(message.serverDismissCount);
    }
    if (message.serverInteractionCount !== 0) {
      writer.uint32(288).int32(message.serverInteractionCount);
    }
    if (message.serverFirstImpressionTimeSecsToNow !== "0") {
      writer.uint32(296).int64(message.serverFirstImpressionTimeSecsToNow);
    }
    if (message.serverLastImpressionTimeSecsToNow !== "0") {
      writer.uint32(304).int64(message.serverLastImpressionTimeSecsToNow);
    }
    if (message.serverFirstClickTimeSecsToNow !== "0") {
      writer.uint32(312).int64(message.serverFirstClickTimeSecsToNow);
    }
    if (message.serverLastClickTimeSecsToNow !== "0") {
      writer.uint32(320).int64(message.serverLastClickTimeSecsToNow);
    }
    if (message.serverFirstDismissTimeSecsToNow !== "0") {
      writer.uint32(328).int64(message.serverFirstDismissTimeSecsToNow);
    }
    if (message.serverLastDismissTimeSecsToNow !== "0") {
      writer.uint32(336).int64(message.serverLastDismissTimeSecsToNow);
    }
    if (message.serverFirstInteractionTimeSecsToNow !== "0") {
      writer.uint32(344).int64(message.serverFirstInteractionTimeSecsToNow);
    }
    if (message.serverLastInteractionTimeSecsToNow !== "0") {
      writer.uint32(352).int64(message.serverLastInteractionTimeSecsToNow);
    }
    if (message.serverContinuousDismissCount !== 0) {
      writer.uint32(360).int32(message.serverContinuousDismissCount);
    }
    if (message.contactPermOsGranted !== false) {
      writer.uint32(368).bool(message.contactPermOsGranted);
    }
    if (message.contactPermUserGranted !== false) {
      writer.uint32(376).bool(message.contactPermUserGranted);
    }
    if (message.contactPermOsAuthorizationStatus !== 0) {
      writer.uint32(384).int32(message.contactPermOsAuthorizationStatus);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBillboardSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.emailVerified = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.phoneVerified = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.notificationPermGranted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.contactPermGranted = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.mutualFriendsCount = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.groupsCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.hasNonTeamSnapchatConversations = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.emailSet = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.bitmojiSet = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.hasAddFriendsRequest = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.appLaunchFromPush = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }
          message.appLaunchType = reader.int32();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.campaignLocalImpressionCount = reader.int32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }
          message.campaignLocalLastImpressionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }
          message.campaignLocalContinuousDismissCount = reader.int32();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }
          message.fstNumInAppWarnings = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }
          message.fstShouldChangePassword = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }
          message.audioRecordPermGranted = reader.bool();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }
          message.mutualFriendsWithBirthdayCount = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 160) {
            break;
          }
          message.campaignLocalDismissCount = reader.int32();
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }
          message.memoriesCount = reader.int32();
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }
          message.campaignLocalFirstImpressionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }
          message.campaignLocalClickCount = reader.int32();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }
          message.campaignLocalInteractionCount = reader.int32();
          continue;
        }
        case 25: {
          if (tag !== 200) {
            break;
          }
          message.campaignLocalLastInteractionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 26: {
          if (tag !== 208) {
            break;
          }
          message.lockScreenWidgetAppOpenFromPush = reader.bool();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }
          message.communityCount = reader.int32();
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }
          message.campaignLocalFirstClickTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }
          message.campaignLocalLastClickTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }
          message.campaignLocalFirstDismissTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }
          message.campaignLocalLastDismissTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 32: {
          if (tag !== 256) {
            break;
          }
          message.campaignLocalFirstInteractionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 33: {
          if (tag !== 264) {
            break;
          }
          message.serverImpressionCount = reader.int32();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }
          message.serverClickCount = reader.int32();
          continue;
        }
        case 35: {
          if (tag !== 280) {
            break;
          }
          message.serverDismissCount = reader.int32();
          continue;
        }
        case 36: {
          if (tag !== 288) {
            break;
          }
          message.serverInteractionCount = reader.int32();
          continue;
        }
        case 37: {
          if (tag !== 296) {
            break;
          }
          message.serverFirstImpressionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 38: {
          if (tag !== 304) {
            break;
          }
          message.serverLastImpressionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 39: {
          if (tag !== 312) {
            break;
          }
          message.serverFirstClickTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 40: {
          if (tag !== 320) {
            break;
          }
          message.serverLastClickTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 41: {
          if (tag !== 328) {
            break;
          }
          message.serverFirstDismissTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 42: {
          if (tag !== 336) {
            break;
          }
          message.serverLastDismissTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 43: {
          if (tag !== 344) {
            break;
          }
          message.serverFirstInteractionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 44: {
          if (tag !== 352) {
            break;
          }
          message.serverLastInteractionTimeSecsToNow = reader.int64().toString();
          continue;
        }
        case 45: {
          if (tag !== 360) {
            break;
          }
          message.serverContinuousDismissCount = reader.int32();
          continue;
        }
        case 46: {
          if (tag !== 368) {
            break;
          }
          message.contactPermOsGranted = reader.bool();
          continue;
        }
        case 47: {
          if (tag !== 376) {
            break;
          }
          message.contactPermUserGranted = reader.bool();
          continue;
        }
        case 48: {
          if (tag !== 384) {
            break;
          }
          message.contactPermOsAuthorizationStatus = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BillboardSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23;
    const message = createBaseBillboardSignals();
    message.emailVerified = (_a = object.emailVerified) !== null && _a !== void 0 ? _a : false;
    message.phoneVerified = (_b = object.phoneVerified) !== null && _b !== void 0 ? _b : false;
    message.notificationPermGranted = (_c = object.notificationPermGranted) !== null && _c !== void 0 ? _c : false;
    message.contactPermGranted = (_d = object.contactPermGranted) !== null && _d !== void 0 ? _d : false;
    message.mutualFriendsCount = (_e = object.mutualFriendsCount) !== null && _e !== void 0 ? _e : 0;
    message.groupsCount = (_f = object.groupsCount) !== null && _f !== void 0 ? _f : 0;
    message.hasNonTeamSnapchatConversations = (_g = object.hasNonTeamSnapchatConversations) !== null && _g !== void 0 ? _g : false;
    message.emailSet = (_h = object.emailSet) !== null && _h !== void 0 ? _h : false;
    message.bitmojiSet = (_j = object.bitmojiSet) !== null && _j !== void 0 ? _j : false;
    message.hasAddFriendsRequest = (_k = object.hasAddFriendsRequest) !== null && _k !== void 0 ? _k : false;
    message.appLaunchFromPush = (_l = object.appLaunchFromPush) !== null && _l !== void 0 ? _l : false;
    message.appLaunchType = (_m = object.appLaunchType) !== null && _m !== void 0 ? _m : 0;
    message.campaignLocalImpressionCount = (_o = object.campaignLocalImpressionCount) !== null && _o !== void 0 ? _o : 0;
    message.campaignLocalLastImpressionTimeSecsToNow = (_p = object.campaignLocalLastImpressionTimeSecsToNow) !== null && _p !== void 0 ? _p : "0";
    message.campaignLocalContinuousDismissCount = (_q = object.campaignLocalContinuousDismissCount) !== null && _q !== void 0 ? _q : 0;
    message.fstNumInAppWarnings = (_r = object.fstNumInAppWarnings) !== null && _r !== void 0 ? _r : 0;
    message.fstShouldChangePassword = (_s = object.fstShouldChangePassword) !== null && _s !== void 0 ? _s : false;
    message.audioRecordPermGranted = (_t = object.audioRecordPermGranted) !== null && _t !== void 0 ? _t : false;
    message.mutualFriendsWithBirthdayCount = (_u = object.mutualFriendsWithBirthdayCount) !== null && _u !== void 0 ? _u : 0;
    message.campaignLocalDismissCount = (_v = object.campaignLocalDismissCount) !== null && _v !== void 0 ? _v : 0;
    message.memoriesCount = (_w = object.memoriesCount) !== null && _w !== void 0 ? _w : 0;
    message.campaignLocalFirstImpressionTimeSecsToNow = (_x = object.campaignLocalFirstImpressionTimeSecsToNow) !== null && _x !== void 0 ? _x : "0";
    message.campaignLocalClickCount = (_y = object.campaignLocalClickCount) !== null && _y !== void 0 ? _y : 0;
    message.campaignLocalInteractionCount = (_z = object.campaignLocalInteractionCount) !== null && _z !== void 0 ? _z : 0;
    message.campaignLocalLastInteractionTimeSecsToNow = (_0 = object.campaignLocalLastInteractionTimeSecsToNow) !== null && _0 !== void 0 ? _0 : "0";
    message.lockScreenWidgetAppOpenFromPush = (_1 = object.lockScreenWidgetAppOpenFromPush) !== null && _1 !== void 0 ? _1 : false;
    message.communityCount = (_2 = object.communityCount) !== null && _2 !== void 0 ? _2 : 0;
    message.campaignLocalFirstClickTimeSecsToNow = (_3 = object.campaignLocalFirstClickTimeSecsToNow) !== null && _3 !== void 0 ? _3 : "0";
    message.campaignLocalLastClickTimeSecsToNow = (_4 = object.campaignLocalLastClickTimeSecsToNow) !== null && _4 !== void 0 ? _4 : "0";
    message.campaignLocalFirstDismissTimeSecsToNow = (_5 = object.campaignLocalFirstDismissTimeSecsToNow) !== null && _5 !== void 0 ? _5 : "0";
    message.campaignLocalLastDismissTimeSecsToNow = (_6 = object.campaignLocalLastDismissTimeSecsToNow) !== null && _6 !== void 0 ? _6 : "0";
    message.campaignLocalFirstInteractionTimeSecsToNow = (_7 = object.campaignLocalFirstInteractionTimeSecsToNow) !== null && _7 !== void 0 ? _7 : "0";
    message.serverImpressionCount = (_8 = object.serverImpressionCount) !== null && _8 !== void 0 ? _8 : 0;
    message.serverClickCount = (_9 = object.serverClickCount) !== null && _9 !== void 0 ? _9 : 0;
    message.serverDismissCount = (_10 = object.serverDismissCount) !== null && _10 !== void 0 ? _10 : 0;
    message.serverInteractionCount = (_11 = object.serverInteractionCount) !== null && _11 !== void 0 ? _11 : 0;
    message.serverFirstImpressionTimeSecsToNow = (_12 = object.serverFirstImpressionTimeSecsToNow) !== null && _12 !== void 0 ? _12 : "0";
    message.serverLastImpressionTimeSecsToNow = (_13 = object.serverLastImpressionTimeSecsToNow) !== null && _13 !== void 0 ? _13 : "0";
    message.serverFirstClickTimeSecsToNow = (_14 = object.serverFirstClickTimeSecsToNow) !== null && _14 !== void 0 ? _14 : "0";
    message.serverLastClickTimeSecsToNow = (_15 = object.serverLastClickTimeSecsToNow) !== null && _15 !== void 0 ? _15 : "0";
    message.serverFirstDismissTimeSecsToNow = (_16 = object.serverFirstDismissTimeSecsToNow) !== null && _16 !== void 0 ? _16 : "0";
    message.serverLastDismissTimeSecsToNow = (_17 = object.serverLastDismissTimeSecsToNow) !== null && _17 !== void 0 ? _17 : "0";
    message.serverFirstInteractionTimeSecsToNow = (_18 = object.serverFirstInteractionTimeSecsToNow) !== null && _18 !== void 0 ? _18 : "0";
    message.serverLastInteractionTimeSecsToNow = (_19 = object.serverLastInteractionTimeSecsToNow) !== null && _19 !== void 0 ? _19 : "0";
    message.serverContinuousDismissCount = (_20 = object.serverContinuousDismissCount) !== null && _20 !== void 0 ? _20 : 0;
    message.contactPermOsGranted = (_21 = object.contactPermOsGranted) !== null && _21 !== void 0 ? _21 : false;
    message.contactPermUserGranted = (_22 = object.contactPermUserGranted) !== null && _22 !== void 0 ? _22 : false;
    message.contactPermOsAuthorizationStatus = (_23 = object.contactPermOsAuthorizationStatus) !== null && _23 !== void 0 ? _23 : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/bolt_provided_signals.js
function createBaseBoltSignals() {
  return { boltUseCase: 0, boltCdnExperimentationId: 0, boltIsContentPopular: false, boltClientAppState: 0 };
}
var BoltSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.boltUseCase !== 0) {
      writer.uint32(8).uint32(message.boltUseCase);
    }
    if (message.boltCdnExperimentationId !== 0) {
      writer.uint32(16).uint32(message.boltCdnExperimentationId);
    }
    if (message.boltIsContentPopular !== false) {
      writer.uint32(24).bool(message.boltIsContentPopular);
    }
    if (message.boltClientAppState !== 0) {
      writer.uint32(32).int32(message.boltClientAppState);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBoltSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.boltUseCase = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.boltCdnExperimentationId = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.boltIsContentPopular = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.boltClientAppState = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BoltSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseBoltSignals();
    message.boltUseCase = (_a = object.boltUseCase) !== null && _a !== void 0 ? _a : 0;
    message.boltCdnExperimentationId = (_b = object.boltCdnExperimentationId) !== null && _b !== void 0 ? _b : 0;
    message.boltIsContentPopular = (_c = object.boltIsContentPopular) !== null && _c !== void 0 ? _c : false;
    message.boltClientAppState = (_d = object.boltClientAppState) !== null && _d !== void 0 ? _d : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/camera_provided_signals.js
var CameraDirection;
(function(CameraDirection2) {
  CameraDirection2[CameraDirection2["UNKNOWN_CAMERA_DIRECTION"] = 0] = "UNKNOWN_CAMERA_DIRECTION";
  CameraDirection2[CameraDirection2["FRONT"] = 1] = "FRONT";
  CameraDirection2[CameraDirection2["BACK"] = 2] = "BACK";
  CameraDirection2[CameraDirection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraDirection || (CameraDirection = {}));
var CameraContext;
(function(CameraContext2) {
  CameraContext2[CameraContext2["UNKNOWN_CAMERA_CONTEXT"] = 0] = "UNKNOWN_CAMERA_CONTEXT";
  CameraContext2[CameraContext2["MAIN"] = 1] = "MAIN";
  CameraContext2[CameraContext2["REPLY"] = 2] = "REPLY";
  CameraContext2[CameraContext2["PROFILE"] = 3] = "PROFILE";
  CameraContext2[CameraContext2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraContext || (CameraContext = {}));
var CameraApi;
(function(CameraApi2) {
  CameraApi2[CameraApi2["UNKNOWN_CAMERA_API"] = 0] = "UNKNOWN_CAMERA_API";
  CameraApi2[CameraApi2["CAMERA_1"] = 1] = "CAMERA_1";
  CameraApi2[CameraApi2["CAMERA_2"] = 2] = "CAMERA_2";
  CameraApi2[CameraApi2["ARCORE"] = 3] = "ARCORE";
  CameraApi2[CameraApi2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraApi || (CameraApi = {}));
var FlashState;
(function(FlashState2) {
  FlashState2[FlashState2["UNKNOWN_FLASH_STATE"] = 0] = "UNKNOWN_FLASH_STATE";
  FlashState2[FlashState2["FLASH_ON"] = 1] = "FLASH_ON";
  FlashState2[FlashState2["FLASH_OFF"] = 2] = "FLASH_OFF";
  FlashState2[FlashState2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FlashState || (FlashState = {}));
var NightModeState;
(function(NightModeState2) {
  NightModeState2[NightModeState2["UNKNOWN_NIGHT_MODE_STATE"] = 0] = "UNKNOWN_NIGHT_MODE_STATE";
  NightModeState2[NightModeState2["NIGHT_MODE_ON"] = 1] = "NIGHT_MODE_ON";
  NightModeState2[NightModeState2["NIGHT_MODE_OFF"] = 2] = "NIGHT_MODE_OFF";
  NightModeState2[NightModeState2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(NightModeState || (NightModeState = {}));
var PictureMode;
(function(PictureMode2) {
  PictureMode2[PictureMode2["UNKNOWN_PICTURE_MODE"] = 0] = "UNKNOWN_PICTURE_MODE";
  PictureMode2[PictureMode2["JPEG_PICTURE_MODE"] = 1] = "JPEG_PICTURE_MODE";
  PictureMode2[PictureMode2["GPU_PICTURE_MODE"] = 2] = "GPU_PICTURE_MODE";
  PictureMode2[PictureMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(PictureMode || (PictureMode = {}));
var CaptureMode;
(function(CaptureMode2) {
  CaptureMode2[CaptureMode2["UNKNOWN_CAPTURE_MODE"] = 0] = "UNKNOWN_CAPTURE_MODE";
  CaptureMode2[CaptureMode2["DEFAULT_CAPTURE_MODE"] = 1] = "DEFAULT_CAPTURE_MODE";
  CaptureMode2[CaptureMode2["TIMELINE_CAPTURE_MODE"] = 2] = "TIMELINE_CAPTURE_MODE";
  CaptureMode2[CaptureMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CaptureMode || (CaptureMode = {}));
var Camera2Level;
(function(Camera2Level2) {
  Camera2Level2[Camera2Level2["UNKNOWN_CAMERA2_LEVEL"] = 0] = "UNKNOWN_CAMERA2_LEVEL";
  Camera2Level2[Camera2Level2["LEGACY"] = 1] = "LEGACY";
  Camera2Level2[Camera2Level2["LIMITED"] = 2] = "LIMITED";
  Camera2Level2[Camera2Level2["FULL"] = 3] = "FULL";
  Camera2Level2[Camera2Level2["LEVEL_3"] = 4] = "LEVEL_3";
  Camera2Level2[Camera2Level2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Camera2Level || (Camera2Level = {}));
function createBaseCameraSignals() {
  return {
    cameraDirection: 0,
    cameraContext: 0,
    cameraApi: 0,
    flashState: 0,
    camera2Level: 0,
    nightModeState: 0,
    isFirstCapture: false,
    pictureMode: 0,
    captureMode: 0,
    hasLens: false,
    isLowLight: false,
    isConcurrentCameraSupported: false
  };
}
var CameraSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraDirection !== 0) {
      writer.uint32(8).int32(message.cameraDirection);
    }
    if (message.cameraContext !== 0) {
      writer.uint32(16).int32(message.cameraContext);
    }
    if (message.cameraApi !== 0) {
      writer.uint32(24).int32(message.cameraApi);
    }
    if (message.flashState !== 0) {
      writer.uint32(32).int32(message.flashState);
    }
    if (message.camera2Level !== 0) {
      writer.uint32(40).int32(message.camera2Level);
    }
    if (message.nightModeState !== 0) {
      writer.uint32(48).int32(message.nightModeState);
    }
    if (message.isFirstCapture !== false) {
      writer.uint32(56).bool(message.isFirstCapture);
    }
    if (message.pictureMode !== 0) {
      writer.uint32(64).int32(message.pictureMode);
    }
    if (message.captureMode !== 0) {
      writer.uint32(72).int32(message.captureMode);
    }
    if (message.hasLens !== false) {
      writer.uint32(80).bool(message.hasLens);
    }
    if (message.isLowLight !== false) {
      writer.uint32(88).bool(message.isLowLight);
    }
    if (message.isConcurrentCameraSupported !== false) {
      writer.uint32(96).bool(message.isConcurrentCameraSupported);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCameraSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.cameraDirection = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.cameraContext = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.cameraApi = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.flashState = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.camera2Level = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.nightModeState = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.isFirstCapture = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }
          message.pictureMode = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.captureMode = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.hasLens = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }
          message.isLowLight = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }
          message.isConcurrentCameraSupported = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return CameraSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const message = createBaseCameraSignals();
    message.cameraDirection = (_a = object.cameraDirection) !== null && _a !== void 0 ? _a : 0;
    message.cameraContext = (_b = object.cameraContext) !== null && _b !== void 0 ? _b : 0;
    message.cameraApi = (_c = object.cameraApi) !== null && _c !== void 0 ? _c : 0;
    message.flashState = (_d = object.flashState) !== null && _d !== void 0 ? _d : 0;
    message.camera2Level = (_e = object.camera2Level) !== null && _e !== void 0 ? _e : 0;
    message.nightModeState = (_f = object.nightModeState) !== null && _f !== void 0 ? _f : 0;
    message.isFirstCapture = (_g = object.isFirstCapture) !== null && _g !== void 0 ? _g : false;
    message.pictureMode = (_h = object.pictureMode) !== null && _h !== void 0 ? _h : 0;
    message.captureMode = (_j = object.captureMode) !== null && _j !== void 0 ? _j : 0;
    message.hasLens = (_k = object.hasLens) !== null && _k !== void 0 ? _k : false;
    message.isLowLight = (_l = object.isLowLight) !== null && _l !== void 0 ? _l : false;
    message.isConcurrentCameraSupported = (_m = object.isConcurrentCameraSupported) !== null && _m !== void 0 ? _m : false;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/cognac_provided_signals.js
function createBaseCognacSignals() {
  return { cognacId: [] };
}
var CognacSignals = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.cognacId) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCognacSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.cognacId.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return CognacSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseCognacSignals();
    message.cognacId = ((_a = object.cognacId) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/content_manager_provided_signals.js
var LegacyMushroomContentType;
(function(LegacyMushroomContentType2) {
  LegacyMushroomContentType2[LegacyMushroomContentType2["UNKNOWN_ASSET_TYPE"] = 0] = "UNKNOWN_ASSET_TYPE";
  LegacyMushroomContentType2[LegacyMushroomContentType2["GENERIC_LARGE_ASSET_TYPE"] = 1] = "GENERIC_LARGE_ASSET_TYPE";
  LegacyMushroomContentType2[LegacyMushroomContentType2["GENERIC_SMALL_ASSET_TYPE"] = 2] = "GENERIC_SMALL_ASSET_TYPE";
  LegacyMushroomContentType2[LegacyMushroomContentType2["AD_REMOTE_ASSET"] = 3] = "AD_REMOTE_ASSET";
  LegacyMushroomContentType2[LegacyMushroomContentType2["AD_SNAP"] = 4] = "AD_SNAP";
  LegacyMushroomContentType2[LegacyMushroomContentType2["AD_WEB_VIEW_RESOURCE_CONTENT"] = 5] = "AD_WEB_VIEW_RESOURCE_CONTENT";
  LegacyMushroomContentType2[LegacyMushroomContentType2["ATTACHMENT_INFO"] = 6] = "ATTACHMENT_INFO";
  LegacyMushroomContentType2[LegacyMushroomContentType2["BITMOJI"] = 7] = "BITMOJI";
  LegacyMushroomContentType2[LegacyMushroomContentType2["BITMOJI_LENS_AVATAR_ASSET"] = 8] = "BITMOJI_LENS_AVATAR_ASSET";
  LegacyMushroomContentType2[LegacyMushroomContentType2["BITMOJI_LENS_METADATA"] = 9] = "BITMOJI_LENS_METADATA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["CAPTION_METADATA"] = 10] = "CAPTION_METADATA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["CAPTION_TYPEFACE"] = 11] = "CAPTION_TYPEFACE";
  LegacyMushroomContentType2[LegacyMushroomContentType2["CAPTION_VIEW_BITMAP"] = 12] = "CAPTION_VIEW_BITMAP";
  LegacyMushroomContentType2[LegacyMushroomContentType2["CHAT_MEDIA_THUMBNAIL"] = 13] = "CHAT_MEDIA_THUMBNAIL";
  LegacyMushroomContentType2[LegacyMushroomContentType2["COGNAC"] = 14] = "COGNAC";
  LegacyMushroomContentType2[LegacyMushroomContentType2["COGNAC_WEBVIEW"] = 15] = "COGNAC_WEBVIEW";
  LegacyMushroomContentType2[LegacyMushroomContentType2["COMMERCE"] = 16] = "COMMERCE";
  LegacyMushroomContentType2[LegacyMushroomContentType2["CONTEXT_FILTER_METADATA"] = 17] = "CONTEXT_FILTER_METADATA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["CUSTOM_STICKERS"] = 18] = "CUSTOM_STICKERS";
  LegacyMushroomContentType2[LegacyMushroomContentType2["DISCOVER_FEED_THUMBNAIL"] = 19] = "DISCOVER_FEED_THUMBNAIL";
  LegacyMushroomContentType2[LegacyMushroomContentType2["DISCOVER_PUBLISHER_SNAP"] = 20] = "DISCOVER_PUBLISHER_SNAP";
  LegacyMushroomContentType2[LegacyMushroomContentType2["DISCOVER_STORY_SNAP"] = 21] = "DISCOVER_STORY_SNAP";
  LegacyMushroomContentType2[LegacyMushroomContentType2["DISCOVER_STORY_STREAMING_SNAP"] = 22] = "DISCOVER_STORY_STREAMING_SNAP";
  LegacyMushroomContentType2[LegacyMushroomContentType2["EMOJI"] = 23] = "EMOJI";
  LegacyMushroomContentType2[LegacyMushroomContentType2["EMOJI_BRUSH"] = 24] = "EMOJI_BRUSH";
  LegacyMushroomContentType2[LegacyMushroomContentType2["EXTERNAL_GEOFILTER"] = 25] = "EXTERNAL_GEOFILTER";
  LegacyMushroomContentType2[LegacyMushroomContentType2["EXTERNAL_STICKER"] = 26] = "EXTERNAL_STICKER";
  LegacyMushroomContentType2[LegacyMushroomContentType2["GEOFILTER_OVERLAY"] = 27] = "GEOFILTER_OVERLAY";
  LegacyMushroomContentType2[LegacyMushroomContentType2["IMAGELOADING_URL"] = 28] = "IMAGELOADING_URL";
  LegacyMushroomContentType2[LegacyMushroomContentType2["HELVETICA"] = 29] = "HELVETICA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["INFO_STICKER"] = 30] = "INFO_STICKER";
  LegacyMushroomContentType2[LegacyMushroomContentType2["LENS_CONTENT"] = 31] = "LENS_CONTENT";
  LegacyMushroomContentType2[LegacyMushroomContentType2["LENS_ICON"] = 32] = "LENS_ICON";
  LegacyMushroomContentType2[LegacyMushroomContentType2["LENS_OVERLAY_IMAGE"] = 33] = "LENS_OVERLAY_IMAGE";
  LegacyMushroomContentType2[LegacyMushroomContentType2["LENS_REMOTE_ASSET"] = 34] = "LENS_REMOTE_ASSET";
  LegacyMushroomContentType2[LegacyMushroomContentType2["LOGIN_KIT_PRIVACT"] = 35] = "LOGIN_KIT_PRIVACT";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MAPS_EGGHUNT"] = 36] = "MAPS_EGGHUNT";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MAPS_KASHMIR"] = 37] = "MAPS_KASHMIR";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MAPS_WORLDEFFECTS"] = 38] = "MAPS_WORLDEFFECTS";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MEDIA_PACKAGE_COMPOSITE"] = 39] = "MEDIA_PACKAGE_COMPOSITE";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MEDIA_PACKAGE_THUMB"] = 40] = "MEDIA_PACKAGE_THUMB";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MEMORIES_EDITS"] = 41] = "MEMORIES_EDITS";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MEMORIES_MEDIA"] = 42] = "MEMORIES_MEDIA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MEMORIES_MINI_THUMBNAIL"] = 43] = "MEMORIES_MINI_THUMBNAIL";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MEMORIES_OVERLAY"] = 44] = "MEMORIES_OVERLAY";
  LegacyMushroomContentType2[LegacyMushroomContentType2["MEMORIES_THUMBNAIL"] = 45] = "MEMORIES_THUMBNAIL";
  LegacyMushroomContentType2[LegacyMushroomContentType2["NON_USER_BITMOJI"] = 46] = "NON_USER_BITMOJI";
  LegacyMushroomContentType2[LegacyMushroomContentType2["PAYMENTS"] = 47] = "PAYMENTS";
  LegacyMushroomContentType2[LegacyMushroomContentType2["PUBLISHER_SNAP_MEDIA"] = 48] = "PUBLISHER_SNAP_MEDIA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["SHAZAM"] = 49] = "SHAZAM";
  LegacyMushroomContentType2[LegacyMushroomContentType2["SKY_MODEL"] = 50] = "SKY_MODEL";
  LegacyMushroomContentType2[LegacyMushroomContentType2["SNAP"] = 51] = "SNAP";
  LegacyMushroomContentType2[LegacyMushroomContentType2["SNAP_FIRST_FRAME"] = 52] = "SNAP_FIRST_FRAME";
  LegacyMushroomContentType2[LegacyMushroomContentType2["SNAP_LOADING_FRAME"] = 53] = "SNAP_LOADING_FRAME";
  LegacyMushroomContentType2[LegacyMushroomContentType2["SNAP_STICKER"] = 54] = "SNAP_STICKER";
  LegacyMushroomContentType2[LegacyMushroomContentType2["SPECTACLES"] = 55] = "SPECTACLES";
  LegacyMushroomContentType2[LegacyMushroomContentType2["STICKER_TAG"] = 56] = "STICKER_TAG";
  LegacyMushroomContentType2[LegacyMushroomContentType2["STICKERS_METADATA"] = 57] = "STICKERS_METADATA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["STORY_SNAP"] = 58] = "STORY_SNAP";
  LegacyMushroomContentType2[LegacyMushroomContentType2["STORY_THUMB"] = 59] = "STORY_THUMB";
  LegacyMushroomContentType2[LegacyMushroomContentType2["TRACKING_DATA"] = 60] = "TRACKING_DATA";
  LegacyMushroomContentType2[LegacyMushroomContentType2["USER_GENERATED_ASSETS"] = 61] = "USER_GENERATED_ASSETS";
  LegacyMushroomContentType2[LegacyMushroomContentType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(LegacyMushroomContentType || (LegacyMushroomContentType = {}));
function createBaseContentManagerSignals() {
  return { legacyMushroomContentType: 0 };
}
var ContentManagerSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.legacyMushroomContentType !== 0) {
      writer.uint32(8).int32(message.legacyMushroomContentType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseContentManagerSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.legacyMushroomContentType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ContentManagerSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseContentManagerSignals();
    message.legacyMushroomContentType = (_a = object.legacyMushroomContentType) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/creative_tools_provided_signals.js
function createBaseCreativeToolsSignals() {
  return { withAnimatedOverlay: false, withMusic: false };
}
var CreativeToolsSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.withAnimatedOverlay !== false) {
      writer.uint32(8).bool(message.withAnimatedOverlay);
    }
    if (message.withMusic !== false) {
      writer.uint32(16).bool(message.withMusic);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseCreativeToolsSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.withAnimatedOverlay = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.withMusic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return CreativeToolsSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCreativeToolsSignals();
    message.withAnimatedOverlay = (_a = object.withAnimatedOverlay) !== null && _a !== void 0 ? _a : false;
    message.withMusic = (_b = object.withMusic) !== null && _b !== void 0 ? _b : false;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/discover_feed_provided_signals.js
function createBaseDiscoverFeedSignals() {
  return { discoverFeedSectionCacheInfo: void 0 };
}
var DiscoverFeedSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.discoverFeedSectionCacheInfo !== void 0) {
      DiscoverFeedSignals_DiscoverFeedSectionCacheInfo.encode(message.discoverFeedSectionCacheInfo, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDiscoverFeedSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.discoverFeedSectionCacheInfo = DiscoverFeedSignals_DiscoverFeedSectionCacheInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return DiscoverFeedSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseDiscoverFeedSignals();
    message.discoverFeedSectionCacheInfo = object.discoverFeedSectionCacheInfo !== void 0 && object.discoverFeedSectionCacheInfo !== null ? DiscoverFeedSignals_DiscoverFeedSectionCacheInfo.fromPartial(object.discoverFeedSectionCacheInfo) : void 0;
    return message;
  }
};
function createBaseDiscoverFeedSignals_DiscoverFeedSectionCacheInfo() {
  return { feedType: 0 };
}
var DiscoverFeedSignals_DiscoverFeedSectionCacheInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.feedType !== 0) {
      writer.uint32(8).int32(message.feedType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseDiscoverFeedSignals_DiscoverFeedSectionCacheInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.feedType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return DiscoverFeedSignals_DiscoverFeedSectionCacheInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseDiscoverFeedSignals_DiscoverFeedSectionCacheInfo();
    message.feedType = (_a = object.feedType) !== null && _a !== void 0 ? _a : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/lenses_provided_signals.js
function createBaseLensesSignals() {
  return { lastLensActivatedTime: "0", lastSnappableLensActivatedTime: "0", isAnyEffectApplied: false };
}
var LensesSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.lastLensActivatedTime !== "0") {
      writer.uint32(8).uint64(message.lastLensActivatedTime);
    }
    if (message.lastSnappableLensActivatedTime !== "0") {
      writer.uint32(16).uint64(message.lastSnappableLensActivatedTime);
    }
    if (message.isAnyEffectApplied !== false) {
      writer.uint32(24).bool(message.isAnyEffectApplied);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLensesSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.lastLensActivatedTime = reader.uint64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.lastSnappableLensActivatedTime = reader.uint64().toString();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.isAnyEffectApplied = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return LensesSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseLensesSignals();
    message.lastLensActivatedTime = (_a = object.lastLensActivatedTime) !== null && _a !== void 0 ? _a : "0";
    message.lastSnappableLensActivatedTime = (_b = object.lastSnappableLensActivatedTime) !== null && _b !== void 0 ? _b : "0";
    message.isAnyEffectApplied = (_c = object.isAnyEffectApplied) !== null && _c !== void 0 ? _c : false;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/mdp_media_attribution.js
function createBaseMdpMediaAttribution() {
  return { mediaSource: 0, assetType: 0 };
}
var MdpMediaAttribution = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mediaSource !== 0) {
      writer.uint32(8).int32(message.mediaSource);
    }
    if (message.assetType !== 0) {
      writer.uint32(16).int32(message.assetType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMdpMediaAttribution();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.mediaSource = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.assetType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MdpMediaAttribution.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMdpMediaAttribution();
    message.mediaSource = (_a = object.mediaSource) !== null && _a !== void 0 ? _a : 0;
    message.assetType = (_b = object.assetType) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/media_provided_signals.js
var MediaType;
(function(MediaType2) {
  MediaType2[MediaType2["MEDIA_TYPE_UNSET"] = 0] = "MEDIA_TYPE_UNSET";
  MediaType2[MediaType2["IMAGE"] = 1] = "IMAGE";
  MediaType2[MediaType2["VIDEO"] = 2] = "VIDEO";
  MediaType2[MediaType2["GIF"] = 3] = "GIF";
  MediaType2[MediaType2["AUDIO"] = 4] = "AUDIO";
  MediaType2[MediaType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(MediaType || (MediaType = {}));
function createBaseMediaSignals() {
  return { mediaDurationMs: 0, mediaType: 0 };
}
var MediaSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mediaDurationMs !== 0) {
      writer.uint32(8).uint32(message.mediaDurationMs);
    }
    if (message.mediaType !== 0) {
      writer.uint32(16).int32(message.mediaType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseMediaSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.mediaDurationMs = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.mediaType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return MediaSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseMediaSignals();
    message.mediaDurationMs = (_a = object.mediaDurationMs) !== null && _a !== void 0 ? _a : 0;
    message.mediaType = (_b = object.mediaType) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/opera_provided_signals.js
function createBaseOperaSignals() {
  return { contentViewSource: 0, playbackItemType: 0, useVerticalNavigation: false };
}
var OperaSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.contentViewSource !== 0) {
      writer.uint32(8).int32(message.contentViewSource);
    }
    if (message.playbackItemType !== 0) {
      writer.uint32(16).int32(message.playbackItemType);
    }
    if (message.useVerticalNavigation !== false) {
      writer.uint32(24).bool(message.useVerticalNavigation);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseOperaSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.contentViewSource = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.playbackItemType = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.useVerticalNavigation = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return OperaSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseOperaSignals();
    message.contentViewSource = (_a = object.contentViewSource) !== null && _a !== void 0 ? _a : 0;
    message.playbackItemType = (_b = object.playbackItemType) !== null && _b !== void 0 ? _b : 0;
    message.useVerticalNavigation = (_c = object.useVerticalNavigation) !== null && _c !== void 0 ? _c : false;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/perception_provided_signals.js
function createBasePerceptionSignals() {
  return { scannedCategoryIds: [] };
}
var PerceptionSignals = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.scannedCategoryIds) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePerceptionSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.scannedCategoryIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PerceptionSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBasePerceptionSignals();
    message.scannedCategoryIds = ((_a = object.scannedCategoryIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/recipients_provided_signals.js
function createBaseRecipientsSignals() {
  return { userIds: [] };
}
var RecipientsSignals = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.userIds) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRecipientsSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.userIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RecipientsSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseRecipientsSignals();
    message.userIds = ((_a = object.userIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/routing_provided_signals.js
function createBaseRoutingSignals() {
  return { url: "" };
}
var RoutingSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.url !== "") {
      writer.uint32(10).string(message.url);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRoutingSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.url = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RoutingSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseRoutingSignals();
    message.url = (_a = object.url) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/snap_kit_provided_signals.js
function createBaseSnapKitSignals() {
  return { oauthClientId: "" };
}
var SnapKitSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.oauthClientId !== "") {
      writer.uint32(10).string(message.oauthClientId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnapKitSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.oauthClientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SnapKitSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSnapKitSignals();
    message.oauthClientId = (_a = object.oauthClientId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/upload_provided_signals.js
var ChunkUploadPreference;
(function(ChunkUploadPreference2) {
  ChunkUploadPreference2[ChunkUploadPreference2["PREFERENCE_UNSET"] = 0] = "PREFERENCE_UNSET";
  ChunkUploadPreference2[ChunkUploadPreference2["GCS"] = 1] = "GCS";
  ChunkUploadPreference2[ChunkUploadPreference2["S3"] = 2] = "S3";
  ChunkUploadPreference2[ChunkUploadPreference2["AUTO"] = 3] = "AUTO";
  ChunkUploadPreference2[ChunkUploadPreference2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ChunkUploadPreference || (ChunkUploadPreference = {}));
function createBaseUploadSignals() {
  return { chunkUploadSupportRequired: false, cloudfrontPop: "", gcdnPop: "", chunkUploadPreference: 0 };
}
var UploadSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.chunkUploadSupportRequired !== false) {
      writer.uint32(8).bool(message.chunkUploadSupportRequired);
    }
    if (message.cloudfrontPop !== "") {
      writer.uint32(18).string(message.cloudfrontPop);
    }
    if (message.gcdnPop !== "") {
      writer.uint32(26).string(message.gcdnPop);
    }
    if (message.chunkUploadPreference !== 0) {
      writer.uint32(32).int32(message.chunkUploadPreference);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUploadSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.chunkUploadSupportRequired = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.cloudfrontPop = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.gcdnPop = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.chunkUploadPreference = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return UploadSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseUploadSignals();
    message.chunkUploadSupportRequired = (_a = object.chunkUploadSupportRequired) !== null && _a !== void 0 ? _a : false;
    message.cloudfrontPop = (_b = object.cloudfrontPop) !== null && _b !== void 0 ? _b : "";
    message.gcdnPop = (_c = object.gcdnPop) !== null && _c !== void 0 ? _c : "";
    message.chunkUploadPreference = (_d = object.chunkUploadPreference) !== null && _d !== void 0 ? _d : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/feature_provided_signals.js
var FeatureProvidedSignals_StoryType;
(function(FeatureProvidedSignals_StoryType2) {
  FeatureProvidedSignals_StoryType2[FeatureProvidedSignals_StoryType2["UNKNOWN_STORY_TYPE"] = 0] = "UNKNOWN_STORY_TYPE";
  FeatureProvidedSignals_StoryType2[FeatureProvidedSignals_StoryType2["PUBLIC_USER_STORY"] = 1] = "PUBLIC_USER_STORY";
  FeatureProvidedSignals_StoryType2[FeatureProvidedSignals_StoryType2["OUR_STORY"] = 2] = "OUR_STORY";
  FeatureProvidedSignals_StoryType2[FeatureProvidedSignals_StoryType2["PUBLISHER_STORY"] = 3] = "PUBLISHER_STORY";
  FeatureProvidedSignals_StoryType2[FeatureProvidedSignals_StoryType2["FRIEND_STORY"] = 4] = "FRIEND_STORY";
  FeatureProvidedSignals_StoryType2[FeatureProvidedSignals_StoryType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FeatureProvidedSignals_StoryType || (FeatureProvidedSignals_StoryType = {}));
var FeatureProvidedSignals_SpectaclesVersion;
(function(FeatureProvidedSignals_SpectaclesVersion2) {
  FeatureProvidedSignals_SpectaclesVersion2[FeatureProvidedSignals_SpectaclesVersion2["UNKNOWN_SPECTACLES_VERSION"] = 0] = "UNKNOWN_SPECTACLES_VERSION";
  FeatureProvidedSignals_SpectaclesVersion2[FeatureProvidedSignals_SpectaclesVersion2["V1"] = 1] = "V1";
  FeatureProvidedSignals_SpectaclesVersion2[FeatureProvidedSignals_SpectaclesVersion2["V2"] = 2] = "V2";
  FeatureProvidedSignals_SpectaclesVersion2[FeatureProvidedSignals_SpectaclesVersion2["V3"] = 3] = "V3";
  FeatureProvidedSignals_SpectaclesVersion2[FeatureProvidedSignals_SpectaclesVersion2["V4"] = 4] = "V4";
  FeatureProvidedSignals_SpectaclesVersion2[FeatureProvidedSignals_SpectaclesVersion2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(FeatureProvidedSignals_SpectaclesVersion || (FeatureProvidedSignals_SpectaclesVersion = {}));
function createBaseFeatureProvidedSignals() {
  return {
    mediaMetadata: void 0,
    storyMetadata: void 0,
    cameraSignals: void 0,
    snapSource: 0,
    contentManagerProvidedSignals: void 0,
    spectacleMetadata: void 0,
    boltSignals: void 0,
    lensesSignals: void 0,
    creativeToolsSignals: void 0,
    estimatedDurationForEventMs: 0,
    routingSignals: void 0,
    mdpMediaAttribution: void 0,
    size: 0,
    mediaSignals: void 0,
    perceptionSignals: void 0,
    operaSignals: void 0,
    recipientsSignals: void 0,
    billboardSignals: void 0,
    cognacSignals: void 0,
    hashSignals: void 0,
    edgeSignals: {},
    snapKitSignals: void 0,
    uploadSignals: void 0,
    ruids: [],
    discoverFeedSignals: void 0
  };
}
var FeatureProvidedSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.mediaMetadata !== void 0) {
      MediaMetadata.encode(message.mediaMetadata, writer.uint32(10).fork()).join();
    }
    if (message.storyMetadata !== void 0) {
      FeatureProvidedSignals_StoryMetadata.encode(message.storyMetadata, writer.uint32(18).fork()).join();
    }
    if (message.cameraSignals !== void 0) {
      CameraSignals.encode(message.cameraSignals, writer.uint32(26).fork()).join();
    }
    if (message.snapSource !== 0) {
      writer.uint32(32).int32(message.snapSource);
    }
    if (message.contentManagerProvidedSignals !== void 0) {
      ContentManagerSignals.encode(message.contentManagerProvidedSignals, writer.uint32(42).fork()).join();
    }
    if (message.spectacleMetadata !== void 0) {
      FeatureProvidedSignals_SpectacleMetadata.encode(message.spectacleMetadata, writer.uint32(50).fork()).join();
    }
    if (message.boltSignals !== void 0) {
      BoltSignals.encode(message.boltSignals, writer.uint32(58).fork()).join();
    }
    if (message.lensesSignals !== void 0) {
      LensesSignals.encode(message.lensesSignals, writer.uint32(66).fork()).join();
    }
    if (message.creativeToolsSignals !== void 0) {
      CreativeToolsSignals.encode(message.creativeToolsSignals, writer.uint32(74).fork()).join();
    }
    if (message.estimatedDurationForEventMs !== 0) {
      writer.uint32(80).uint32(message.estimatedDurationForEventMs);
    }
    if (message.routingSignals !== void 0) {
      RoutingSignals.encode(message.routingSignals, writer.uint32(90).fork()).join();
    }
    if (message.mdpMediaAttribution !== void 0) {
      MdpMediaAttribution.encode(message.mdpMediaAttribution, writer.uint32(98).fork()).join();
    }
    if (message.size !== 0) {
      writer.uint32(104).uint32(message.size);
    }
    if (message.mediaSignals !== void 0) {
      MediaSignals.encode(message.mediaSignals, writer.uint32(114).fork()).join();
    }
    if (message.perceptionSignals !== void 0) {
      PerceptionSignals.encode(message.perceptionSignals, writer.uint32(122).fork()).join();
    }
    if (message.operaSignals !== void 0) {
      OperaSignals.encode(message.operaSignals, writer.uint32(130).fork()).join();
    }
    if (message.recipientsSignals !== void 0) {
      RecipientsSignals.encode(message.recipientsSignals, writer.uint32(138).fork()).join();
    }
    if (message.billboardSignals !== void 0) {
      BillboardSignals.encode(message.billboardSignals, writer.uint32(146).fork()).join();
    }
    if (message.cognacSignals !== void 0) {
      CognacSignals.encode(message.cognacSignals, writer.uint32(154).fork()).join();
    }
    if (message.hashSignals !== void 0) {
      FeatureProvidedSignals_HashSignals.encode(message.hashSignals, writer.uint32(162).fork()).join();
    }
    Object.entries(message.edgeSignals).forEach(([key, value]) => {
      FeatureProvidedSignals_EdgeSignalsEntry.encode({ key, value }, writer.uint32(170).fork()).join();
    });
    if (message.snapKitSignals !== void 0) {
      SnapKitSignals.encode(message.snapKitSignals, writer.uint32(178).fork()).join();
    }
    if (message.uploadSignals !== void 0) {
      UploadSignals.encode(message.uploadSignals, writer.uint32(186).fork()).join();
    }
    for (const v2 of message.ruids) {
      Ruid.encode(v2, writer.uint32(194).fork()).join();
    }
    if (message.discoverFeedSignals !== void 0) {
      DiscoverFeedSignals.encode(message.discoverFeedSignals, writer.uint32(202).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFeatureProvidedSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.mediaMetadata = MediaMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.storyMetadata = FeatureProvidedSignals_StoryMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.cameraSignals = CameraSignals.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.snapSource = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.contentManagerProvidedSignals = ContentManagerSignals.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.spectacleMetadata = FeatureProvidedSignals_SpectacleMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.boltSignals = BoltSignals.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.lensesSignals = LensesSignals.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.creativeToolsSignals = CreativeToolsSignals.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.estimatedDurationForEventMs = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.routingSignals = RoutingSignals.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }
          message.mdpMediaAttribution = MdpMediaAttribution.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.size = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }
          message.mediaSignals = MediaSignals.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }
          message.perceptionSignals = PerceptionSignals.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }
          message.operaSignals = OperaSignals.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }
          message.recipientsSignals = RecipientsSignals.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }
          message.billboardSignals = BillboardSignals.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }
          message.cognacSignals = CognacSignals.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }
          message.hashSignals = FeatureProvidedSignals_HashSignals.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }
          const entry21 = FeatureProvidedSignals_EdgeSignalsEntry.decode(reader, reader.uint32());
          if (entry21.value !== void 0) {
            message.edgeSignals[entry21.key] = entry21.value;
          }
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }
          message.snapKitSignals = SnapKitSignals.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }
          message.uploadSignals = UploadSignals.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }
          message.ruids.push(Ruid.decode(reader, reader.uint32()));
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }
          message.discoverFeedSignals = DiscoverFeedSignals.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return FeatureProvidedSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseFeatureProvidedSignals();
    message.mediaMetadata = object.mediaMetadata !== void 0 && object.mediaMetadata !== null ? MediaMetadata.fromPartial(object.mediaMetadata) : void 0;
    message.storyMetadata = object.storyMetadata !== void 0 && object.storyMetadata !== null ? FeatureProvidedSignals_StoryMetadata.fromPartial(object.storyMetadata) : void 0;
    message.cameraSignals = object.cameraSignals !== void 0 && object.cameraSignals !== null ? CameraSignals.fromPartial(object.cameraSignals) : void 0;
    message.snapSource = (_a = object.snapSource) !== null && _a !== void 0 ? _a : 0;
    message.contentManagerProvidedSignals = object.contentManagerProvidedSignals !== void 0 && object.contentManagerProvidedSignals !== null ? ContentManagerSignals.fromPartial(object.contentManagerProvidedSignals) : void 0;
    message.spectacleMetadata = object.spectacleMetadata !== void 0 && object.spectacleMetadata !== null ? FeatureProvidedSignals_SpectacleMetadata.fromPartial(object.spectacleMetadata) : void 0;
    message.boltSignals = object.boltSignals !== void 0 && object.boltSignals !== null ? BoltSignals.fromPartial(object.boltSignals) : void 0;
    message.lensesSignals = object.lensesSignals !== void 0 && object.lensesSignals !== null ? LensesSignals.fromPartial(object.lensesSignals) : void 0;
    message.creativeToolsSignals = object.creativeToolsSignals !== void 0 && object.creativeToolsSignals !== null ? CreativeToolsSignals.fromPartial(object.creativeToolsSignals) : void 0;
    message.estimatedDurationForEventMs = (_b = object.estimatedDurationForEventMs) !== null && _b !== void 0 ? _b : 0;
    message.routingSignals = object.routingSignals !== void 0 && object.routingSignals !== null ? RoutingSignals.fromPartial(object.routingSignals) : void 0;
    message.mdpMediaAttribution = object.mdpMediaAttribution !== void 0 && object.mdpMediaAttribution !== null ? MdpMediaAttribution.fromPartial(object.mdpMediaAttribution) : void 0;
    message.size = (_c = object.size) !== null && _c !== void 0 ? _c : 0;
    message.mediaSignals = object.mediaSignals !== void 0 && object.mediaSignals !== null ? MediaSignals.fromPartial(object.mediaSignals) : void 0;
    message.perceptionSignals = object.perceptionSignals !== void 0 && object.perceptionSignals !== null ? PerceptionSignals.fromPartial(object.perceptionSignals) : void 0;
    message.operaSignals = object.operaSignals !== void 0 && object.operaSignals !== null ? OperaSignals.fromPartial(object.operaSignals) : void 0;
    message.recipientsSignals = object.recipientsSignals !== void 0 && object.recipientsSignals !== null ? RecipientsSignals.fromPartial(object.recipientsSignals) : void 0;
    message.billboardSignals = object.billboardSignals !== void 0 && object.billboardSignals !== null ? BillboardSignals.fromPartial(object.billboardSignals) : void 0;
    message.cognacSignals = object.cognacSignals !== void 0 && object.cognacSignals !== null ? CognacSignals.fromPartial(object.cognacSignals) : void 0;
    message.hashSignals = object.hashSignals !== void 0 && object.hashSignals !== null ? FeatureProvidedSignals_HashSignals.fromPartial(object.hashSignals) : void 0;
    message.edgeSignals = Object.entries((_d = object.edgeSignals) !== null && _d !== void 0 ? _d : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[globalThis.Number(key)] = Value.fromPartial(value);
      }
      return acc;
    }, {});
    message.snapKitSignals = object.snapKitSignals !== void 0 && object.snapKitSignals !== null ? SnapKitSignals.fromPartial(object.snapKitSignals) : void 0;
    message.uploadSignals = object.uploadSignals !== void 0 && object.uploadSignals !== null ? UploadSignals.fromPartial(object.uploadSignals) : void 0;
    message.ruids = ((_e = object.ruids) === null || _e === void 0 ? void 0 : _e.map((e2) => Ruid.fromPartial(e2))) || [];
    message.discoverFeedSignals = object.discoverFeedSignals !== void 0 && object.discoverFeedSignals !== null ? DiscoverFeedSignals.fromPartial(object.discoverFeedSignals) : void 0;
    return message;
  }
};
function createBaseFeatureProvidedSignals_StoryMetadata() {
  return { isPublicStory: false, isOfficialStory: false, storyType: 0 };
}
var FeatureProvidedSignals_StoryMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.isPublicStory !== false) {
      writer.uint32(8).bool(message.isPublicStory);
    }
    if (message.isOfficialStory !== false) {
      writer.uint32(16).bool(message.isOfficialStory);
    }
    if (message.storyType !== 0) {
      writer.uint32(24).int32(message.storyType);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFeatureProvidedSignals_StoryMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.isPublicStory = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.isOfficialStory = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.storyType = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return FeatureProvidedSignals_StoryMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseFeatureProvidedSignals_StoryMetadata();
    message.isPublicStory = (_a = object.isPublicStory) !== null && _a !== void 0 ? _a : false;
    message.isOfficialStory = (_b = object.isOfficialStory) !== null && _b !== void 0 ? _b : false;
    message.storyType = (_c = object.storyType) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseFeatureProvidedSignals_SpectacleMetadata() {
  return { isSpectacle: false, spectaclesVersion: 0 };
}
var FeatureProvidedSignals_SpectacleMetadata = {
  encode(message, writer = new BinaryWriter()) {
    if (message.isSpectacle !== false) {
      writer.uint32(8).bool(message.isSpectacle);
    }
    if (message.spectaclesVersion !== 0) {
      writer.uint32(16).int32(message.spectaclesVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFeatureProvidedSignals_SpectacleMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.isSpectacle = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.spectaclesVersion = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return FeatureProvidedSignals_SpectacleMetadata.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseFeatureProvidedSignals_SpectacleMetadata();
    message.isSpectacle = (_a = object.isSpectacle) !== null && _a !== void 0 ? _a : false;
    message.spectaclesVersion = (_b = object.spectaclesVersion) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseFeatureProvidedSignals_HashSignals() {
  return { userId: new Uint8Array(0), seed: new Uint8Array(0), namespace: 0 };
}
var FeatureProvidedSignals_HashSignals = {
  encode(message, writer = new BinaryWriter()) {
    if (message.userId.length !== 0) {
      writer.uint32(10).bytes(message.userId);
    }
    if (message.seed.length !== 0) {
      writer.uint32(18).bytes(message.seed);
    }
    if (message.namespace !== 0) {
      writer.uint32(24).int32(message.namespace);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFeatureProvidedSignals_HashSignals();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.userId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.seed = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.namespace = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return FeatureProvidedSignals_HashSignals.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseFeatureProvidedSignals_HashSignals();
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : new Uint8Array(0);
    message.seed = (_b = object.seed) !== null && _b !== void 0 ? _b : new Uint8Array(0);
    message.namespace = (_c = object.namespace) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseFeatureProvidedSignals_EdgeSignalsEntry() {
  return { key: 0, value: void 0 };
}
var FeatureProvidedSignals_EdgeSignalsEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== 0) {
      writer.uint32(8).int32(message.key);
    }
    if (message.value !== void 0) {
      Value.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFeatureProvidedSignals_EdgeSignalsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.key = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = Value.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return FeatureProvidedSignals_EdgeSignalsEntry.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseFeatureProvidedSignals_EdgeSignalsEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : 0;
    message.value = object.value !== void 0 && object.value !== null ? Value.fromPartial(object.value) : void 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/cdp/cof/circumstance_service.js
function createBaseGetAbConfigValuesRequest() {
  return {
    configNames: [],
    namespaces: [],
    cofConfigNames: [],
    includeAllConfigs: false,
    disableExposureLogging: false,
    enableDebug: false
  };
}
var GetAbConfigValuesRequest = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.configNames) {
      writer.uint32(10).string(v2);
    }
    writer.uint32(18).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.join();
    for (const v2 of message.cofConfigNames) {
      writer.uint32(26).string(v2);
    }
    if (message.includeAllConfigs !== false) {
      writer.uint32(32).bool(message.includeAllConfigs);
    }
    if (message.disableExposureLogging !== false) {
      writer.uint32(40).bool(message.disableExposureLogging);
    }
    if (message.enableDebug !== false) {
      writer.uint32(104).bool(message.enableDebug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAbConfigValuesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configNames.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.namespaces.push(reader.int32());
            continue;
          }
          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.cofConfigNames.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.includeAllConfigs = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.disableExposureLogging = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }
          message.enableDebug = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetAbConfigValuesRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseGetAbConfigValuesRequest();
    message.configNames = ((_a = object.configNames) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.namespaces = ((_b = object.namespaces) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.cofConfigNames = ((_c = object.cofConfigNames) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.includeAllConfigs = (_d = object.includeAllConfigs) !== null && _d !== void 0 ? _d : false;
    message.disableExposureLogging = (_e = object.disableExposureLogging) !== null && _e !== void 0 ? _e : false;
    message.enableDebug = (_f = object.enableDebug) !== null && _f !== void 0 ? _f : false;
    return message;
  }
};
function createBaseGetAbConfigValuesResponse() {
  return { configResults: [], debugTrace: void 0 };
}
var GetAbConfigValuesResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).join();
    }
    if (message.debugTrace !== void 0) {
      DebugTrace.encode(message.debugTrace, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetAbConfigValuesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.debugTrace = DebugTrace.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetAbConfigValuesResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetAbConfigValuesResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    message.debugTrace = object.debugTrace !== void 0 && object.debugTrace !== null ? DebugTrace.fromPartial(object.debugTrace) : void 0;
    return message;
  }
};
function createBaseConfigSetGenerationRequest() {
  return { targetingParameters: void 0, overrides: [] };
}
var ConfigSetGenerationRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.targetingParameters !== void 0) {
      ConfigTargetingRequest.encode(message.targetingParameters, writer.uint32(10).fork()).join();
    }
    for (const v2 of message.overrides) {
      ConfigResult.encode(v2, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigSetGenerationRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.targetingParameters = ConfigTargetingRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.overrides.push(ConfigResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigSetGenerationRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigSetGenerationRequest();
    message.targetingParameters = object.targetingParameters !== void 0 && object.targetingParameters !== null ? ConfigTargetingRequest.fromPartial(object.targetingParameters) : void 0;
    message.overrides = ((_a = object.overrides) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseConfigSetGenerationResponse() {
  return { targetingResponse: void 0 };
}
var ConfigSetGenerationResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.targetingResponse !== void 0) {
      ConfigTargetingResponse.encode(message.targetingResponse, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigSetGenerationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.targetingResponse = ConfigTargetingResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigSetGenerationResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseConfigSetGenerationResponse();
    message.targetingResponse = object.targetingResponse !== void 0 && object.targetingResponse !== null ? ConfigTargetingResponse.fromPartial(object.targetingResponse) : void 0;
    return message;
  }
};
function createBasePinConfigRequest() {
  return { configSetToken: "", userId: "", ttlSeconds: 0 };
}
var PinConfigRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.configSetToken !== "") {
      writer.uint32(10).string(message.configSetToken);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(24).int32(message.ttlSeconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configSetToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.ttlSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PinConfigRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBasePinConfigRequest();
    message.configSetToken = (_a = object.configSetToken) !== null && _a !== void 0 ? _a : "";
    message.userId = (_b = object.userId) !== null && _b !== void 0 ? _b : "";
    message.ttlSeconds = (_c = object.ttlSeconds) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBasePinConfigResponse() {
  return { debug: "" };
}
var PinConfigResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.debug !== "") {
      writer.uint32(10).string(message.debug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.debug = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PinConfigResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBasePinConfigResponse();
    message.debug = (_a = object.debug) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseUnpinConfigRequest() {
  return { configSetToken: "", userId: "" };
}
var UnpinConfigRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.configSetToken !== "") {
      writer.uint32(10).string(message.configSetToken);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configSetToken = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return UnpinConfigRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseUnpinConfigRequest();
    message.configSetToken = (_a = object.configSetToken) !== null && _a !== void 0 ? _a : "";
    message.userId = (_b = object.userId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseUnpinConfigResponse() {
  return { debug: "" };
}
var UnpinConfigResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.debug !== "") {
      writer.uint32(10).string(message.debug);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.debug = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return UnpinConfigResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUnpinConfigResponse();
    message.debug = (_a = object.debug) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBasePinTargetingPropertiesRequest() {
  return { userId: "", targetingProperties: void 0, ttlSeconds: 0 };
}
var PinTargetingPropertiesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.targetingProperties !== void 0) {
      FeatureProvidedSignals.encode(message.targetingProperties, writer.uint32(18).fork()).join();
    }
    if (message.ttlSeconds !== 0) {
      writer.uint32(24).int32(message.ttlSeconds);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinTargetingPropertiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.targetingProperties = FeatureProvidedSignals.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.ttlSeconds = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PinTargetingPropertiesRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePinTargetingPropertiesRequest();
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    message.targetingProperties = object.targetingProperties !== void 0 && object.targetingProperties !== null ? FeatureProvidedSignals.fromPartial(object.targetingProperties) : void 0;
    message.ttlSeconds = (_b = object.ttlSeconds) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBasePinTargetingPropertiesResponse() {
  return { message: "" };
}
var PinTargetingPropertiesResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePinTargetingPropertiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PinTargetingPropertiesResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBasePinTargetingPropertiesResponse();
    message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseUnpinTargetingPropertiesRequest() {
  return { userId: "" };
}
var UnpinTargetingPropertiesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinTargetingPropertiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return UnpinTargetingPropertiesRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUnpinTargetingPropertiesRequest();
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseUnpinTargetingPropertiesResponse() {
  return { message: "" };
}
var UnpinTargetingPropertiesResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUnpinTargetingPropertiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return UnpinTargetingPropertiesResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseUnpinTargetingPropertiesResponse();
    message.message = (_a = object.message) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseGetPinnedTargetingPropertiesRequest() {
  return { userId: "" };
}
var GetPinnedTargetingPropertiesRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPinnedTargetingPropertiesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetPinnedTargetingPropertiesRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetPinnedTargetingPropertiesRequest();
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseGetPinnedTargetingPropertiesResponse() {
  return { targetingProperties: void 0 };
}
var GetPinnedTargetingPropertiesResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.targetingProperties !== void 0) {
      FeatureProvidedSignals.encode(message.targetingProperties, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetPinnedTargetingPropertiesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.targetingProperties = FeatureProvidedSignals.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetPinnedTargetingPropertiesResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    const message = createBaseGetPinnedTargetingPropertiesResponse();
    message.targetingProperties = object.targetingProperties !== void 0 && object.targetingProperties !== null ? FeatureProvidedSignals.fromPartial(object.targetingProperties) : void 0;
    return message;
  }
};
function createBaseConfigWithNamespace() {
  return { configName: "", namespace: 0 };
}
var ConfigWithNamespace = {
  encode(message, writer = new BinaryWriter()) {
    if (message.configName !== "") {
      writer.uint32(10).string(message.configName);
    }
    if (message.namespace !== 0) {
      writer.uint32(16).int32(message.namespace);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigWithNamespace();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.namespace = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigWithNamespace.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseConfigWithNamespace();
    message.configName = (_a = object.configName) !== null && _a !== void 0 ? _a : "";
    message.namespace = (_b = object.namespace) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseGetConfigValuesByTokenRequest() {
  return { token: "", configNames: [], namespaces: [], disableExposureLogging: false, getAllConfigs: false };
}
var GetConfigValuesByTokenRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    for (const v2 of message.configNames) {
      ConfigWithNamespace.encode(v2, writer.uint32(18).fork()).join();
    }
    writer.uint32(26).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.join();
    if (message.disableExposureLogging !== false) {
      writer.uint32(32).bool(message.disableExposureLogging);
    }
    if (message.getAllConfigs !== false) {
      writer.uint32(40).bool(message.getAllConfigs);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigValuesByTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.configNames.push(ConfigWithNamespace.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.namespaces.push(reader.int32());
            continue;
          }
          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.disableExposureLogging = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.getAllConfigs = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetConfigValuesByTokenRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseGetConfigValuesByTokenRequest();
    message.token = (_a = object.token) !== null && _a !== void 0 ? _a : "";
    message.configNames = ((_b = object.configNames) === null || _b === void 0 ? void 0 : _b.map((e2) => ConfigWithNamespace.fromPartial(e2))) || [];
    message.namespaces = ((_c = object.namespaces) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.disableExposureLogging = (_d = object.disableExposureLogging) !== null && _d !== void 0 ? _d : false;
    message.getAllConfigs = (_e = object.getAllConfigs) !== null && _e !== void 0 ? _e : false;
    return message;
  }
};
function createBaseGetConfigValuesByTokenResponse() {
  return { configResults: [] };
}
var GetConfigValuesByTokenResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigValuesByTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetConfigValuesByTokenResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigValuesByTokenResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetCachedConfigResultSequenceIdsRequest() {
  return {};
}
var GetCachedConfigResultSequenceIdsRequest = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCachedConfigResultSequenceIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetCachedConfigResultSequenceIdsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseGetCachedConfigResultSequenceIdsRequest();
    return message;
  }
};
function createBaseGetCachedConfigResultSequenceIdsResponse() {
  return { serializedBitmap: new Uint8Array(0) };
}
var GetCachedConfigResultSequenceIdsResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.serializedBitmap.length !== 0) {
      writer.uint32(10).bytes(message.serializedBitmap);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetCachedConfigResultSequenceIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.serializedBitmap = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetCachedConfigResultSequenceIdsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetCachedConfigResultSequenceIdsResponse();
    message.serializedBitmap = (_a = object.serializedBitmap) !== null && _a !== void 0 ? _a : new Uint8Array(0);
    return message;
  }
};
function createBaseGetConfigResultsBySequenceIdsRequest() {
  return { sequenceIds: [] };
}
var GetConfigResultsBySequenceIdsRequest = {
  encode(message, writer = new BinaryWriter()) {
    writer.uint32(10).fork();
    for (const v2 of message.sequenceIds) {
      writer.int32(v2);
    }
    writer.join();
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResultsBySequenceIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.sequenceIds.push(reader.int32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.sequenceIds.push(reader.int32());
            }
            continue;
          }
          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetConfigResultsBySequenceIdsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigResultsBySequenceIdsRequest();
    message.sequenceIds = ((_a = object.sequenceIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};
function createBaseConfigResultWithSequenceId() {
  return { sequenceId: 0, configResult: void 0 };
}
var ConfigResultWithSequenceId = {
  encode(message, writer = new BinaryWriter()) {
    if (message.sequenceId !== 0) {
      writer.uint32(8).int32(message.sequenceId);
    }
    if (message.configResult !== void 0) {
      ConfigResult.encode(message.configResult, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseConfigResultWithSequenceId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }
          message.sequenceId = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.configResult = ConfigResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ConfigResultWithSequenceId.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseConfigResultWithSequenceId();
    message.sequenceId = (_a = object.sequenceId) !== null && _a !== void 0 ? _a : 0;
    message.configResult = object.configResult !== void 0 && object.configResult !== null ? ConfigResult.fromPartial(object.configResult) : void 0;
    return message;
  }
};
function createBaseGetConfigResultsBySequenceIdsResponse() {
  return { configResultWithSequenceIds: [] };
}
var GetConfigResultsBySequenceIdsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.configResultWithSequenceIds) {
      ConfigResultWithSequenceId.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetConfigResultsBySequenceIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configResultWithSequenceIds.push(ConfigResultWithSequenceId.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetConfigResultsBySequenceIdsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetConfigResultsBySequenceIdsResponse();
    message.configResultWithSequenceIds = ((_a = object.configResultWithSequenceIds) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResultWithSequenceId.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseGetBitmapByTokenRequest() {
  return { token: "" };
}
var GetBitmapByTokenRequest = {
  encode(message, writer = new BinaryWriter()) {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBitmapByTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetBitmapByTokenRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetBitmapByTokenRequest();
    message.token = (_a = object.token) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseGetBitmapByTokenResponse() {
  return { idBitmap: new Uint8Array(0) };
}
var GetBitmapByTokenResponse = {
  encode(message, writer = new BinaryWriter()) {
    if (message.idBitmap.length !== 0) {
      writer.uint32(10).bytes(message.idBitmap);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetBitmapByTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.idBitmap = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetBitmapByTokenResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetBitmapByTokenResponse();
    message.idBitmap = (_a = object.idBitmap) !== null && _a !== void 0 ? _a : new Uint8Array(0);
    return message;
  }
};
function createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest() {
  return { namespaces: [], edgeConfigClientVersion: "" };
}
var GetUnevaluatedConfigResultsWithAbTargetingRequest = {
  encode(message, writer = new BinaryWriter()) {
    writer.uint32(10).fork();
    for (const v2 of message.namespaces) {
      writer.int32(v2);
    }
    writer.join();
    if (message.edgeConfigClientVersion !== "") {
      writer.uint32(18).string(message.edgeConfigClientVersion);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.namespaces.push(reader.int32());
            continue;
          }
          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.namespaces.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.edgeConfigClientVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetUnevaluatedConfigResultsWithAbTargetingRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingRequest();
    message.namespaces = ((_a = object.namespaces) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    message.edgeConfigClientVersion = (_b = object.edgeConfigClientVersion) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse() {
  return { configResults: [] };
}
var GetUnevaluatedConfigResultsWithAbTargetingResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.configResults) {
      ConfigResult.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.configResults.push(ConfigResult.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetUnevaluatedConfigResultsWithAbTargetingResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetUnevaluatedConfigResultsWithAbTargetingResponse();
    message.configResults = ((_a = object.configResults) === null || _a === void 0 ? void 0 : _a.map((e2) => ConfigResult.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseAddRuidsForDebuggingRequest() {
  return { ruids: [], configNames: [], maxSnapshots: 0 };
}
var AddRuidsForDebuggingRequest = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.ruids) {
      Ruid.encode(v2, writer.uint32(10).fork()).join();
    }
    for (const v2 of message.configNames) {
      writer.uint32(18).string(v2);
    }
    if (message.maxSnapshots !== 0) {
      writer.uint32(24).int32(message.maxSnapshots);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddRuidsForDebuggingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.ruids.push(Ruid.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.configNames.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.maxSnapshots = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return AddRuidsForDebuggingRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseAddRuidsForDebuggingRequest();
    message.ruids = ((_a = object.ruids) === null || _a === void 0 ? void 0 : _a.map((e2) => Ruid.fromPartial(e2))) || [];
    message.configNames = ((_b = object.configNames) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.maxSnapshots = (_c = object.maxSnapshots) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseAddRuidsForDebuggingResponse() {
  return {};
}
var AddRuidsForDebuggingResponse = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseAddRuidsForDebuggingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return AddRuidsForDebuggingResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseAddRuidsForDebuggingResponse();
    return message;
  }
};
var CircumstancesServiceClientImpl = class {
  constructor(rpc) {
    this.rpc = rpc;
    this.targetingQuery = this.targetingQuery.bind(this);
    this.getAbConfigValues = this.getAbConfigValues.bind(this);
    this.getConfigValuesByToken = this.getConfigValuesByToken.bind(this);
    this.getConfigResultsBySequenceIds = this.getConfigResultsBySequenceIds.bind(this);
    this.getCachedConfigResultSequenceIds = this.getCachedConfigResultSequenceIds.bind(this);
    this.getBitmapByToken = this.getBitmapByToken.bind(this);
    this.generateConfigSet = this.generateConfigSet.bind(this);
    this.pinConfigSet = this.pinConfigSet.bind(this);
    this.unpinConfigSet = this.unpinConfigSet.bind(this);
    this.getUnevaluatedConfigResultsWithAbTargeting = this.getUnevaluatedConfigResultsWithAbTargeting.bind(this);
    this.addRuidsForDebugging = this.addRuidsForDebugging.bind(this);
    this.pinTargetingProperties = this.pinTargetingProperties.bind(this);
    this.unpinTargetingProperties = this.unpinTargetingProperties.bind(this);
    this.getPinnedTargetingProperties = this.getPinnedTargetingProperties.bind(this);
  }
  targetingQuery(request, metadata) {
    return this.rpc.unary(CircumstancesServicetargetingQueryDesc, ConfigTargetingRequest.fromPartial(request), metadata);
  }
  getAbConfigValues(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetAbConfigValuesDesc, GetAbConfigValuesRequest.fromPartial(request), metadata);
  }
  getConfigValuesByToken(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetConfigValuesByTokenDesc, GetConfigValuesByTokenRequest.fromPartial(request), metadata);
  }
  getConfigResultsBySequenceIds(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetConfigResultsBySequenceIdsDesc, GetConfigResultsBySequenceIdsRequest.fromPartial(request), metadata);
  }
  getCachedConfigResultSequenceIds(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetCachedConfigResultSequenceIdsDesc, GetCachedConfigResultSequenceIdsRequest.fromPartial(request), metadata);
  }
  getBitmapByToken(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetBitmapByTokenDesc, GetBitmapByTokenRequest.fromPartial(request), metadata);
  }
  generateConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServicegenerateConfigSetDesc, ConfigSetGenerationRequest.fromPartial(request), metadata);
  }
  pinConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServicepinConfigSetDesc, PinConfigRequest.fromPartial(request), metadata);
  }
  unpinConfigSet(request, metadata) {
    return this.rpc.unary(CircumstancesServiceunpinConfigSetDesc, UnpinConfigRequest.fromPartial(request), metadata);
  }
  getUnevaluatedConfigResultsWithAbTargeting(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetUnevaluatedConfigResultsWithAbTargetingDesc, GetUnevaluatedConfigResultsWithAbTargetingRequest.fromPartial(request), metadata);
  }
  addRuidsForDebugging(request, metadata) {
    return this.rpc.unary(CircumstancesServiceaddRuidsForDebuggingDesc, AddRuidsForDebuggingRequest.fromPartial(request), metadata);
  }
  pinTargetingProperties(request, metadata) {
    return this.rpc.unary(CircumstancesServicepinTargetingPropertiesDesc, PinTargetingPropertiesRequest.fromPartial(request), metadata);
  }
  unpinTargetingProperties(request, metadata) {
    return this.rpc.unary(CircumstancesServiceunpinTargetingPropertiesDesc, UnpinTargetingPropertiesRequest.fromPartial(request), metadata);
  }
  getPinnedTargetingProperties(request, metadata) {
    return this.rpc.unary(CircumstancesServicegetPinnedTargetingPropertiesDesc, GetPinnedTargetingPropertiesRequest.fromPartial(request), metadata);
  }
};
var CircumstancesServiceDesc = { serviceName: "snapchat.cdp.cof.CircumstancesService" };
var CircumstancesServicetargetingQueryDesc = {
  methodName: "targetingQuery",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ConfigTargetingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = ConfigTargetingResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegetAbConfigValuesDesc = {
  methodName: "getAbConfigValues",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetAbConfigValuesRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = GetAbConfigValuesResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegetConfigValuesByTokenDesc = {
  methodName: "getConfigValuesByToken",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConfigValuesByTokenRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = GetConfigValuesByTokenResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegetConfigResultsBySequenceIdsDesc = {
  methodName: "getConfigResultsBySequenceIds",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetConfigResultsBySequenceIdsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = GetConfigResultsBySequenceIdsResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegetCachedConfigResultSequenceIdsDesc = {
  methodName: "getCachedConfigResultSequenceIds",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetCachedConfigResultSequenceIdsRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = GetCachedConfigResultSequenceIdsResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegetBitmapByTokenDesc = {
  methodName: "getBitmapByToken",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetBitmapByTokenRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = GetBitmapByTokenResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegenerateConfigSetDesc = {
  methodName: "generateConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return ConfigSetGenerationRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = ConfigSetGenerationResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicepinConfigSetDesc = {
  methodName: "pinConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PinConfigRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = PinConfigResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServiceunpinConfigSetDesc = {
  methodName: "unpinConfigSet",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnpinConfigRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = UnpinConfigResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegetUnevaluatedConfigResultsWithAbTargetingDesc = {
  methodName: "getUnevaluatedConfigResultsWithAbTargeting",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetUnevaluatedConfigResultsWithAbTargetingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = GetUnevaluatedConfigResultsWithAbTargetingResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServiceaddRuidsForDebuggingDesc = {
  methodName: "addRuidsForDebugging",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return AddRuidsForDebuggingRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = AddRuidsForDebuggingResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicepinTargetingPropertiesDesc = {
  methodName: "pinTargetingProperties",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return PinTargetingPropertiesRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = PinTargetingPropertiesResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServiceunpinTargetingPropertiesDesc = {
  methodName: "unpinTargetingProperties",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return UnpinTargetingPropertiesRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = UnpinTargetingPropertiesResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var CircumstancesServicegetPinnedTargetingPropertiesDesc = {
  methodName: "getPinnedTargetingProperties",
  service: CircumstancesServiceDesc,
  requestStream: false,
  responseStream: false,
  requestType: {
    serializeBinary() {
      return GetPinnedTargetingPropertiesRequest.encode(this).finish();
    }
  },
  responseType: {
    deserializeBinary(data) {
      const value = GetPinnedTargetingPropertiesResponse.decode(data);
      return Object.assign(Object.assign({}, value), { toObject() {
        return value;
      } });
    }
  }
};
var GrpcWebImpl = class {
  constructor(host, options) {
    this.host = host;
    this.options = options;
  }
  unary(methodDesc, _request, metadata) {
    var _a;
    const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);
    const maybeCombinedMetadata = metadata && this.options.metadata ? new import_browser_headers.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap)) : metadata !== null && metadata !== void 0 ? metadata : this.options.metadata;
    return new Promise((resolve, reject) => {
      var _a2;
      import_grpc_web2.grpc.unary(methodDesc, Object.assign(Object.assign({ request, host: this.host, metadata: maybeCombinedMetadata !== null && maybeCombinedMetadata !== void 0 ? maybeCombinedMetadata : {} }, this.options.transport !== void 0 ? { transport: this.options.transport } : {}), { debug: (_a2 = this.options.debug) !== null && _a2 !== void 0 ? _a2 : false, onEnd: function(response) {
        if (response.status === import_grpc_web2.grpc.Code.OK) {
          resolve(response.message.toObject());
        } else {
          const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
          reject(err);
        }
      } }));
    });
  }
};
var GrpcWebError = class extends globalThis.Error {
  constructor(message, code, metadata) {
    super(message);
    this.code = code;
    this.metadata = metadata;
  }
};

// node_modules/@snap/camera-kit/dist/handlers/responseCachingHandler.js
var logger3 = getLogger("responseCachingHandler");
var notFound = (key) => cacheKeyNotFoundError(`Response for key ${key} not found in cache.`);
var strategyFailed = (key, cause) => new Error(`Network request and cache lookup for key ${key} both failed.`, { cause });
var staleWhileRevalidateStrategy = (options) => (key, cache, network) => __awaiter(void 0, void 0, void 0, function* () {
  var _c, _d;
  try {
    const cachedResponse = yield cache.retrieve(key);
    if (!cachedResponse)
      throw notFound(key);
    network({ isSideEffect: true }).then((response) => cache.store(key, response)).catch((error) => {
      logger3.warn(`staleWhileRevalidateStrategy failed to retrieve and store key ${key}.`, error);
    });
    (_c = options === null || options === void 0 ? void 0 : options.onHit) === null || _c === void 0 ? void 0 : _c.call(options);
    return cachedResponse;
  } catch (cacheError) {
    (_d = options === null || options === void 0 ? void 0 : options.onMiss) === null || _d === void 0 ? void 0 : _d.call(options);
    try {
      const response = yield network();
      cache.store(key, response).catch((error) => {
        logger3.warn(`staleWhileRevalidateStrategy failed to store key ${key}.`, error);
      });
      logger3.debug(`staleWhileRevalidateStrategy successfully fell back to network for key ${key} after cache error.`, cacheError);
      return response;
    } catch (networkError) {
      const error = ensureError(networkError);
      error.cause = cacheError;
      throw strategyFailed(key, error);
    }
  }
});
var createResponseCachingHandler = (cache, resolveKey, strategy) => {
  return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    const network = (additionalMetadata = {}) => {
      const m2 = Object.assign(Object.assign({}, metadata), additionalMetadata);
      return next(request, m2);
    };
    let key;
    try {
      key = resolveKey(request, metadata);
    } catch (error) {
      logger3.warn("Cache lookup failed because the cache key could not be resolved.", error);
      return network();
    }
    return strategy(key, cache, network);
  });
};

// node_modules/@snap/camera-kit/dist/persistence/Persistence.js
var isValidKey = (key) => typeof key === "string" || typeof key === "number";

// node_modules/@snap/camera-kit/dist/persistence/IndexedDBPersistence.js
function wrapRequest(request) {
  const p2 = new Promise((resolve, reject) => {
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
  p2.request = request;
  return p2;
}
function wrapCursorRequest(request) {
  return new Promise((resolve, reject) => {
    request.onsuccess = () => {
      const cursor = request.result;
      if (!cursor)
        resolve({ cursor: null, continue: () => Promise.reject() });
      else
        resolve({
          cursor,
          continue: () => {
            cursor.continue();
            return wrapCursorRequest(request);
          }
        });
    };
    request.onerror = () => reject(request.error);
  });
}
var IndexedDBPersistence = class {
  constructor(options) {
    var _a;
    this.databaseName = `Snap.CameraKit.${options.databaseName}`;
    this.databaseVersion = options.databaseVersion;
    this.objectStore = (_a = options.objectStore) !== null && _a !== void 0 ? _a : options.databaseName;
    this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
    this.size = 0;
  }
  retrieve(key) {
    return this.simpleTransaction("readonly", (store) => store.get(key));
  }
  retrieveAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = [];
      const { store, done } = yield this.transaction("readonly");
      let request = yield wrapCursorRequest(store.openCursor());
      while (request.cursor) {
        results.push([request.cursor.primaryKey, request.cursor.value]);
        request = yield request.continue();
      }
      yield done;
      return results;
    });
  }
  remove(key) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.simpleTransaction("readwrite", (store) => store.delete(key));
      this.size--;
    });
  }
  removeAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = [];
      const { store, done } = yield this.transaction("readwrite");
      let request = yield wrapCursorRequest(store.openCursor());
      const deleteRequests = [];
      while (request.cursor) {
        results.push(request.cursor.value);
        deleteRequests.push(wrapRequest(store.delete(request.cursor.key)));
        request = yield request.continue();
      }
      yield Promise.all(deleteRequests.concat(done));
      this.size = 0;
      return results;
    });
  }
  store(keyOrValue, maybeValue) {
    return __awaiter(this, void 0, void 0, function* () {
      const [key, value] = maybeValue === void 0 ? [void 0, keyOrValue] : [keyOrValue, maybeValue];
      if (!isValidKey(key) && typeof key !== "undefined")
        throw new TypeError(`IndexedDBPersistence failed to store a value. Invalid key type: ${typeof key}`);
      const storedKey = yield this.simpleTransaction("readwrite", (store) => store.put(value, key));
      this.size++;
      return storedKey;
    });
  }
  openDatabase(request) {
    return __awaiter(this, void 0, void 0, function* () {
      const dbPromise = wrapRequest(request);
      dbPromise.request.onupgradeneeded = () => {
        try {
          dbPromise.request.result.createObjectStore(this.objectStore, { autoIncrement: true });
        } catch (error) {
          if (error instanceof DOMException && error.name === "ConstraintError")
            return;
          throw error;
        }
      };
      const db = yield dbPromise;
      db.onclose = () => {
        this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
      };
      return db;
    });
  }
  simpleTransaction(mode, operation) {
    return __awaiter(this, void 0, void 0, function* () {
      const { store, done } = yield this.transaction(mode);
      const [result] = yield Promise.all([wrapRequest(operation(store)), done]);
      return result;
    });
  }
  transaction(mode) {
    return __awaiter(this, void 0, void 0, function* () {
      const db = yield this.db;
      const tx = db.transaction(this.objectStore, mode);
      const store = tx.objectStore(this.objectStore);
      const done = new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.onabort = () => reject(new DOMException("The transaction was aborted", "AbortError"));
      });
      return { tx, store, done };
    });
  }
};

// node_modules/@snap/camera-kit/dist/persistence/ExpiringPersistence.js
var logger4 = getLogger("ExpiringPersistence");
var ExpiringPersistence = class {
  constructor(expiration, persistence) {
    this.expiration = expiration;
    this.persistence = persistence;
    this.removeExpired().catch((error) => {
      logger4.warn("Failed to cleanup expired entries on startup.", error);
    });
  }
  get size() {
    return this.persistence.size;
  }
  retrieve(key) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const [expiry, value] = (_a = yield this.persistence.retrieve(key)) !== null && _a !== void 0 ? _a : [];
      if (value === void 0 || expiry === void 0)
        return void 0;
      if (Date.now() > expiry) {
        yield this.persistence.remove(key).catch((error) => {
          logger4.warn(`Key ${key} is expired, but removing it from persistence failed.`, error);
        });
        return void 0;
      }
      return value;
    });
  }
  retrieveAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const now = Date.now();
      return (yield this.persistence.retrieveAll()).filter(([, [expiry]]) => expiry >= now).map(([, v2]) => v2);
    });
  }
  remove(key) {
    return this.persistence.remove(key);
  }
  removeAll() {
    return __awaiter(this, void 0, void 0, function* () {
      const results = yield this.persistence.removeAll();
      return results.map(([, v2]) => v2);
    });
  }
  removeExpired() {
    return __awaiter(this, void 0, void 0, function* () {
      for (const [key, [expiry]] of yield this.persistence.retrieveAll()) {
        if (Date.now() >= expiry) {
          yield this.persistence.remove(key).catch((error) => logger4.warn(`Failed to remove expired key ${key}.`, error));
        }
      }
    });
  }
  store(keyOrValue, maybeValue) {
    const [key, value] = maybeValue === void 0 ? [void 0, keyOrValue] : [keyOrValue, maybeValue];
    const expiry = Date.now() + this.expiration(value) * 1e3;
    return key === void 0 ? this.persistence.store([expiry, value]) : this.persistence.store(key, [expiry, value]);
  }
};

// node_modules/@snap/camera-kit/dist/common/pageVisibility.js
var PageVisibility = class {
  constructor() {
    this.onHiddenHandlers = /* @__PURE__ */ new Set();
    this.onVisibleHandlers = /* @__PURE__ */ new Set();
    this.previousVisibilityState = document.visibilityState;
    this.visibilityTransition = false;
    this.onVisibilityChange = this.onVisibilityChange.bind(this);
    this.isDuringVisibilityTransition = this.isDuringVisibilityTransition.bind(this);
    this.onPageHidden = this.onPageHidden.bind(this);
    this.onPageVisible = this.onPageVisible.bind(this);
    this.destroy = this.destroy.bind(this);
    document.addEventListener("visibilitychange", this.onVisibilityChange);
  }
  isDuringVisibilityTransition(test) {
    return test === this.visibilityTransition;
  }
  onPageHidden(handler) {
    this.onHiddenHandlers.add(handler);
    return () => this.onHiddenHandlers.delete(handler);
  }
  onPageVisible(handler) {
    this.onVisibleHandlers.add(handler);
    return () => this.onVisibleHandlers.delete(handler);
  }
  destroy() {
    document.removeEventListener("visibilitychange", this.onVisibilityChange);
    this.onHiddenHandlers.clear();
    this.onVisibleHandlers.clear();
  }
  onVisibilityChange() {
    const handlers = this.previousVisibilityState === "visible" && document.visibilityState === "hidden" ? this.onHiddenHandlers : this.previousVisibilityState === "hidden" && document.visibilityState === "visible" ? this.onVisibleHandlers : /* @__PURE__ */ new Set();
    this.visibilityTransition = document.visibilityState;
    for (const handler of handlers) {
      try {
        handler();
      } catch (error) {
        if (typeof window !== "undefined")
          window.dispatchEvent(new CustomEvent("error", { detail: error }));
      }
    }
    this.previousVisibilityState = this.visibilityTransition;
    this.visibilityTransition = false;
  }
};
var pageVisibilityFactory = Injectable("pageVisibility", () => new PageVisibility());

// node_modules/@snap/camera-kit/dist/generated-proto/blizzard/cameraKitEvents.js
var ServerEventBatch = {
  encode(message, writer = new BinaryWriter()) {
    if (message.serverUploadTs !== 0) {
      writer.uint32(9).double(message.serverUploadTs);
    }
    for (const v2 of message.serverAllUpdateEvents) {
      ServerRequestAllUpdates.encode(v2, writer.uint32(18).fork()).join();
    }
    if (message.maxSequenceIdOnInstance !== "0") {
      writer.uint32(24).uint64(message.maxSequenceIdOnInstance);
    }
    for (const v2 of message.serverEvents) {
      ServerEvent.encode(v2, writer.uint32(34).fork()).join();
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseServerEventBatch();
    message.serverUploadTs = (_a = object.serverUploadTs) !== null && _a !== void 0 ? _a : 0;
    message.serverAllUpdateEvents = ((_b = object.serverAllUpdateEvents) === null || _b === void 0 ? void 0 : _b.map((e2) => ServerRequestAllUpdates.fromPartial(e2))) || [];
    message.maxSequenceIdOnInstance = (_c = object.maxSequenceIdOnInstance) !== null && _c !== void 0 ? _c : "0";
    message.serverEvents = ((_d = object.serverEvents) === null || _d === void 0 ? void 0 : _d.map((e2) => ServerEvent.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseServerEventBatch() {
  return { serverUploadTs: 0, serverAllUpdateEvents: [], maxSequenceIdOnInstance: "0", serverEvents: [] };
}
var ServerRequestAllUpdates = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(_) {
    const message = createBaseServerRequestAllUpdates();
    return message;
  }
};
function createBaseServerRequestAllUpdates() {
  return {};
}
var ServerEvent = {
  encode(message, writer = new BinaryWriter()) {
    if (message.eventName !== "") {
      writer.uint32(10).string(message.eventName);
    }
    if (message.serverTs !== 0) {
      writer.uint32(25).double(message.serverTs);
    }
    if (message.userId !== "") {
      writer.uint32(34).string(message.userId);
    }
    if (message.userAgent !== "") {
      writer.uint32(42).string(message.userAgent);
    }
    if (message.country !== "") {
      writer.uint32(50).string(message.country);
    }
    if (message.city !== "") {
      writer.uint32(58).string(message.city);
    }
    if (message.region !== "") {
      writer.uint32(66).string(message.region);
    }
    if (message.eventId !== "") {
      writer.uint32(74).string(message.eventId);
    }
    if (message.instanceId !== "") {
      writer.uint32(82).string(message.instanceId);
    }
    if (message.sequenceId !== "0") {
      writer.uint32(88).uint64(message.sequenceId);
    }
    if (message.osType !== "") {
      writer.uint32(98).string(message.osType);
    }
    if (message.osVersion !== "") {
      writer.uint32(106).string(message.osVersion);
    }
    if (message.appVersion !== "") {
      writer.uint32(114).string(message.appVersion);
    }
    if (message.appBuild !== "") {
      writer.uint32(122).string(message.appBuild);
    }
    if (message.serverUploadTs !== 0) {
      writer.uint32(809).double(message.serverUploadTs);
    }
    if (message.eventTime !== 0) {
      writer.uint32(817).double(message.eventTime);
    }
    if (message.serverReceiptTime !== 0) {
      writer.uint32(825).double(message.serverReceiptTime);
    }
    if (message.maxSequenceIdOnInstance !== "0") {
      writer.uint32(832).uint64(message.maxSequenceIdOnInstance);
    }
    if (message.userGuid !== "") {
      writer.uint32(850).string(message.userGuid);
    }
    if (message.collection !== 0) {
      writer.uint32(872).int32(message.collection);
    }
    if (message.serviceId !== "") {
      writer.uint32(890).string(message.serviceId);
    }
    if (message.appType !== 0) {
      writer.uint32(912).int32(message.appType);
    }
    if (message.spectrumInstanceId !== "") {
      writer.uint32(930).string(message.spectrumInstanceId);
    }
    if (message.spectrumSequenceId !== "0") {
      writer.uint32(944).uint64(message.spectrumSequenceId);
    }
    if (message.eventData !== void 0) {
      ServerEventData.encode(message.eventData, writer.uint32(802).fork()).join();
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;
    const message = createBaseServerEvent();
    message.eventName = (_a = object.eventName) !== null && _a !== void 0 ? _a : "";
    message.serverTs = (_b = object.serverTs) !== null && _b !== void 0 ? _b : 0;
    message.userId = (_c = object.userId) !== null && _c !== void 0 ? _c : "";
    message.userAgent = (_d = object.userAgent) !== null && _d !== void 0 ? _d : "";
    message.country = (_e = object.country) !== null && _e !== void 0 ? _e : "";
    message.city = (_f = object.city) !== null && _f !== void 0 ? _f : "";
    message.region = (_g = object.region) !== null && _g !== void 0 ? _g : "";
    message.eventId = (_h = object.eventId) !== null && _h !== void 0 ? _h : "";
    message.instanceId = (_j = object.instanceId) !== null && _j !== void 0 ? _j : "";
    message.sequenceId = (_k = object.sequenceId) !== null && _k !== void 0 ? _k : "0";
    message.osType = (_l = object.osType) !== null && _l !== void 0 ? _l : "";
    message.osVersion = (_m = object.osVersion) !== null && _m !== void 0 ? _m : "";
    message.appVersion = (_o = object.appVersion) !== null && _o !== void 0 ? _o : "";
    message.appBuild = (_p = object.appBuild) !== null && _p !== void 0 ? _p : "";
    message.serverUploadTs = (_q = object.serverUploadTs) !== null && _q !== void 0 ? _q : 0;
    message.eventTime = (_r = object.eventTime) !== null && _r !== void 0 ? _r : 0;
    message.serverReceiptTime = (_s = object.serverReceiptTime) !== null && _s !== void 0 ? _s : 0;
    message.maxSequenceIdOnInstance = (_t = object.maxSequenceIdOnInstance) !== null && _t !== void 0 ? _t : "0";
    message.userGuid = (_u = object.userGuid) !== null && _u !== void 0 ? _u : "";
    message.collection = (_v = object.collection) !== null && _v !== void 0 ? _v : 0;
    message.serviceId = (_w = object.serviceId) !== null && _w !== void 0 ? _w : "";
    message.appType = (_x = object.appType) !== null && _x !== void 0 ? _x : 0;
    message.spectrumInstanceId = (_y = object.spectrumInstanceId) !== null && _y !== void 0 ? _y : "";
    message.spectrumSequenceId = (_z = object.spectrumSequenceId) !== null && _z !== void 0 ? _z : "0";
    message.eventData = object.eventData !== void 0 && object.eventData !== null ? ServerEventData.fromPartial(object.eventData) : void 0;
    return message;
  }
};
function createBaseServerEvent() {
  return {
    eventName: "",
    serverTs: 0,
    userId: "",
    userAgent: "",
    country: "",
    city: "",
    region: "",
    eventId: "",
    instanceId: "",
    sequenceId: "0",
    osType: "",
    osVersion: "",
    appVersion: "",
    appBuild: "",
    serverUploadTs: 0,
    eventTime: 0,
    serverReceiptTime: 0,
    maxSequenceIdOnInstance: "0",
    userGuid: "",
    collection: 0,
    serviceId: "",
    appType: 0,
    spectrumInstanceId: "",
    spectrumSequenceId: "0",
    eventData: void 0
  };
}
var ServerEventData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitException !== void 0) {
      CameraKitException.encode(message.cameraKitException, writer.uint32(1866).fork()).join();
    }
    if (message.cameraKitLensSpin !== void 0) {
      CameraKitLensSpin.encode(message.cameraKitLensSpin, writer.uint32(1874).fork()).join();
    }
    if (message.cameraKitAssetDownload !== void 0) {
      CameraKitAssetDownload.encode(message.cameraKitAssetDownload, writer.uint32(1882).fork()).join();
    }
    if (message.cameraKitLensContentValidationFailed !== void 0) {
      CameraKitLensContentValidationFailed.encode(message.cameraKitLensContentValidationFailed, writer.uint32(1922).fork()).join();
    }
    if (message.cameraKitLensDownload !== void 0) {
      CameraKitLensDownload.encode(message.cameraKitLensDownload, writer.uint32(1930).fork()).join();
    }
    if (message.cameraKitAssetValidationFailed !== void 0) {
      CameraKitAssetValidationFailed.encode(message.cameraKitAssetValidationFailed, writer.uint32(1938).fork()).join();
    }
    if (message.cameraKitSession !== void 0) {
      CameraKitSession.encode(message.cameraKitSession, writer.uint32(2130).fork()).join();
    }
    if (message.cameraKitWebLensSwipe !== void 0) {
      CameraKitWebLensSwipe.encode(message.cameraKitWebLensSwipe, writer.uint32(3818).fork()).join();
    }
    if (message.cameraKitWebBenchmarkComplete !== void 0) {
      CameraKitWebBenchmarkComplete.encode(message.cameraKitWebBenchmarkComplete, writer.uint32(3826).fork()).join();
    }
    if (message.cameraKitLegalPrompt !== void 0) {
      CameraKitLegalPrompt.encode(message.cameraKitLegalPrompt, writer.uint32(3874).fork()).join();
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    const message = createBaseServerEventData();
    message.cameraKitException = object.cameraKitException !== void 0 && object.cameraKitException !== null ? CameraKitException.fromPartial(object.cameraKitException) : void 0;
    message.cameraKitLensSpin = object.cameraKitLensSpin !== void 0 && object.cameraKitLensSpin !== null ? CameraKitLensSpin.fromPartial(object.cameraKitLensSpin) : void 0;
    message.cameraKitAssetDownload = object.cameraKitAssetDownload !== void 0 && object.cameraKitAssetDownload !== null ? CameraKitAssetDownload.fromPartial(object.cameraKitAssetDownload) : void 0;
    message.cameraKitLensContentValidationFailed = object.cameraKitLensContentValidationFailed !== void 0 && object.cameraKitLensContentValidationFailed !== null ? CameraKitLensContentValidationFailed.fromPartial(object.cameraKitLensContentValidationFailed) : void 0;
    message.cameraKitLensDownload = object.cameraKitLensDownload !== void 0 && object.cameraKitLensDownload !== null ? CameraKitLensDownload.fromPartial(object.cameraKitLensDownload) : void 0;
    message.cameraKitAssetValidationFailed = object.cameraKitAssetValidationFailed !== void 0 && object.cameraKitAssetValidationFailed !== null ? CameraKitAssetValidationFailed.fromPartial(object.cameraKitAssetValidationFailed) : void 0;
    message.cameraKitSession = object.cameraKitSession !== void 0 && object.cameraKitSession !== null ? CameraKitSession.fromPartial(object.cameraKitSession) : void 0;
    message.cameraKitWebLensSwipe = object.cameraKitWebLensSwipe !== void 0 && object.cameraKitWebLensSwipe !== null ? CameraKitWebLensSwipe.fromPartial(object.cameraKitWebLensSwipe) : void 0;
    message.cameraKitWebBenchmarkComplete = object.cameraKitWebBenchmarkComplete !== void 0 && object.cameraKitWebBenchmarkComplete !== null ? CameraKitWebBenchmarkComplete.fromPartial(object.cameraKitWebBenchmarkComplete) : void 0;
    message.cameraKitLegalPrompt = object.cameraKitLegalPrompt !== void 0 && object.cameraKitLegalPrompt !== null ? CameraKitLegalPrompt.fromPartial(object.cameraKitLegalPrompt) : void 0;
    return message;
  }
};
function createBaseServerEventData() {
  return {
    cameraKitException: void 0,
    cameraKitLensSpin: void 0,
    cameraKitAssetDownload: void 0,
    cameraKitLensContentValidationFailed: void 0,
    cameraKitLensDownload: void 0,
    cameraKitAssetValidationFailed: void 0,
    cameraKitSession: void 0,
    cameraKitWebLensSwipe: void 0,
    cameraKitWebBenchmarkComplete: void 0,
    cameraKitLegalPrompt: void 0
  };
}
var AppType;
(function(AppType2) {
  AppType2[AppType2["IOS_NATIVE"] = 0] = "IOS_NATIVE";
  AppType2[AppType2["IOS_WEB_DESKTOP"] = 1] = "IOS_WEB_DESKTOP";
  AppType2[AppType2["IOS_WEB_MOBILE"] = 2] = "IOS_WEB_MOBILE";
  AppType2[AppType2["ANDROID_NATIVE"] = 3] = "ANDROID_NATIVE";
  AppType2[AppType2["ANDROID_WEB_DESKTOP"] = 4] = "ANDROID_WEB_DESKTOP";
  AppType2[AppType2["ANDROID_WEB_MOBILE"] = 5] = "ANDROID_WEB_MOBILE";
  AppType2[AppType2["OSX_WEB_DESKTOP"] = 6] = "OSX_WEB_DESKTOP";
  AppType2[AppType2["OSX_WEB_MOBILE"] = 7] = "OSX_WEB_MOBILE";
  AppType2[AppType2["WINDOWS_WEB_DESKTOP"] = 8] = "WINDOWS_WEB_DESKTOP";
  AppType2[AppType2["WINDOWS_WEB_MOBILE"] = 9] = "WINDOWS_WEB_MOBILE";
  AppType2[AppType2["LINUX_WEB_DESKTOP"] = 10] = "LINUX_WEB_DESKTOP";
  AppType2[AppType2["LINUX_WEB_MOBILE"] = 11] = "LINUX_WEB_MOBILE";
  AppType2[AppType2["LENSSTUDIO"] = 12] = "LENSSTUDIO";
  AppType2[AppType2["SNAPCAMERA"] = 13] = "SNAPCAMERA";
  AppType2[AppType2["WEB_DESKTOP"] = 14] = "WEB_DESKTOP";
  AppType2[AppType2["WEB_MOBILE"] = 15] = "WEB_MOBILE";
  AppType2[AppType2["LENSSTUDIO_REMAKE"] = 16] = "LENSSTUDIO_REMAKE";
  AppType2[AppType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(AppType || (AppType = {}));
var Collection;
(function(Collection2) {
  Collection2[Collection2["COLLECTION_UNUSED"] = 0] = "COLLECTION_UNUSED";
  Collection2[Collection2["GAE"] = 1] = "GAE";
  Collection2[Collection2["GCE_M"] = 2] = "GCE_M";
  Collection2[Collection2["GCE_S"] = 3] = "GCE_S";
  Collection2[Collection2["GCE_T"] = 4] = "GCE_T";
  Collection2[Collection2["GKE_M"] = 5] = "GKE_M";
  Collection2[Collection2["GKE_S"] = 6] = "GKE_S";
  Collection2[Collection2["GKE_T"] = 7] = "GKE_T";
  Collection2[Collection2["LOCAL"] = 8] = "LOCAL";
  Collection2[Collection2["GCE_ST"] = 9] = "GCE_ST";
  Collection2[Collection2["GKE_ST"] = 10] = "GKE_ST";
  Collection2[Collection2["GCE_C"] = 11] = "GCE_C";
  Collection2[Collection2["GCE_SC"] = 12] = "GCE_SC";
  Collection2[Collection2["GCE_TC"] = 13] = "GCE_TC";
  Collection2[Collection2["GCE_TSC"] = 14] = "GCE_TSC";
  Collection2[Collection2["GKE_C"] = 15] = "GKE_C";
  Collection2[Collection2["GKE_SC"] = 16] = "GKE_SC";
  Collection2[Collection2["GKE_TC"] = 17] = "GKE_TC";
  Collection2[Collection2["GKE_TSC"] = 18] = "GKE_TSC";
  Collection2[Collection2["GKE_W"] = 19] = "GKE_W";
  Collection2[Collection2["GKE_WT"] = 20] = "GKE_WT";
  Collection2[Collection2["GKE_WC"] = 21] = "GKE_WC";
  Collection2[Collection2["GKE_WSC"] = 22] = "GKE_WSC";
  Collection2[Collection2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Collection || (Collection = {}));
var CameraKitLensSpin = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    if (message.viewTimeSec !== 0) {
      writer.uint32(25).double(message.viewTimeSec);
    }
    if (message.lensGroupId !== "") {
      writer.uint32(34).string(message.lensGroupId);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseCameraKitLensSpin();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.viewTimeSec = (_b = object.viewTimeSec) !== null && _b !== void 0 ? _b : 0;
    message.lensGroupId = (_c = object.lensGroupId) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseCameraKitLensSpin() {
  return { cameraKitEventBase: void 0, lensId: "", viewTimeSec: 0, lensGroupId: "" };
}
var CameraKitWebLensSwipe = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.performanceCluster !== "0") {
      writer.uint32(16).uint64(message.performanceCluster);
    }
    if (message.webglRendererInfo !== "") {
      writer.uint32(26).string(message.webglRendererInfo);
    }
    if (message.lensId !== "") {
      writer.uint32(34).string(message.lensId);
    }
    if (message.lensFrameProcessingTimeMsAvg !== 0) {
      writer.uint32(41).double(message.lensFrameProcessingTimeMsAvg);
    }
    if (message.lensFrameProcessingTimeMsStd !== 0) {
      writer.uint32(49).double(message.lensFrameProcessingTimeMsStd);
    }
    if (message.viewTimeSec !== 0) {
      writer.uint32(57).double(message.viewTimeSec);
    }
    if (message.recordingTimeSec !== 0) {
      writer.uint32(65).double(message.recordingTimeSec);
    }
    if (message.applyDelaySec !== 0) {
      writer.uint32(73).double(message.applyDelaySec);
    }
    if (message.avgFps !== 0) {
      writer.uint32(81).double(message.avgFps);
    }
    if (message.isLensFirstWithinDay !== false) {
      writer.uint32(88).bool(message.isLensFirstWithinDay);
    }
    if (message.isLensFirstWithinMonth !== false) {
      writer.uint32(96).bool(message.isLensFirstWithinMonth);
    }
    if (message.lensGroupId !== "") {
      writer.uint32(106).string(message.lensGroupId);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const message = createBaseCameraKitWebLensSwipe();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.performanceCluster = (_a = object.performanceCluster) !== null && _a !== void 0 ? _a : "0";
    message.webglRendererInfo = (_b = object.webglRendererInfo) !== null && _b !== void 0 ? _b : "";
    message.lensId = (_c = object.lensId) !== null && _c !== void 0 ? _c : "";
    message.lensFrameProcessingTimeMsAvg = (_d = object.lensFrameProcessingTimeMsAvg) !== null && _d !== void 0 ? _d : 0;
    message.lensFrameProcessingTimeMsStd = (_e = object.lensFrameProcessingTimeMsStd) !== null && _e !== void 0 ? _e : 0;
    message.viewTimeSec = (_f = object.viewTimeSec) !== null && _f !== void 0 ? _f : 0;
    message.recordingTimeSec = (_g = object.recordingTimeSec) !== null && _g !== void 0 ? _g : 0;
    message.applyDelaySec = (_h = object.applyDelaySec) !== null && _h !== void 0 ? _h : 0;
    message.avgFps = (_j = object.avgFps) !== null && _j !== void 0 ? _j : 0;
    message.isLensFirstWithinDay = (_k = object.isLensFirstWithinDay) !== null && _k !== void 0 ? _k : false;
    message.isLensFirstWithinMonth = (_l = object.isLensFirstWithinMonth) !== null && _l !== void 0 ? _l : false;
    message.lensGroupId = (_m = object.lensGroupId) !== null && _m !== void 0 ? _m : "";
    return message;
  }
};
function createBaseCameraKitWebLensSwipe() {
  return {
    cameraKitEventBase: void 0,
    performanceCluster: "0",
    webglRendererInfo: "",
    lensId: "",
    lensFrameProcessingTimeMsAvg: 0,
    lensFrameProcessingTimeMsStd: 0,
    viewTimeSec: 0,
    recordingTimeSec: 0,
    applyDelaySec: 0,
    avgFps: 0,
    isLensFirstWithinDay: false,
    isLensFirstWithinMonth: false,
    lensGroupId: ""
  };
}
var CameraKitLensDownload = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    if (message.automaticDownload !== false) {
      writer.uint32(24).bool(message.automaticDownload);
    }
    if (message.downloadTimeSec !== 0) {
      writer.uint32(33).double(message.downloadTimeSec);
    }
    if (message.sizeByte !== "0") {
      writer.uint32(40).uint64(message.sizeByte);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitLensDownload();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.automaticDownload = (_b = object.automaticDownload) !== null && _b !== void 0 ? _b : false;
    message.downloadTimeSec = (_c = object.downloadTimeSec) !== null && _c !== void 0 ? _c : 0;
    message.sizeByte = (_d = object.sizeByte) !== null && _d !== void 0 ? _d : "0";
    return message;
  }
};
function createBaseCameraKitLensDownload() {
  return { cameraKitEventBase: void 0, lensId: "", automaticDownload: false, downloadTimeSec: 0, sizeByte: "0" };
}
var CameraKitAssetDownload = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.automaticDownload !== false) {
      writer.uint32(24).bool(message.automaticDownload);
    }
    if (message.downloadTimeSec !== 0) {
      writer.uint32(33).double(message.downloadTimeSec);
    }
    if (message.sizeByte !== "0") {
      writer.uint32(40).uint64(message.sizeByte);
    }
    if (message.assetId !== "") {
      writer.uint32(50).string(message.assetId);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitAssetDownload();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.automaticDownload = (_a = object.automaticDownload) !== null && _a !== void 0 ? _a : false;
    message.downloadTimeSec = (_b = object.downloadTimeSec) !== null && _b !== void 0 ? _b : 0;
    message.sizeByte = (_c = object.sizeByte) !== null && _c !== void 0 ? _c : "0";
    message.assetId = (_d = object.assetId) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseCameraKitAssetDownload() {
  return { cameraKitEventBase: void 0, automaticDownload: false, downloadTimeSec: 0, sizeByte: "0", assetId: "" };
}
var CameraKitException = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseCameraKitException();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    message.type = (_b = object.type) !== null && _b !== void 0 ? _b : "";
    message.reason = (_c = object.reason) !== null && _c !== void 0 ? _c : "";
    return message;
  }
};
function createBaseCameraKitException() {
  return { cameraKitEventBase: void 0, lensId: "", type: "", reason: "" };
}
var CameraKitSession = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.dailySessionBucket !== 0) {
      writer.uint32(16).int32(message.dailySessionBucket);
    }
    if (message.isFirstWithinMonth !== false) {
      writer.uint32(24).bool(message.isFirstWithinMonth);
    }
    if (message.day !== "0") {
      writer.uint32(32).uint64(message.day);
    }
    if (message.month !== "0") {
      writer.uint32(40).uint64(message.month);
    }
    if (message.year !== "0") {
      writer.uint32(48).uint64(message.year);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseCameraKitSession();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.dailySessionBucket = (_a = object.dailySessionBucket) !== null && _a !== void 0 ? _a : 0;
    message.isFirstWithinMonth = (_b = object.isFirstWithinMonth) !== null && _b !== void 0 ? _b : false;
    message.day = (_c = object.day) !== null && _c !== void 0 ? _c : "0";
    message.month = (_d = object.month) !== null && _d !== void 0 ? _d : "0";
    message.year = (_e = object.year) !== null && _e !== void 0 ? _e : "0";
    return message;
  }
};
function createBaseCameraKitSession() {
  return {
    cameraKitEventBase: void 0,
    dailySessionBucket: 0,
    isFirstWithinMonth: false,
    day: "0",
    month: "0",
    year: "0"
  };
}
var DailySessionBucket;
(function(DailySessionBucket2) {
  DailySessionBucket2[DailySessionBucket2["NO_SESSION_BUCKET"] = 0] = "NO_SESSION_BUCKET";
  DailySessionBucket2[DailySessionBucket2["ONE_SESSION"] = 1] = "ONE_SESSION";
  DailySessionBucket2[DailySessionBucket2["TWO_SESSION"] = 2] = "TWO_SESSION";
  DailySessionBucket2[DailySessionBucket2["THREE_SESSION"] = 3] = "THREE_SESSION";
  DailySessionBucket2[DailySessionBucket2["FOUR_SESSION"] = 4] = "FOUR_SESSION";
  DailySessionBucket2[DailySessionBucket2["FIVE_SESSION"] = 5] = "FIVE_SESSION";
  DailySessionBucket2[DailySessionBucket2["SIX_SESSION"] = 6] = "SIX_SESSION";
  DailySessionBucket2[DailySessionBucket2["SEVEN_SESSION"] = 7] = "SEVEN_SESSION";
  DailySessionBucket2[DailySessionBucket2["EIGHT_SESSION"] = 8] = "EIGHT_SESSION";
  DailySessionBucket2[DailySessionBucket2["NINE_SESSION"] = 9] = "NINE_SESSION";
  DailySessionBucket2[DailySessionBucket2["TEN_OR_MORE_SESSION"] = 10] = "TEN_OR_MORE_SESSION";
  DailySessionBucket2[DailySessionBucket2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(DailySessionBucket || (DailySessionBucket = {}));
var CameraKitLensContentValidationFailed = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.lensId !== "") {
      writer.uint32(18).string(message.lensId);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a;
    const message = createBaseCameraKitLensContentValidationFailed();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.lensId = (_a = object.lensId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseCameraKitLensContentValidationFailed() {
  return { cameraKitEventBase: void 0, lensId: "" };
}
var CameraKitAssetValidationFailed = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.assetId !== "") {
      writer.uint32(26).string(message.assetId);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a;
    const message = createBaseCameraKitAssetValidationFailed();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.assetId = (_a = object.assetId) !== null && _a !== void 0 ? _a : "";
    return message;
  }
};
function createBaseCameraKitAssetValidationFailed() {
  return { cameraKitEventBase: void 0, assetId: "" };
}
var CameraKitWebBenchmarkComplete = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.benchmarkName !== "") {
      writer.uint32(18).string(message.benchmarkName);
    }
    if (message.benchmarkValue !== 0) {
      writer.uint32(25).double(message.benchmarkValue);
    }
    if (message.performanceCluster !== "0") {
      writer.uint32(32).uint64(message.performanceCluster);
    }
    if (message.webglRendererInfo !== "") {
      writer.uint32(42).string(message.webglRendererInfo);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseCameraKitWebBenchmarkComplete();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.benchmarkName = (_a = object.benchmarkName) !== null && _a !== void 0 ? _a : "";
    message.benchmarkValue = (_b = object.benchmarkValue) !== null && _b !== void 0 ? _b : 0;
    message.performanceCluster = (_c = object.performanceCluster) !== null && _c !== void 0 ? _c : "0";
    message.webglRendererInfo = (_d = object.webglRendererInfo) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseCameraKitWebBenchmarkComplete() {
  return {
    cameraKitEventBase: void 0,
    benchmarkName: "",
    benchmarkValue: 0,
    performanceCluster: "0",
    webglRendererInfo: ""
  };
}
var CameraKitLegalPrompt = {
  encode(message, writer = new BinaryWriter()) {
    if (message.cameraKitEventBase !== void 0) {
      CameraKitEventBase.encode(message.cameraKitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.legalPromptId !== "") {
      writer.uint32(18).string(message.legalPromptId);
    }
    if (message.legalPromptResult !== 0) {
      writer.uint32(24).int32(message.legalPromptResult);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseCameraKitLegalPrompt();
    message.cameraKitEventBase = object.cameraKitEventBase !== void 0 && object.cameraKitEventBase !== null ? CameraKitEventBase.fromPartial(object.cameraKitEventBase) : void 0;
    message.legalPromptId = (_a = object.legalPromptId) !== null && _a !== void 0 ? _a : "";
    message.legalPromptResult = (_b = object.legalPromptResult) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};
function createBaseCameraKitLegalPrompt() {
  return { cameraKitEventBase: void 0, legalPromptId: "", legalPromptResult: 0 };
}
var CameraKitEventBase = {
  encode(message, writer = new BinaryWriter()) {
    if (message.kitEventBase !== void 0) {
      KitEventBase.encode(message.kitEventBase, writer.uint32(10).fork()).join();
    }
    if (message.deviceCluster !== "0") {
      writer.uint32(16).uint64(message.deviceCluster);
    }
    if (message.cameraKitVersion !== "") {
      writer.uint32(26).string(message.cameraKitVersion);
    }
    if (message.lensCoreVersion !== "") {
      writer.uint32(34).string(message.lensCoreVersion);
    }
    if (message.deviceModel !== "") {
      writer.uint32(42).string(message.deviceModel);
    }
    if (message.cameraKitVariant !== 0) {
      writer.uint32(48).int32(message.cameraKitVariant);
    }
    if (message.cameraKitFlavor !== 0) {
      writer.uint32(56).int32(message.cameraKitFlavor);
    }
    if (message.appId !== "") {
      writer.uint32(66).string(message.appId);
    }
    if (message.deviceConnectivity !== 0) {
      writer.uint32(72).int32(message.deviceConnectivity);
    }
    if (message.sessionId !== "") {
      writer.uint32(82).string(message.sessionId);
    }
    if (message.appVendorUuid !== "") {
      writer.uint32(90).string(message.appVendorUuid);
    }
    if (message.rankingRequestId !== "") {
      writer.uint32(98).string(message.rankingRequestId);
    }
    if (message.cameraKitEnvironment !== 0) {
      writer.uint32(104).int32(message.cameraKitEnvironment);
    }
    if (message.partnerUuid !== "") {
      writer.uint32(114).string(message.partnerUuid);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    const message = createBaseCameraKitEventBase();
    message.kitEventBase = object.kitEventBase !== void 0 && object.kitEventBase !== null ? KitEventBase.fromPartial(object.kitEventBase) : void 0;
    message.deviceCluster = (_a = object.deviceCluster) !== null && _a !== void 0 ? _a : "0";
    message.cameraKitVersion = (_b = object.cameraKitVersion) !== null && _b !== void 0 ? _b : "";
    message.lensCoreVersion = (_c = object.lensCoreVersion) !== null && _c !== void 0 ? _c : "";
    message.deviceModel = (_d = object.deviceModel) !== null && _d !== void 0 ? _d : "";
    message.cameraKitVariant = (_e = object.cameraKitVariant) !== null && _e !== void 0 ? _e : 0;
    message.cameraKitFlavor = (_f = object.cameraKitFlavor) !== null && _f !== void 0 ? _f : 0;
    message.appId = (_g = object.appId) !== null && _g !== void 0 ? _g : "";
    message.deviceConnectivity = (_h = object.deviceConnectivity) !== null && _h !== void 0 ? _h : 0;
    message.sessionId = (_j = object.sessionId) !== null && _j !== void 0 ? _j : "";
    message.appVendorUuid = (_k = object.appVendorUuid) !== null && _k !== void 0 ? _k : "";
    message.rankingRequestId = (_l = object.rankingRequestId) !== null && _l !== void 0 ? _l : "";
    message.cameraKitEnvironment = (_m = object.cameraKitEnvironment) !== null && _m !== void 0 ? _m : 0;
    message.partnerUuid = (_o = object.partnerUuid) !== null && _o !== void 0 ? _o : "";
    return message;
  }
};
function createBaseCameraKitEventBase() {
  return {
    kitEventBase: void 0,
    deviceCluster: "0",
    cameraKitVersion: "",
    lensCoreVersion: "",
    deviceModel: "",
    cameraKitVariant: 0,
    cameraKitFlavor: 0,
    appId: "",
    deviceConnectivity: 0,
    sessionId: "",
    appVendorUuid: "",
    rankingRequestId: "",
    cameraKitEnvironment: 0,
    partnerUuid: ""
  };
}
var KitEventBase = {
  encode(message, writer = new BinaryWriter()) {
    if (message.oauthClientId !== "") {
      writer.uint32(10).string(message.oauthClientId);
    }
    if (message.locale !== "") {
      writer.uint32(18).string(message.locale);
    }
    if (message.kitUserAgent !== "") {
      writer.uint32(26).string(message.kitUserAgent);
    }
    if (message.ipAddress !== "") {
      writer.uint32(34).string(message.ipAddress);
    }
    if (message.osMinorVersion !== "") {
      writer.uint32(42).string(message.osMinorVersion);
    }
    if (message.kitVariant !== 0) {
      writer.uint32(48).int32(message.kitVariant);
    }
    if (message.kitVariantVersion !== "") {
      writer.uint32(58).string(message.kitVariantVersion);
    }
    if (message.kitClientTimestampMillis !== "0") {
      writer.uint32(64).uint64(message.kitClientTimestampMillis);
    }
    if (message.clientSequenceId !== "0") {
      writer.uint32(72).uint64(message.clientSequenceId);
    }
    if (message.maxClientSequenceIdOnInstance !== "0") {
      writer.uint32(80).uint64(message.maxClientSequenceIdOnInstance);
    }
    if (message.targetArchitecture !== "") {
      writer.uint32(90).string(message.targetArchitecture);
    }
    if (message.runningWithDebuggerAttached !== false) {
      writer.uint32(96).bool(message.runningWithDebuggerAttached);
    }
    if (message.runningInTests !== false) {
      writer.uint32(104).bool(message.runningInTests);
    }
    if (message.runningInSimulator !== false) {
      writer.uint32(112).bool(message.runningInSimulator);
    }
    if (message.isAppPrerelease !== false) {
      writer.uint32(120).bool(message.isAppPrerelease);
    }
    if (message.kitAppId !== "") {
      writer.uint32(130).string(message.kitAppId);
    }
    if (message.kitSessionId !== "") {
      writer.uint32(138).string(message.kitSessionId);
    }
    if (message.kitPluginType !== 0) {
      writer.uint32(144).int32(message.kitPluginType);
    }
    if (message.isFromReactNativePlugin !== false) {
      writer.uint32(152).bool(message.isFromReactNativePlugin);
    }
    return writer;
  },
  decode() {
    throw new Error("Not implemented.");
  },
  fromJSON() {
    throw new Error("Not implemented.");
  },
  toJSON() {
    throw new Error("Not implemented.");
  },
  create() {
    throw new Error("Not implemented.");
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const message = createBaseKitEventBase();
    message.oauthClientId = (_a = object.oauthClientId) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    message.kitUserAgent = (_c = object.kitUserAgent) !== null && _c !== void 0 ? _c : "";
    message.ipAddress = (_d = object.ipAddress) !== null && _d !== void 0 ? _d : "";
    message.osMinorVersion = (_e = object.osMinorVersion) !== null && _e !== void 0 ? _e : "";
    message.kitVariant = (_f = object.kitVariant) !== null && _f !== void 0 ? _f : 0;
    message.kitVariantVersion = (_g = object.kitVariantVersion) !== null && _g !== void 0 ? _g : "";
    message.kitClientTimestampMillis = (_h = object.kitClientTimestampMillis) !== null && _h !== void 0 ? _h : "0";
    message.clientSequenceId = (_j = object.clientSequenceId) !== null && _j !== void 0 ? _j : "0";
    message.maxClientSequenceIdOnInstance = (_k = object.maxClientSequenceIdOnInstance) !== null && _k !== void 0 ? _k : "0";
    message.targetArchitecture = (_l = object.targetArchitecture) !== null && _l !== void 0 ? _l : "";
    message.runningWithDebuggerAttached = (_m = object.runningWithDebuggerAttached) !== null && _m !== void 0 ? _m : false;
    message.runningInTests = (_o = object.runningInTests) !== null && _o !== void 0 ? _o : false;
    message.runningInSimulator = (_p = object.runningInSimulator) !== null && _p !== void 0 ? _p : false;
    message.isAppPrerelease = (_q = object.isAppPrerelease) !== null && _q !== void 0 ? _q : false;
    message.kitAppId = (_r = object.kitAppId) !== null && _r !== void 0 ? _r : "";
    message.kitSessionId = (_s = object.kitSessionId) !== null && _s !== void 0 ? _s : "";
    message.kitPluginType = (_t = object.kitPluginType) !== null && _t !== void 0 ? _t : 0;
    message.isFromReactNativePlugin = (_u = object.isFromReactNativePlugin) !== null && _u !== void 0 ? _u : false;
    return message;
  }
};
function createBaseKitEventBase() {
  return {
    oauthClientId: "",
    locale: "",
    kitUserAgent: "",
    ipAddress: "",
    osMinorVersion: "",
    kitVariant: 0,
    kitVariantVersion: "",
    kitClientTimestampMillis: "0",
    clientSequenceId: "0",
    maxClientSequenceIdOnInstance: "0",
    targetArchitecture: "",
    runningWithDebuggerAttached: false,
    runningInTests: false,
    runningInSimulator: false,
    isAppPrerelease: false,
    kitAppId: "",
    kitSessionId: "",
    kitPluginType: 0,
    isFromReactNativePlugin: false
  };
}
var CameraKitLegalPromptResult;
(function(CameraKitLegalPromptResult2) {
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_MISSING"] = 0] = "CAMERA_KIT_LEGAL_PROMPT_MISSING";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_ACCEPTED"] = 1] = "CAMERA_KIT_LEGAL_PROMPT_ACCEPTED";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["CAMERA_KIT_LEGAL_PROMPT_DISMISSED"] = 2] = "CAMERA_KIT_LEGAL_PROMPT_DISMISSED";
  CameraKitLegalPromptResult2[CameraKitLegalPromptResult2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitLegalPromptResult || (CameraKitLegalPromptResult = {}));
var CameraKitEnvironment2;
(function(CameraKitEnvironment3) {
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_UNKNOWN"] = 0] = "CAMERA_KIT_ENVIRONMENT_UNKNOWN";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_STAGING"] = 1] = "CAMERA_KIT_ENVIRONMENT_STAGING";
  CameraKitEnvironment3[CameraKitEnvironment3["CAMERA_KIT_ENVIRONMENT_PRODUCTION"] = 2] = "CAMERA_KIT_ENVIRONMENT_PRODUCTION";
  CameraKitEnvironment3[CameraKitEnvironment3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitEnvironment2 || (CameraKitEnvironment2 = {}));
var CameraKitConnectivityType2;
(function(CameraKitConnectivityType3) {
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN"] = 0] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_WIFI"] = 1] = "CAMERA_KIT_CONNECTIVITY_TYPE_WIFI";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE"] = 2] = "CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE"] = 3] = "CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE";
  CameraKitConnectivityType3[CameraKitConnectivityType3["CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH"] = 4] = "CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH";
  CameraKitConnectivityType3[CameraKitConnectivityType3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitConnectivityType2 || (CameraKitConnectivityType2 = {}));
var CameraKitFlavor2;
(function(CameraKitFlavor3) {
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_UNKNOWN"] = 0] = "CAMERA_KIT_FLAVOR_UNKNOWN";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_DEBUG"] = 1] = "CAMERA_KIT_FLAVOR_DEBUG";
  CameraKitFlavor3[CameraKitFlavor3["CAMERA_KIT_FLAVOR_RELEASE"] = 2] = "CAMERA_KIT_FLAVOR_RELEASE";
  CameraKitFlavor3[CameraKitFlavor3["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitFlavor2 || (CameraKitFlavor2 = {}));
var CameraKitVariant;
(function(CameraKitVariant2) {
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_UNKNOWN"] = 0] = "CAMERA_KIT_VARIANT_UNKNOWN";
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_PARTNER"] = 1] = "CAMERA_KIT_VARIANT_PARTNER";
  CameraKitVariant2[CameraKitVariant2["CAMERA_KIT_VARIANT_PUBLIC"] = 2] = "CAMERA_KIT_VARIANT_PUBLIC";
  CameraKitVariant2[CameraKitVariant2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CameraKitVariant || (CameraKitVariant = {}));
var KitPluginType;
(function(KitPluginType2) {
  KitPluginType2[KitPluginType2["NO_PLUGIN"] = 0] = "NO_PLUGIN";
  KitPluginType2[KitPluginType2["UNITY"] = 1] = "UNITY";
  KitPluginType2[KitPluginType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KitPluginType || (KitPluginType = {}));
var KitType;
(function(KitType2) {
  KitType2[KitType2["UNKNOWN_KIT_TYPE"] = 0] = "UNKNOWN_KIT_TYPE";
  KitType2[KitType2["BITMOJI_KIT"] = 1] = "BITMOJI_KIT";
  KitType2[KitType2["CREATIVE_KIT"] = 2] = "CREATIVE_KIT";
  KitType2[KitType2["LOGIN_KIT"] = 3] = "LOGIN_KIT";
  KitType2[KitType2["STORY_KIT"] = 4] = "STORY_KIT";
  KitType2[KitType2["CAMERA_KIT"] = 5] = "CAMERA_KIT";
  KitType2[KitType2["SHOP_KIT"] = 6] = "SHOP_KIT";
  KitType2[KitType2["EULA_KIT"] = 7] = "EULA_KIT";
  KitType2[KitType2["PAYMENTS_KIT"] = 8] = "PAYMENTS_KIT";
  KitType2[KitType2["INVITE_KIT"] = 9] = "INVITE_KIT";
  KitType2[KitType2["CAMERA_KIT_WEB"] = 10] = "CAMERA_KIT_WEB";
  KitType2[KitType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(KitType || (KitType = {}));

// node_modules/@snap/camera-kit/dist/handlers/mappingHandler.js
var createMappingHandler = (map2, pageVisibility, maxMapConcurrency = Number.POSITIVE_INFINITY) => {
  const buffer2 = [];
  let mapConcurrency = 0;
  const processRequest = (request) => __awaiter(void 0, void 0, void 0, function* () {
    try {
      mapConcurrency++;
      const mapped = request.map();
      if (mapped instanceof Promise)
        request.next(yield mapped);
      else if (mapped)
        request.next(mapped);
    } catch (error) {
      request.reject(error);
    } finally {
      mapConcurrency--;
    }
    while (buffer2.length > 0 && mapConcurrency < maxMapConcurrency) {
      processRequest(buffer2.shift());
    }
  });
  if (pageVisibility) {
    pageVisibility.onPageHidden(() => {
      while (buffer2.length > 0)
        processRequest(buffer2.shift());
    });
  }
  return (next) => (request, metadata) => {
    return new Promise((resolve, reject) => {
      const mappableRequest = {
        map: () => map2(request),
        next: (mappedRequest) => next(mappedRequest, metadata).then(resolve).catch(reject),
        reject
      };
      if (mapConcurrency < maxMapConcurrency)
        processRequest(mappableRequest);
      else
        buffer2.push(mappableRequest);
    });
  };
};

// node_modules/@snap/camera-kit/dist/handlers/batchingHandler.js
var createBatchingHandler = ({ batchReduce, isBatchComplete, maxBatchAge, pageVisibility }) => {
  let batchTimeout;
  let currentBatch = void 0;
  let clearOnHidden = () => {
  };
  const reducingHandler = createMappingHandler((request) => __awaiter(void 0, void 0, void 0, function* () {
    currentBatch = yield batchReduce(currentBatch, request);
    return currentBatch;
  }), pageVisibility, 1);
  const batchAndSend = (next, request, metadata) => {
    const batch = request ? batchReduce(currentBatch, request) : currentBatch;
    if (!batch)
      return;
    const complete = batch instanceof Promise ? batch.then((b2) => next(b2, metadata)).catch(() => {
    }) : next(batch, metadata).catch(() => {
    });
    currentBatch = void 0;
    clearTimeout(batchTimeout);
    clearOnHidden();
    return complete;
  };
  return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
    if (pageVisibility && pageVisibility.isDuringVisibilityTransition("hidden")) {
      yield batchAndSend(next, request, metadata);
      return;
    }
    if (currentBatch === void 0) {
      const sendBatch = () => batchAndSend(next, void 0, metadata);
      if (maxBatchAge !== void 0)
        batchTimeout = setTimeout(sendBatch, maxBatchAge);
      if (pageVisibility)
        clearOnHidden = pageVisibility.onPageHidden(sendBatch);
    }
    const handle = reducingHandler(() => __awaiter(void 0, void 0, void 0, function* () {
      if (!currentBatch)
        return;
      if (!isBatchComplete(currentBatch))
        return;
      yield batchAndSend(next, void 0, metadata);
    }));
    return handle(request, metadata);
  });
};

// node_modules/@snap/camera-kit/dist/handlers/rateLimitingHandler.js
var delay2 = (duration) => new Promise((resolve) => setTimeout(resolve, duration));
var createRateLimitingHandler = (duration, pageVisibility) => {
  let mostRecentSendTime = void 0;
  const mappingHandler = createMappingHandler((request) => __awaiter(void 0, void 0, void 0, function* () {
    if (mostRecentSendTime !== void 0) {
      const millisUntilNextSend = duration - (Date.now() - mostRecentSendTime);
      if (millisUntilNextSend > 0)
        yield delay2(millisUntilNextSend);
    }
    mostRecentSendTime = Date.now();
    return request;
  }), pageVisibility, 1);
  return (next) => (request, metadata) => {
    if (pageVisibility && pageVisibility.isDuringVisibilityTransition("hidden"))
      return next(request, metadata);
    return mappingHandler(next)(request, metadata);
  };
};

// node_modules/@snap/camera-kit/dist/metrics/operational/Count.js
function isCountMetric(value) {
  var _a;
  return ((_a = value.metric) === null || _a === void 0 ? void 0 : _a.$case) === "count";
}
var Count = class _Count extends Metric {
  static count(name, n2, dimensions = {}) {
    const count2 = new _Count(name, dimensions);
    count2.increment(n2);
    return count2;
  }
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.count = 0;
  }
  increment(count2) {
    this.count += count2;
    return this.count;
  }
  toOperationalMetric() {
    return [
      {
        name: `${this.name}${serializeMetricDimensions(this.dimensions)}`,
        timestamp: /* @__PURE__ */ new Date(),
        metric: { $case: "count", count: `${Math.ceil(this.count)}` }
      }
    ];
  }
};

// node_modules/@snap/camera-kit/dist/clients/metricsClient.js
var METRIC_REQUEST_RATE_LIMIT_MS = 1e3;
var BUSINESS_EVENT_BATCH_MAX_SIZE = 10;
var BUSINESS_EVENT_BATCH_MAX_AGE_MS = 5e3;
var METRIC_BATCH_MAX_SIZE = 100;
var METRIC_BATCH_MAX_AGE_MS = 5e3;
var MetricsClient = class {
  constructor(grpcClient, pageVisibility) {
    this.grpcClient = grpcClient;
    const rateLimitingHandler = createRateLimitingHandler(METRIC_REQUEST_RATE_LIMIT_MS, pageVisibility);
    this.businessEventsHandler = new HandlerChainBuilder((request) => __awaiter(this, void 0, void 0, function* () {
      yield this.grpcClient.setBusinessEvents(request);
    })).map(rateLimitingHandler).map(createMappingHandler((serverEvents) => {
      const batch = ServerEventBatch.fromPartial({ serverEvents });
      const request = {
        batchEvents: {
          typeUrl: "com.snapchat.analytics.blizzard.ServerEventBatch",
          value: ServerEventBatch.encode(batch).finish()
        }
      };
      return request;
    }, pageVisibility)).map(createBatchingHandler({
      batchReduce: (previous, event) => {
        const batch = previous !== null && previous !== void 0 ? previous : [];
        batch.push(event);
        return batch;
      },
      isBatchComplete: (batch) => batch.length >= BUSINESS_EVENT_BATCH_MAX_SIZE,
      maxBatchAge: BUSINESS_EVENT_BATCH_MAX_AGE_MS,
      pageVisibility
    })).handler;
    this.operationalMetricsHandler = new HandlerChainBuilder((metrics) => __awaiter(this, void 0, void 0, function* () {
      yield this.grpcClient.setOperationalMetrics({ metrics });
    })).map(rateLimitingHandler).map(createBatchingHandler({
      batchReduce: (previous, metric) => {
        var _a;
        const batch = { metrics: (_a = previous === null || previous === void 0 ? void 0 : previous.metrics) !== null && _a !== void 0 ? _a : [] };
        if (isCountMetric(metric)) {
          const priorCount = batch.metrics.find((m2) => {
            return isCountMetric(m2) && m2.name === metric.name;
          });
          if (priorCount && isCountMetric(priorCount)) {
            priorCount.metric.count = `${Number(priorCount.metric.count) + Number(metric.metric.count)}`;
            return batch;
          }
        }
        batch.metrics.push(metric);
        return batch;
      },
      isBatchComplete: (bundle) => bundle.metrics.length >= METRIC_BATCH_MAX_SIZE,
      maxBatchAge: METRIC_BATCH_MAX_AGE_MS,
      pageVisibility
    })).handler;
  }
  setBusinessEvents(event) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.businessEventsHandler(event);
    });
  }
  setOperationalMetrics(metric) {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(metric.toOperationalMetric().map((metric2) => {
        return this.operationalMetricsHandler(metric2);
      }));
    });
  }
};
var validExternalMetrics = /^push2web_/;
var externalMetricsSubjectFactory = Injectable("externalMetricsSubject", () => new Subject());
var metricsClientFactory = Injectable("metricsClient", [externalMetricsSubjectFactory.token, grpcHandlerFactory.token, pageVisibilityFactory.token], (externalMetricsSubjectFactory2, grpcHandler, pageVisibility) => {
  const metrics = new MetricsClient(createTsProtoClient(MetricsDefinition, grpcHandler), pageVisibility);
  externalMetricsSubjectFactory2.pipe(filter((metric) => validExternalMetrics.test(metric.name))).subscribe({
    next: (metric) => {
      metrics.setOperationalMetrics(metric);
    }
  });
  return metrics;
});

// node_modules/@snap/camera-kit/dist/remote-configuration/cofHandler.js
var COF_REQUEST_TYPE = "cof";
var logger5 = getLogger("cofHandler");
var cofHandlerFactory = Injectable("cofHandler", [configurationToken, requestStateEventTargetFactory.token, metricsClientFactory.token], (config2, requestStateEventTarget, metrics) => {
  const cofCache = new ExpiringPersistence(() => convertDaysToSeconds(365), new IndexedDBPersistence({ databaseName: "COFCache" }));
  const getCacheKey2 = (r2) => JSON.stringify(r2);
  return new HandlerChainBuilder((request, _a) => __awaiter(void 0, void 0, void 0, function* () {
    var { signal, isSideEffect: _ } = _a, metadata = __rest(_a, ["signal", "isSideEffect"]);
    const rpc = new GrpcWebImpl(`https://${config2.apiHostname}`, {});
    const client = new CircumstancesServiceClientImpl(rpc);
    return new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
      var _b;
      if (signal) {
        signal.addEventListener("abort", () => reject(new Error("COF request aborted by handler chain.")));
      }
      const cachedResponse = yield cofCache.retrieve(getCacheKey2(request)).catch((e2) => {
        logger5.warn("Unable to get COF response from cache.", e2);
        return {
          configResultsEtag: void 0,
          configResults: []
        };
      });
      const dimensions = {
        requestType: COF_REQUEST_TYPE,
        delta: `${!!(cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResultsEtag)}`
      };
      const { requestId: requestId2 } = dispatchRequestStarted(requestStateEventTarget, { dimensions });
      try {
        const response = yield client.targetingQuery(Object.assign(Object.assign({}, request), { configResultsEtag: cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResultsEtag, deltaSync: !!(cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResultsEtag) }), new import_browser_headers2.BrowserHeaders(Object.assign({ authorization: `Bearer ${config2.apiToken}`, "x-snap-client-user-agent": getCameraKitUserAgent() }, metadata)));
        delete response.toObject;
        const configResults = unionBy("configId", (_b = cachedResponse === null || cachedResponse === void 0 ? void 0 : cachedResponse.configResults) !== null && _b !== void 0 ? _b : [], response.configResults).filter((config3) => !config3.delete);
        const status = 200;
        let sizeByte = 0;
        try {
          sizeByte = new TextEncoder().encode(JSON.stringify(response)).byteLength;
        } finally {
          dispatchRequestCompleted(requestStateEventTarget, {
            requestId: requestId2,
            dimensions,
            status,
            sizeByte
          });
        }
        resolve(Object.assign(Object.assign({}, response), { configResults }));
      } catch (error) {
        dispatchRequestErrored(requestStateEventTarget, {
          requestId: requestId2,
          dimensions,
          error: ensureError(error)
        });
        reject(error);
      }
    }));
  })).map(createRetryingHandler({ retryPredicate: (r2) => r2 instanceof Error })).map(createTimeoutHandler({ timeout: 20 * 1e3 })).map(createResponseCachingHandler(cofCache, getCacheKey2, staleWhileRevalidateStrategy({
    onMiss: () => {
      metrics.setOperationalMetrics(Count.count("cache_miss", 1, { request_type: COF_REQUEST_TYPE }));
    }
  }))).handler;
});

// node_modules/@snap/camera-kit/dist/remote-configuration/remoteConfiguration.js
var defaultTargetingRequest = {
  namespaces: [Namespace.LENS_CORE, Namespace.CAMERA_KIT_CORE, Namespace.LENS_CORE_CONFIG]
};
var RemoteConfiguration = class {
  constructor(lensPerformance, cofHandler, grpcClient) {
    const lensCluster = Promise.resolve(lensPerformance).then((lensPerformance2) => {
      return (lensPerformance2 === null || lensPerformance2 === void 0 ? void 0 : lensPerformance2.cluster) === 0 ? void 0 : lensPerformance2 === null || lensPerformance2 === void 0 ? void 0 : lensPerformance2.cluster;
    });
    this.configById = from(lensCluster).pipe(mergeMap((lensClusterOrig4) => from(cofHandler(Object.assign(Object.assign({}, defaultTargetingRequest), { lensClusterOrig4 })))), map((result) => {
      const configById = /* @__PURE__ */ new Map();
      result.configResults.forEach((config2) => {
        var _a;
        const configsWithId = (_a = configById.get(config2.configId)) !== null && _a !== void 0 ? _a : [];
        configsWithId.push(config2);
        configById.set(config2.configId, configsWithId);
      });
      return configById;
    }), shareReplay(1));
    this.initializationConfig = from(grpcClient.getInitializationConfig({})).pipe(map((result) => {
      if (result.ok) {
        const response = result.unwrap();
        if (response.message)
          return response.message;
        else
          throw new Error(`Failed to load initialization config. gRPC response successful, but message was null. gRPC status: ${response.statusMessage}`);
      }
      throw new Error(`Failed to load initialization config. gRPC status message: ${result.unwrapErr().statusMessage}`);
    }), shareReplay(1));
  }
  get(configId) {
    return this.configById.pipe(map((config2) => {
      var _a;
      return (_a = config2.get(configId)) !== null && _a !== void 0 ? _a : [];
    }));
  }
  getInitializationConfig() {
    return this.initializationConfig;
  }
  getGpuIndexConfig() {
    const lensClusterConfigName = "LENS_FEATURE_GPU_INDEX";
    return this.get(lensClusterConfigName).pipe(map((configResults) => {
      var _a, _b;
      if (configResults.length === 0) {
        throw new Error(`Cannot find '${lensClusterConfigName}' config.`);
      }
      return (_b = (_a = configResults[0].value) === null || _a === void 0 ? void 0 : _a.intValue) !== null && _b !== void 0 ? _b : -1;
    }), shareReplay(1));
  }
  getNamespace(namespace) {
    return this.configById.pipe(map((configs) => {
      const namespaceConfigs = Array.from(configs.values()).filter((values) => values.some((c2) => c2.namespace === namespace)).flatMap((results) => results);
      return namespaceConfigs;
    }));
  }
};
var remoteConfigurationFactory = Injectable("remoteConfiguration", [configurationToken, cofHandlerFactory.token, grpcHandlerFactory.token], (config2, cofHandler, grpcHandler) => {
  const remoteConfig = new RemoteConfiguration(config2.lensPerformance, cofHandler, createTsProtoClient(MetricsDefinition, grpcHandler));
  remoteConfig.get("").pipe(take(1)).subscribe();
  return remoteConfig;
});

// node_modules/@snap/camera-kit/dist/lens/assets/deviceDependentAssetLoader.js
var hasStringValue = (value) => {
  return isRecord(value) && isString(value.stringValue);
};
var isAssetConfig = (value) => {
  return isRecord(value) && isString(value.url) && (value.checksum === void 0 || isString(value.checksum));
};
var deviceDependentAssetLoaderFactory = Injectable("deviceDependentAssetLoader", [defaultFetchHandlerFactory.token, remoteConfigurationFactory.token], (fetchHandler, remoteConfiguration) => {
  const assetHandler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return function deviceDependentAssetLoader({ assetDescriptor: { assetId }, lowPriority }) {
    return __awaiter(this, void 0, void 0, function* () {
      const loadingFailed = (reason, cause) => new Error(`Cannot load device-dependent asset ${assetId}. ${reason}`, { cause });
      return firstValueFrom(remoteConfiguration.get(assetId).pipe(catchError((error) => {
        throw loadingFailed("COF config failed to load.", error);
      }), map((configs) => {
        if (configs.length === 0) {
          throw loadingFailed(`No COF config found corresponding to that assetId.`);
        }
        const [{ value }] = configs;
        if (!hasStringValue(value))
          throw loadingFailed("COF config malformed (missing stringValue)");
        let assetConfig;
        try {
          assetConfig = JSON.parse(value.stringValue);
        } catch (parseError) {
          throw loadingFailed("COF config malformed (JSON parse error)", parseError);
        }
        if (!isAssetConfig(assetConfig))
          throw loadingFailed("COF config malformed (missing URL)");
        return assetConfig;
      }), mergeMap(({ url, checksum }) => __awaiter(this, void 0, void 0, function* () {
        const [data, response] = yield assetHandler(url, withRequestPriority({ cache: "force-cache" }, lowPriority));
        if (!response.ok)
          throw response;
        return { data, checksum };
      }))));
    });
  };
});

// node_modules/@snap/camera-kit/dist/lens/assets/staticAssetLoader.js
var staticAssetLoaderFactory = Injectable("staticAssetLoader", [defaultFetchHandlerFactory.token], (fetchHandler) => {
  const handler = new HandlerChainBuilder(fetchHandler).map(createArrayBufferParsingHandler()).handler;
  return ({ assetDescriptor: { assetId }, assetManifest, lowPriority }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const assetUrl = (_a = assetManifest === null || assetManifest === void 0 ? void 0 : assetManifest.find((manifest) => manifest.id === assetId)) === null || _a === void 0 ? void 0 : _a.assetUrl;
    if (!assetUrl) {
      throw new Error(`Cannot load lens asset ${assetId}. Static asset URL could not be found.`);
    }
    const [buffer2, response] = yield handler(assetUrl, withRequestPriority({ cache: "force-cache" }, lowPriority));
    if (!response.ok)
      throw response;
    return buffer2;
  });
});

// node_modules/@snap/camera-kit/dist/lens-core-module/lensCoreError.js
var lensCoreErrorValue = {
  LensDeserialization: 0,
  Validation: 1,
  Uncategorized: 2,
  LensExecution: 3,
  Abort: 4,
  Uninitialized: 5
};
var lensCoreErrorName = Object.fromEntries(Object.entries(lensCoreErrorValue).map((entry) => [entry[1], entry[0]]));
function wrapLensCoreError(unknownError, isFrameError) {
  var _a, _b, _c, _d, _e;
  const lcError = ensureError(unknownError);
  const error = new Error(lcError.message.split("\n")[0], {
    cause: lcError.otherExceptions || ((_a = lcError.cause) === null || _a === void 0 ? void 0 : _a.metadata) ? {
      otherExceptions: lcError.otherExceptions,
      metadata: (_b = lcError.cause) === null || _b === void 0 ? void 0 : _b.metadata
    } : void 0
  });
  const lcErrorType = (_d = (_c = lcError.cause) === null || _c === void 0 ? void 0 : _c.type) === null || _d === void 0 ? void 0 : _d.value;
  const name = `LensCore${(_e = lensCoreErrorName[lcErrorType]) !== null && _e !== void 0 ? _e : "Unknown"}Error`;
  error.name = name;
  error.isFrameError = isFrameError;
  if (lcError.stack) {
    const [_, ...stackLines] = lcError.stack.split("\n");
    if (error.stack) {
      stackLines.unshift(error.stack.split("\n")[0]);
    }
    error.stack = stackLines.join("\n");
  }
  return error;
}

// node_modules/@snap/camera-kit/dist/lens-core-module/lensCore.js
var promisifiableMethods = {
  addLens: null,
  clearAllLenses: null,
  imageToYuvBuffer: null,
  pauseCanvas: null,
  processAudioSampleBuffer: null,
  processFrame: null,
  removeLens: null,
  replaceLenses: null,
  setAudioParameters: null,
  setDeviceClass: null,
  setGpuIndex: null,
  setFPSLimit: null,
  setInputTransform: null,
  setOnFrameProcessedCallback: null,
  setRenderLoopMode: null,
  setRenderSize: null,
  teardown: null,
  useMediaElement: null,
  yuvBufferToBitmap: null
};
function createErrorWrapper(isForFrameErrors, errors) {
  return (fn) => {
    return (nativeError) => {
      const error = wrapLensCoreError(nativeError, isForFrameErrors);
      fn(error);
      errors.next(error);
    };
  };
}
function withTryCatch(fn, errors) {
  return function(...args) {
    try {
      return fn.apply(this, args);
    } catch (e2) {
      const error = wrapLensCoreError(e2, false);
      errors.next(error);
      throw error;
    }
  };
}
var errorsFieldName = "errors";
var createLensCore = (lensCoreModule) => {
  const errors = new Subject();
  const errorsObservable = errors.asObservable();
  const getRegularErrorWrapper = createErrorWrapper(false, errors);
  const getFrameErrorWrapper = createErrorWrapper(true, errors);
  const customMethods = {
    initialize(input) {
      return new Promise((onSuccess, onFailure) => {
        var _a;
        return lensCoreModule.initialize(Object.assign(Object.assign({}, input), { exceptionHandler: getFrameErrorWrapper((_a = input.exceptionHandler) !== null && _a !== void 0 ? _a : () => {
        }), onSuccess, onFailure: getRegularErrorWrapper(onFailure) }));
      });
    },
    provideRemoteAssetsResponse(input) {
      var _a;
      return lensCoreModule.provideRemoteAssetsResponse(Object.assign(Object.assign({}, input), { onFailure: getRegularErrorWrapper((_a = input.onFailure) !== null && _a !== void 0 ? _a : () => {
      }) }));
    },
    playCanvas(input) {
      return new Promise((onReady, onFailure) => {
        lensCoreModule.playCanvas(Object.assign(Object.assign({}, input), { onReady, onFailure: getRegularErrorWrapper(onFailure) }));
      });
    }
  };
  return new Proxy(lensCoreModule, {
    get: (target, property, receiver) => {
      if (property === errorsFieldName) {
        return errorsObservable;
      }
      if (property in customMethods) {
        return withTryCatch(customMethods[property], errors);
      }
      const targetProperty = Reflect.get(target, property, receiver);
      if (!targetProperty)
        return targetProperty;
      if (property in promisifiableMethods) {
        return withTryCatch(function(input) {
          return new Promise((onSuccess, onFailure) => targetProperty(Object.assign(Object.assign({}, input), { onSuccess, onFailure: getRegularErrorWrapper(onFailure) })));
        }, errors);
      }
      if (typeof targetProperty === "function") {
        if ("values" in targetProperty) {
          return targetProperty;
        } else {
          return withTryCatch(targetProperty, errors);
        }
      }
      return targetProperty;
    }
  });
};

// node_modules/@snap/camera-kit/dist/common/loadScript.js
function loadScript(scriptUri) {
  return new Promise((resolve, reject) => {
    const scriptElement = document.createElement("script");
    scriptElement.src = scriptUri;
    scriptElement.async = true;
    merge(fromEvent(scriptElement, "load").pipe(tap(() => resolve(scriptElement))), fromEvent(scriptElement, "error").pipe(tap((e2) => reject(e2)))).pipe(take(1)).subscribe();
    document.body.appendChild(scriptElement);
  });
}

// node_modules/@snap/camera-kit/dist/handlers/customLensCoreHandler.js
var createCustomLensCoreHandler = () => {
  return (next) => (input, init) => {
    var _a;
    const url = isString(input) ? input : (_a = input === null || input === void 0 ? void 0 : input.url) !== null && _a !== void 0 ? _a : "";
    if (url.startsWith("https://lens-core-wasm.sc-corp.net/")) {
      return next(input, Object.assign(Object.assign({}, init), { credentials: "include" }));
    }
    return next(input, init);
  };
};

// node_modules/wasm-feature-detect/dist/esm/index.js
var exceptions = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 8, 1, 6, 0, 6, 64, 25, 11, 11]));
var relaxedSimd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 15, 1, 13, 0, 65, 1, 253, 15, 65, 2, 253, 15, 253, 128, 2, 11]));
var simd = async () => WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]));

// node_modules/@snap/camera-kit/dist/platform/platformCapabilities.js
var minRequiredMaxTextureSize = 1024;
function getWebGlSupport() {
  var _a, _b;
  const ctx = (_a = globalThis.document) === null || _a === void 0 ? void 0 : _a.createElement("canvas").getContext("webgl2");
  if (!ctx) {
    const cause = ((_b = globalThis.document) === null || _b === void 0 ? void 0 : _b.createElement("canvas").getContext("webgl")) ? "platform_not_supported_only_webgl1" : typeof globalThis.WebGLRenderingContext === "function" ? "platform_not_supported_likely_no_hw_accel" : "platform_not_supported_no_webgl_browser_support";
    return {
      supported: false,
      error: platformNotSupportedError("CameraKit requires WebGL2, but this browser does not support WebGL2.", new Error(cause))
    };
  }
  const maxTextureSize = ctx.getParameter(ctx.MAX_TEXTURE_SIZE);
  const supported = maxTextureSize >= minRequiredMaxTextureSize;
  return supported ? { supported, maxTextureSize } : {
    supported,
    error: platformNotSupportedError(`CameraKit requires WebGL's MAX_TEXTURE_SIZE exceed a minimum value of ${minRequiredMaxTextureSize}, but the browser's reported MAX_TEXTURE_SIZE is ${maxTextureSize}.`)
  };
}
function getWebAssemblyCapabilities() {
  return __awaiter(this, void 0, void 0, function* () {
    if (globalThis.WebAssembly === void 0)
      return {
        supported: false,
        error: platformNotSupportedError("CameraKit requires WebAssembly, but this browser does not support WebAssembly.")
      };
    const [simd2, exceptionHandling, relaxedSimd2] = yield Promise.all([
      simd().then((simd3) => {
        if (getPlatformInfo().browser.brand === "Safari")
          return false;
        return simd3;
      }),
      exceptions(),
      relaxedSimd()
    ]);
    return {
      supported: true,
      wasmFeatures: {
        simd: simd2,
        exceptionHandling,
        relaxedSimd: relaxedSimd2
      }
    };
  });
}
function getGenericWebXrNotSupported(cause) {
  return {
    supported: false,
    error: platformNotSupportedError(`Use of this feature requires WebXR support for immersive AR sessions, but this browser does not support immersive AR sessions.`, cause)
  };
}
function getWebXrCapabilities() {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      if (!isSecureContext || !navigator.xr)
        return getGenericWebXrNotSupported();
      const isImmersiveArSupported = yield navigator.xr.isSessionSupported("immersive-ar");
      return isImmersiveArSupported ? {
        supported: true,
        sixDofSupported: true,
        sceneDepthSupported: true
      } : getGenericWebXrNotSupported();
    } catch (error) {
      if (error instanceof Error && error.name === "SecurityError") {
        return {
          supported: false,
          error: platformNotSupportedError("Failed to check XR capabilities due to permissions or other issues.", error)
        };
      }
      return getGenericWebXrNotSupported(error);
    }
  });
}
var getPlatformCapabilities = memoize2(function getPlatformCapabilities2() {
  return __awaiter(this, void 0, void 0, function* () {
    return {
      webgl: getWebGlSupport(),
      wasm: yield getWebAssemblyCapabilities(),
      webxr: yield getWebXrCapabilities()
    };
  });
});

// node_modules/@snap/camera-kit/dist/lens-core-module/loader/bootstrapURLs.js
var wasmAssets = ["LensCoreWebAssembly.js", "LensCoreWebAssembly.wasm"];
function getBuildFlavor({ simd: simd2, exceptionHandling, relaxedSimd: relaxedSimd2 }, buildNumber) {
  const relaxedBuildAvailable = parseInt(buildNumber) >= Number.MAX_SAFE_INTEGER;
  if (relaxedBuildAvailable && relaxedSimd2) {
    return "rel-relaxed-simd-neh";
  } else if (simd2) {
    if (exceptionHandling) {
      return "rel-simd-neh";
    } else {
      return "release-simd";
    }
  } else if (exceptionHandling) {
    return "rel-neh";
  } else {
    return "release";
  }
}
function getRequiredBootstrapURLs(endpointOverride) {
  return __awaiter(this, void 0, void 0, function* () {
    const endpoint = endpointOverride === null || endpointOverride === void 0 ? void 0 : endpointOverride.replace(/[\/]+$/, "");
    const { wasm } = yield getPlatformCapabilities();
    if (!wasm.supported)
      throw wasm.error;
    const { lensCore } = getPlatformInfo();
    const version = lensCore.version;
    const buildNumber = lensCore.buildNumber;
    const flavor = getBuildFlavor(wasm.wasmFeatures, buildNumber);
    return wasmAssets.map((asset) => {
      if (endpoint)
        return `${endpoint}/${asset}`;
      const { origin, pathname, search } = new URL(lensCore.baseUrl);
      return `${origin}${pathname}/${version}/${buildNumber}/${flavor}/${asset}${search}`;
    });
  });
}

// node_modules/@snap/camera-kit/dist/lens-core-module/loader/lensCoreFactory.js
var logger6 = getLogger("lensCoreFactory");
var findMatch = (regex, strings) => strings.find((s2) => regex.test(s2));
var LENS_CORE_JS_REQUEST_TYPE = "lens_core_js";
var LENS_CORE_WASM_REQUEST_TYPE = "lens_core_wasm";
var lensCoreFactory = Injectable("lensCore", [defaultFetchHandlerFactory.token, configurationToken, requestStateEventTargetFactory.token], (handler, { lensCoreOverrideUrls, wasmEndpointOverride }, requestStateEventTarget) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  let lensCoreJS;
  let lensCoreWASM;
  const customBuild = !!(lensCoreOverrideUrls || wasmEndpointOverride);
  let lensCoreHandlerChainBuilder = new HandlerChainBuilder(handler);
  if (customBuild) {
    lensCoreHandlerChainBuilder = lensCoreHandlerChainBuilder.map(createCustomLensCoreHandler());
  }
  const lensCoreHandler = lensCoreHandlerChainBuilder.map(createRequestStateEmittingHandler(requestStateEventTarget)).handler;
  if (lensCoreOverrideUrls) {
    lensCoreJS = lensCoreOverrideUrls.js;
    lensCoreWASM = lensCoreOverrideUrls.wasm;
  } else {
    const endpointOverride = wasmEndpointOverride !== null && wasmEndpointOverride !== void 0 ? wasmEndpointOverride : void 0;
    const assetURLs = yield getRequiredBootstrapURLs(endpointOverride);
    lensCoreJS = (_a = findMatch(/\.js/, assetURLs)) !== null && _a !== void 0 ? _a : "";
    lensCoreWASM = (_b = findMatch(/\.wasm/, assetURLs)) !== null && _b !== void 0 ? _b : "";
    if (!lensCoreJS || !lensCoreWASM) {
      throw new Error(`Cannot fetch required LensCore assets. Either the JS or WASM filename is missing from this list: ${assetURLs}.`);
    }
    const glueScript = yield lensCoreHandler([
      lensCoreJS,
      { requestType: LENS_CORE_JS_REQUEST_TYPE, customBuild: `${customBuild}` }
    ]).then((r2) => r2.blob());
    lensCoreJS = URL.createObjectURL(glueScript);
  }
  const scriptElement = yield loadScript(lensCoreJS);
  const lensCore = yield new Promise((resolve, reject) => {
    let initialModule;
    const moduleInit = globalThis.createLensesModule(initialModule = {
      mainScriptUrlOrBlob: lensCoreJS,
      instantiateWasm: (importObject, receiveInstance) => {
        WebAssembly.instantiateStreaming(lensCoreHandler([
          lensCoreWASM,
          { requestType: LENS_CORE_WASM_REQUEST_TYPE, customBuild: `${customBuild}` }
        ]), importObject).then(function({ instance, module }) {
          receiveInstance(instance, module);
          initialModule.compiledModule = module;
          resolve(moduleInit);
        }).catch(reject);
      }
    });
  });
  scriptElement.remove();
  if (lensCoreWasmVersions_default.version != `${lensCore.getCoreVersion()}`) {
    logger6.warn(`Loaded LensCore version (${lensCore.getCoreVersion()}) differs from expected one (${lensCoreWasmVersions_default.version})`);
  }
  return createLensCore(lensCore);
}));

// node_modules/@snap/camera-kit/dist/common/validate.js
var ordinalSuffixMap = {
  1: "st",
  2: "nd",
  3: "rd"
};
function getArgumentInfo(target, methodName, argumentIndex, arg) {
  var _a;
  let argString;
  try {
    argString = JSON.stringify(arg);
  } catch (_b) {
    argString = String(arg);
  }
  return {
    argPosition: `${argumentIndex + 1}${(_a = ordinalSuffixMap[argumentIndex + 1]) !== null && _a !== void 0 ? _a : "th"}`,
    methodPath: `${getTypeName(target)}.${String(methodName)}()`,
    argString
  };
}
function getTypeName(value) {
  if (value === null) {
    return "null";
  }
  const baseType = typeof value;
  if (!["object", "function"].includes(baseType)) {
    return baseType;
  }
  const nonNullValue = value;
  const tag = nonNullValue[Symbol.toStringTag];
  if (typeof tag === "string") {
    return tag;
  }
  if (baseType === "function" && Function.prototype.toString.call(nonNullValue).startsWith("class")) {
    return "class";
  }
  const className = nonNullValue.constructor.name;
  if (typeof className === "string" && className !== "") {
    return className;
  }
  return baseType;
}
function validate(...guards) {
  return function validator(target, context2) {
    return function(...args) {
      for (const [index, guard] of guards.entries()) {
        if (!guard(args[index])) {
          const { argPosition, methodPath, argString } = getArgumentInfo(this, context2.name, index, args[index]);
          throw argumentValidationError(`The ${argPosition} argument to ${methodPath} method has an invalid value: ${argString}.`);
        }
      }
      return target.apply(this, args);
    };
  };
}

// node_modules/@snap/camera-kit/dist/logger/errorLoggingDecorator.js
function errorLoggingDecorator(logger28) {
  const handleError = (error) => logger28.error(error);
  return function validator(target, _context) {
    return function(...args) {
      try {
        const result = target.apply(this, args);
        if (result instanceof Promise) {
          result.catch(handleError);
        }
        return result;
      } catch (error) {
        handleError(error);
        throw error;
      }
    };
  };
}

// node_modules/@snap/camera-kit/dist/common/assertions.js
function assertUnreachable(_) {
  throw new Error("Reached unreachable code at runtime.");
}
function assert(condition, error = "Assertion failed") {
  if (!condition) {
    if (error instanceof Error) {
      throw error;
    } else {
      throw new Error(error);
    }
  }
}

// node_modules/@snap/camera-kit/dist/lens/Lens.js
function isLensArray(value) {
  return isArrayOfType(isLens, value);
}
function isLens(value) {
  return isRecord(value) && isString(value.id) && isString(value.name) && (isUndefined(value.iconUrl) || isString(value.iconUrl)) && isRecord(value.vendorData) && predicateRecordValues(isString)(value.vendorData) && isNumber(value.cameraFacingPreference) && (isUndefined(value.preview) || isPreview(value.preview)) && (isUndefined(value.lensCreator) || isLensCreator(value.lensCreator)) && (isUndefined(value.snapcode) || isSnapcode(value.snapcode)) && isAnyArray(value.featureMetadata);
}
function isPreview(value) {
  return isRecord(value) && isString(value.imageUrl);
}
function isLensCreator(value) {
  return isRecord(value) && isString(value.displayName);
}
function isSnapcode(value) {
  return isRecord(value) && isString(value.imageUrl) && isString(value.deepLink);
}
function isAny(value) {
  return isRecord(value) && isString(value.typeUrl) && isTypedArray(value.value);
}
function isAnyArray(value) {
  return isArrayOfType(isAny, value);
}
function toPublicLens({ id, groupId, name, content, vendorData, cameraFacingPreference, lensCreator, scannable, featureMetadata }) {
  var _a;
  assert(isEmptyOrSafeUrl(content === null || content === void 0 ? void 0 : content.iconUrlBolt), "Unsafe icon URL");
  assert(isEmptyOrSafeUrl((_a = content === null || content === void 0 ? void 0 : content.preview) === null || _a === void 0 ? void 0 : _a.imageUrl), "Unsafe preview URL");
  return {
    id,
    groupId,
    name,
    iconUrl: content === null || content === void 0 ? void 0 : content.iconUrlBolt,
    preview: (content === null || content === void 0 ? void 0 : content.preview) ? { imageUrl: content.preview.imageUrl } : void 0,
    vendorData,
    cameraFacingPreference,
    lensCreator,
    snapcode: scannable ? { imageUrl: scannable.snapcodeImageUrl, deepLink: scannable.snapcodeDeeplink } : void 0,
    featureMetadata
  };
}

// node_modules/@snap/camera-kit/dist/metrics/metricsEventTarget.js
var metricsEventTargetFactory = Injectable("metricsEventTarget", () => new TypedEventTarget());

// node_modules/@snap/camera-kit/dist/lens/assets/LensAssetRepository.js
var logger7 = getLogger("LensAssetRepository");
function getCacheKey(asset) {
  return `${asset.assetId}_${asset.assetType.value}`;
}
function mapManfiestItemToAssetType(lensCore, type) {
  switch (type) {
    case LensAssetManifestItem_Type.ASSET:
      return lensCore.AssetType.Static;
    case LensAssetManifestItem_Type.DEVICE_DEPENDENT_ASSET_UNSET:
    case LensAssetManifestItem_Type.UNRECOGNIZED:
      return lensCore.AssetType.DeviceDependent;
    default:
      return assertUnreachable(type);
  }
}
var LensAssetRepository = class {
  constructor(lensCore, assetLoaders, metrics, requestStateEventTarget) {
    this.lensCore = lensCore;
    this.assetLoaders = assetLoaders;
    this.metrics = metrics;
    this.requestStateEventTarget = requestStateEventTarget;
    this.cachedAssetKeys = /* @__PURE__ */ new Set();
  }
  cacheAssets(assetManifest, lens, assetTimings = [LensAssetManifestItem_RequestTiming.REQUIRED], lowPriority = false) {
    return __awaiter(this, void 0, void 0, function* () {
      const assetTimingsToPreload = /* @__PURE__ */ new Set([
        LensAssetManifestItem_RequestTiming.PRELOAD_UNSET,
        ...assetTimings
      ]);
      const assetDescriptors = assetManifest.filter((asset) => {
        return assetTimingsToPreload.has(asset.requestTiming);
      }).map(({ id, type }) => ({
        assetId: id,
        assetType: mapManfiestItemToAssetType(this.lensCore, type)
      }));
      if (assetDescriptors.length) {
        return this.cacheAssetsByDescriptor(assetDescriptors, lens, assetManifest, lowPriority);
      }
    });
  }
  loadAsset(request) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      const { assetDescriptor: { assetId, assetType }, lens } = request;
      const [assetTypeName, assetLoader] = (_a = this.assetLoaders.get(assetType)) !== null && _a !== void 0 ? _a : [];
      const safeAssetTypeName = assetTypeName !== null && assetTypeName !== void 0 ? assetTypeName : "unknown";
      const dimensions = {
        requestType: "asset",
        assetId,
        assetType: safeAssetTypeName,
        lensId: (_b = lens === null || lens === void 0 ? void 0 : lens.id) !== null && _b !== void 0 ? _b : "unknown"
      };
      const { requestId: requestId2 } = dispatchRequestStarted(this.requestStateEventTarget, { dimensions });
      try {
        if (!assetLoader) {
          throw new Error(`Cannot get asset ${assetId}. Asset type ${safeAssetTypeName} is not supported.`);
        }
        const assetResponse = yield assetLoader(request);
        const assetBuffer = "data" in assetResponse ? assetResponse.data : assetResponse;
        const assetChecksum = "checksum" in assetResponse ? assetResponse.checksum : void 0;
        if (assetBuffer.byteLength === 0) {
          throw new Error(`Got empty response for asset ${assetId} from ${safeAssetTypeName} loader.`);
        }
        dispatchRequestCompleted(this.requestStateEventTarget, {
          requestId: requestId2,
          dimensions,
          status: 200,
          sizeByte: assetBuffer.byteLength
        });
        this.lensCore.provideRemoteAssetsResponse({
          assetId,
          assetBuffer,
          assetType,
          assetChecksum,
          onFailure: (lensCoreError) => {
            if (/validation failed/.test(lensCoreError.message)) {
              this.metrics.dispatchEvent(new TypedCustomEvent("assetValidationFailed", {
                name: "assetValidationFailed",
                assetId
              }));
            }
            logger7.warn(`Failed to provide lens asset ${assetId}.`, lensCoreError);
          }
        });
      } catch (error) {
        const wrappedError = new Error(`Failed to load lens asset ${assetId}.`, { cause: error });
        dispatchRequestErrored(this.requestStateEventTarget, { requestId: requestId2, dimensions, error: wrappedError });
        throw wrappedError;
      }
    });
  }
  cacheAssetsByDescriptor(assetDescriptors, lens, assetManifest, lowPriority) {
    return __awaiter(this, void 0, void 0, function* () {
      yield Promise.all(assetDescriptors.filter((assetDescriptors2) => !this.cachedAssetKeys.has(getCacheKey(assetDescriptors2))).map((assetDescriptor) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        try {
          yield this.loadAsset({ assetDescriptor, lens, assetManifest, lowPriority });
          this.cachedAssetKeys.add(getCacheKey(assetDescriptor));
        } catch (error) {
          const { assetId, assetType } = assetDescriptor;
          const [assetTypeName] = (_a = this.assetLoaders.get(assetType)) !== null && _a !== void 0 ? _a : [];
          logger7.warn(`Failed to cache asset ${assetId} of type ${assetTypeName !== null && assetTypeName !== void 0 ? assetTypeName : assetType.value}.`, error);
        }
      })));
    });
  }
};
var lensAssetRepositoryFactory = Injectable("lensAssetRepository", [
  lensCoreFactory.token,
  deviceDependentAssetLoaderFactory.token,
  remoteMediaAssetLoaderFactory.token,
  staticAssetLoaderFactory.token,
  metricsEventTargetFactory.token,
  requestStateEventTargetFactory.token
], (lensCore, deviceDependentAssetLoader, remoteMediaAssetLoader, staticAssetLoader, metrics, requestStateEventTarget) => new LensAssetRepository(lensCore, /* @__PURE__ */ new Map([
  [lensCore.AssetType.DeviceDependent, ["DeviceDependent", deviceDependentAssetLoader]],
  [lensCore.AssetType.RemoteMediaByUrl, ["RemoteMediaByUrl", remoteMediaAssetLoader]],
  [lensCore.AssetType.URL, ["URL", remoteMediaAssetLoader]],
  [lensCore.AssetType.Static, ["Static", staticAssetLoader]]
]), metrics, requestStateEventTarget));

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/export.js
var ExportLensesByIdRequest_Context_Extension_Name;
(function(ExportLensesByIdRequest_Context_Extension_Name2) {
  ExportLensesByIdRequest_Context_Extension_Name2["UNSET"] = "UNSET";
  ExportLensesByIdRequest_Context_Extension_Name2["SHOP_KIT"] = "SHOP_KIT";
  ExportLensesByIdRequest_Context_Extension_Name2["LENS_WEB_BUILDER"] = "LENS_WEB_BUILDER";
  ExportLensesByIdRequest_Context_Extension_Name2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdRequest_Context_Extension_Name || (ExportLensesByIdRequest_Context_Extension_Name = {}));
var ExportLensesByIdResponse_ExcludedLens_Code;
(function(ExportLensesByIdResponse_ExcludedLens_Code2) {
  ExportLensesByIdResponse_ExcludedLens_Code2["UNSET"] = "UNSET";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNKNOWN"] = "UNKNOWN";
  ExportLensesByIdResponse_ExcludedLens_Code2["NOT_FOUND"] = "NOT_FOUND";
  ExportLensesByIdResponse_ExcludedLens_Code2["INCOMPATIBLE_LENS_CORE_VERSION"] = "INCOMPATIBLE_LENS_CORE_VERSION";
  ExportLensesByIdResponse_ExcludedLens_Code2["ARCHIVED_OR_INVISIBLE"] = "ARCHIVED_OR_INVISIBLE";
  ExportLensesByIdResponse_ExcludedLens_Code2["CONTAINS_MUSIC"] = "CONTAINS_MUSIC";
  ExportLensesByIdResponse_ExcludedLens_Code2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ExportLensesByIdResponse_ExcludedLens_Code || (ExportLensesByIdResponse_ExcludedLens_Code = {}));
function createBaseExtensionRequestContext() {
  return { userAgent: "", locale: "" };
}
var ExtensionRequestContext = {
  encode(message, writer = new BinaryWriter()) {
    if (message.userAgent !== "") {
      writer.uint32(10).string(message.userAgent);
    }
    if (message.locale !== "") {
      writer.uint32(18).string(message.locale);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseExtensionRequestContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.userAgent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.locale = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return ExtensionRequestContext.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseExtensionRequestContext();
    message.userAgent = (_a = object.userAgent) !== null && _a !== void 0 ? _a : "";
    message.locale = (_b = object.locale) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseEnvelope() {
  return { lenses: [] };
}
var Envelope = {
  encode() {
    throw new Error("Not implemented.");
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.lenses.push(Lens.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Envelope.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseEnvelope();
    message.lenses = ((_a = object.lenses) === null || _a === void 0 ? void 0 : _a.map((e2) => Lens.fromPartial(e2))) || [];
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/lens/LensSource.js
var lensSourcesFactory = Injectable("lensSources", () => []);
function loadLensesFromSources(sources, groupId, lensId) {
  return __awaiter(this, void 0, void 0, function* () {
    const source = sources.find((source2) => source2.isGroupOwner(groupId));
    if (!source) {
      throw new Error(`Cannot load lens ${lensId ? `${lensId} from ` : ""}group ${groupId}. No LensSource claimed ownership of that lens group.`);
    }
    const envelope = lensId === void 0 ? yield source.loadLensGroup(groupId) : yield source.loadLens(lensId, groupId);
    return envelope instanceof ArrayBuffer || ArrayBuffer.isView(envelope) ? Envelope.decode(envelope instanceof Uint8Array ? envelope : new Uint8Array(envelope)).lenses : [];
  });
}

// node_modules/@snap/camera-kit/dist/lens/LensRepository.js
var logger8 = getLogger("LensRepository");
var assetTimingMap = {
  required: LensAssetManifestItem_RequestTiming.REQUIRED,
  onDemand: LensAssetManifestItem_RequestTiming.ON_DEMAND
};
function isAssetTiming(value) {
  return isString(value) && assetTimingMap.hasOwnProperty(value);
}
function isAssetTimingArrayOrUndefined(value) {
  return isUndefined(value) || isArrayOfType(isAssetTiming, value);
}
var LensRepository = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _loadLens_decorators;
  let _loadLensGroups_decorators;
  let _cacheLensContent_decorators;
  return _a = class LensRepository {
    constructor(lensFetchHandler, lensSources, lensAssetRepository) {
      this.lensFetchHandler = (__runInitializers(this, _instanceExtraInitializers), lensFetchHandler);
      this.lensSources = lensSources;
      this.lensAssetRepository = lensAssetRepository;
      this.metadataCache = /* @__PURE__ */ new Map();
      this.binariesCache = /* @__PURE__ */ new Map();
    }
    loadLens(lensId, groupId) {
      return __awaiter(this, void 0, void 0, function* () {
        const lens = (yield loadLensesFromSources(this.lensSources, groupId, lensId))[0];
        if (!lens) {
          throw new Error(`Cannot load lens. No lens with id ${lensId} was found in lens group ${groupId}.`);
        }
        const lensWithGroup = Object.assign(Object.assign({}, lens), { groupId });
        this.metadataCache.set(lens.id, lensWithGroup);
        return toPublicLens(lensWithGroup);
      });
    }
    loadLensGroups(groupIds) {
      return __awaiter(this, void 0, void 0, function* () {
        const responses = yield Promise.all(groupIds.map((groupId) => __awaiter(this, void 0, void 0, function* () {
          try {
            return (yield loadLensesFromSources(this.lensSources, groupId)).map((lens) => {
              const lensWithGroup = Object.assign(Object.assign({}, lens), { groupId });
              this.metadataCache.set(lens.id, lensWithGroup);
              return toPublicLens(lensWithGroup);
            });
          } catch (e2) {
            const error = ensureError(e2);
            logger8.error(new Error(`Failed to load lens group ${groupId}.`, { cause: error }));
            return error;
          }
        })));
        return responses.reduce((result, response) => {
          if (response instanceof Error)
            result.errors.push(response);
          else
            result.lenses.push(...response);
          return result;
        }, { errors: [], lenses: [] });
      });
    }
    cacheLensContent(lenses, assetTimingsToCache = ["required", "onDemand"]) {
      return __awaiter(this, void 0, void 0, function* () {
        const assetTimingsToLoad = assetTimingsToCache.map((timing) => assetTimingMap[timing]);
        yield Promise.all(lenses.map((lens) => __awaiter(this, void 0, void 0, function* () {
          try {
            const { lensBuffer } = yield this.getLensContent(lens, true);
            const { content } = this.metadataCache.get(lens.id);
            this.binariesCache.set(lens.id, lensBuffer);
            yield this.lensAssetRepository.cacheAssets(content.assetManifest, lens, assetTimingsToLoad, true);
          } catch (error) {
            logger8.warn(`Failed to cache lens ${lens.id}.`, error);
          }
        })));
      });
    }
    getLensMetadata(lensId) {
      return this.metadataCache.get(lensId);
    }
    removeCachedLenses(lenses) {
      lenses.forEach((lens) => this.binariesCache.delete(lens.id));
    }
    getLensContent(lens, lowPriority = false) {
      var _a2;
      return __awaiter(this, void 0, void 0, function* () {
        const { content } = (_a2 = this.metadataCache.get(lens.id)) !== null && _a2 !== void 0 ? _a2 : {};
        if (!content) {
          throw new Error(`Cannot find metadata for lens ${lens.id}.`);
        }
        const cachedLensBuffer = this.binariesCache.get(lens.id);
        if (cachedLensBuffer) {
          return {
            lensBuffer: cachedLensBuffer,
            lensChecksum: content.lnsSha256
          };
        }
        const [lensBuffer] = yield this.lensFetchHandler([
          new Request(content.lnsUrlBolt, withRequestPriority({ cache: "force-cache" }, lowPriority)),
          {
            requestType: "lens_content",
            lensId: lens.id
          }
        ]);
        return { lensBuffer, lensChecksum: content.lnsSha256 };
      });
    }
  }, (() => {
    _loadLens_decorators = [validate(isSafeString, isSafeString), errorLoggingDecorator(logger8)];
    _loadLensGroups_decorators = [validate(isSafeStringArray), errorLoggingDecorator(logger8)];
    _cacheLensContent_decorators = [validate(isLensArray, isAssetTimingArrayOrUndefined), errorLoggingDecorator(logger8)];
    __esDecorate(_a, null, _loadLens_decorators, { kind: "method", name: "loadLens", static: false, private: false, access: { has: (obj) => "loadLens" in obj, get: (obj) => obj.loadLens } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _loadLensGroups_decorators, { kind: "method", name: "loadLensGroups", static: false, private: false, access: { has: (obj) => "loadLensGroups" in obj, get: (obj) => obj.loadLensGroups } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _cacheLensContent_decorators, { kind: "method", name: "cacheLensContent", static: false, private: false, access: { has: (obj) => "cacheLensContent" in obj, get: (obj) => obj.cacheLensContent } }, null, _instanceExtraInitializers);
  })(), _a;
})();
var lensRepositoryFactory = Injectable("LensRepository", [
  requestStateEventTargetFactory.token,
  defaultFetchHandlerFactory.token,
  lensSourcesFactory.token,
  lensAssetRepositoryFactory.token
], (requestStateEventTarget, defaultFetchHandler, lensSources, lensAssetRepository) => {
  const lensFetchHandler = new HandlerChainBuilder(defaultFetchHandler).map(createRequestStateEmittingHandler(requestStateEventTarget)).map(createArrayBufferParsingHandler()).handler;
  return new LensRepository(lensFetchHandler, lensSources, lensAssetRepository);
});

// node_modules/@snap/state-management/dist/types.js
var fromEntries2 = (entries3) => Object.fromEntries(entries3);

// node_modules/@snap/state-management/dist/actions.js
var defineAction = (name) => () => {
  const actionCreator = (data) => ({
    name,
    data
  });
  Object.defineProperty(actionCreator, "name", { value: name });
  return actionCreator;
};
var defineActions = (...actions) => {
  const entries3 = actions.map((s2) => [s2.name, s2]);
  return fromEntries2(entries3);
};
function forActions(...actions) {
  return filter((v2) => actions.some((action) => v2[0].name === action));
}
function isAction(action, name) {
  return action.name === name;
}

// node_modules/@snap/state-management/dist/state-machine.js
var StateMachine = class {
  /**
   * Create a StateMachine with a defined set of Actions and States.
   *
   * The StateMachine begins in a given initial state with transitions to new states defined by a "reducer" function.
   *
   * Reducers are OperatorFunctions which map an Observable of `[Action, State]` pairs into an Observable of a new
   * state. They can be constructed using RxJS's `pipe` function. For example:
   *
   * ```ts
   * new StateMachine(actions, states, initialState, pipe(
   *   inStates('someState'),
   *   forActions('someAction'),
   *   map(([a, s]) => computeNewState(a, s)),
   * ))
   * ```
   *
   * Often it will be useful to break the reducer into separate behaviors to handle different actions:
   *
   * ```ts
   * new StateMachine(actions, states, initialState, state => {
   *   return merge(
   *     state.pipe(inStates('someState'), forAction('someAction'), map(computeNextState)),
   *     state.pipe(inStates('otherState'), forAction('otherAction'), map(computeOtherNextState)),
   *     // ...
   *   )
   * })
   * ```
   *
   * Reducers must return an output Observable<State> which, when the input Observable<[Action, State]> emits, either:
   *
   * - synchronously emits a single new state.
   * - emits nothing.
   *
   * To enforce this, reducer Observables race with a sync Observable containing the current state. If the reducer
   * Observable does not emit a new state synchronously, the current state is used (i.e. the state does not change).
   *
   * @param initialState
   * @param reducer
   * @returns
   */
  constructor(actions, states, initialState, reducer) {
    __publicField(this, "actions");
    __publicField(this, "states");
    /**
     * After an Action is dispatched, passed to the StateMachine's reducer to produce a new state (or stay in the same
     * state), a pair of [Action, State] is emitted on this Observable.
     *
     * This can be used to observe every action dispatched to the StateMachine, along with the state that it produced.
     *
     * The most common use of the `events` Observable is to implement side-effects. It's very common for side-effects
     * to dispatch actions back to the StateMachine.
     *
     * ```ts
     * stateMachine.events.pipe(
     *   inStates('idle'),
     *   forActions('makeRequest'),
     *   switchMap(([{data: request}]) => fromFetch(request)),
     *   tap(response => stateMachine.dispatch('requestComplete', response)),
     * ).subscribe()
     * ```
     */
    __publicField(this, "events");
    __publicField(this, "actionsSubject");
    __publicField(this, "eventsSubject");
    __publicField(this, "state");
    this.actions = actions;
    this.states = states;
    this.actionsSubject = new Subject();
    this.eventsSubject = new Subject();
    this.events = this.eventsSubject.asObservable();
    this.state = new BehaviorSubject(initialState);
    this.actionsSubject.pipe(withLatestFrom(this.state), mergeMap(([a2, s2]) => (
      // `NEVER` + `startWith` is needed for `raceWith` to work properly. If we instead used the more
      // typical `of([a, s])` we would encounter the following problem:
      //
      // `of` emits its value and completes synchronously (i.e. both in the same "frame," if you think in
      // marble diagrams). Assuming `reducer` does nothing to modify the completion behavior of its source
      // Observable, the Observable returned by `reducer` will also complete immediately. If we were to
      // pass that Observable to `raceWith`  whose output mirrors whichever input Observable is first to
      // emit, error, *or complete*  it would always win, even if it never emitted anything (because it
      // would already be complete).
      //
      // So instead we need an Observable that does not complete. We achieve this by using `NEVER` and
      // then starting it with `[a, s]`. Note that it's important to then use `take(1)` after `raceWith`
      // so that we don't leak Observables which never complete.
      NEVER.pipe(startWith([a2, s2]), reducer, raceWith(of(s2)), tap((newState) => {
        if (newState !== s2)
          this.state.next(newState);
      }), map((newState) => [a2, newState]), take(1))
    ))).subscribe(this.eventsSubject);
  }
  dispatch(actionOrName, data) {
    const action = typeof actionOrName === "string" ? { name: actionOrName, data } : actionOrName;
    this.actionsSubject.next(action);
  }
  /**
   * Returns the current state.
   */
  getState() {
    return this.state.getValue();
  }
};
function dispatch(stateMachine) {
  return (source) => new Observable((subscriber) => {
    const subscription = stateMachine.events.subscribe(subscriber);
    subscription.add(source.subscribe({
      next: (action) => stateMachine.dispatch(action),
      error: (error) => subscriber.error(error)
      // We purposely do not forward the `complete` notification.
      // We want the subscriber to remain subscribed to the stateMachine.events observable even if the
      // source Observable<Actions> completes.
    }));
    return subscription;
  });
}

// node_modules/@snap/state-management/dist/states.js
var defineState = (name) => () => defineAction(name)();
var defineStates = (...states) => defineActions(...states);
function inStates(...states) {
  return filter((v2) => states.some((state) => v2[1].name === state));
}
function isState(state, name) {
  return state.name === name;
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/launch_params.js
function createBaseLaunchParams() {
  return { data: new Uint8Array(0) };
}
var LaunchParams = {
  encode(message, writer = new BinaryWriter()) {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.data = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return LaunchParams.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLaunchParams();
    message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array(0);
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/geopoint.js
function createBaseGeopoint() {
  return { latitude: 0, longitude: 0 };
}
var Geopoint = {
  encode(message, writer = new BinaryWriter()) {
    if (message.latitude !== 0) {
      writer.uint32(9).double(message.latitude);
    }
    if (message.longitude !== 0) {
      writer.uint32(17).double(message.longitude);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeopoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }
          message.latitude = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }
          message.longitude = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Geopoint.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseGeopoint();
    message.latitude = (_a = object.latitude) !== null && _a !== void 0 ? _a : 0;
    message.longitude = (_b = object.longitude) !== null && _b !== void 0 ? _b : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/geocircle.js
function createBaseGeocircle() {
  return { radius: 0, center: void 0 };
}
var Geocircle = {
  encode(message, writer = new BinaryWriter()) {
    if (message.radius !== 0) {
      writer.uint32(9).double(message.radius);
    }
    if (message.center !== void 0) {
      Geopoint.encode(message.center, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGeocircle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }
          message.radius = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.center = Geopoint.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Geocircle.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGeocircle();
    message.radius = (_a = object.radius) !== null && _a !== void 0 ? _a : 0;
    message.center = object.center !== void 0 && object.center !== null ? Geopoint.fromPartial(object.center) : void 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/lures.js
function createBaseLures() {
  return { locations: [], activeLure: void 0, closestLure: void 0 };
}
var Lures = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.locations) {
      Geocircle.encode(v2, writer.uint32(10).fork()).join();
    }
    if (message.activeLure !== void 0) {
      Geocircle.encode(message.activeLure, writer.uint32(18).fork()).join();
    }
    if (message.closestLure !== void 0) {
      Geocircle.encode(message.closestLure, writer.uint32(26).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.locations.push(Geocircle.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.activeLure = Geocircle.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.closestLure = Geocircle.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Lures.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseLures();
    message.locations = ((_a = object.locations) === null || _a === void 0 ? void 0 : _a.map((e2) => Geocircle.fromPartial(e2))) || [];
    message.activeLure = object.activeLure !== void 0 && object.activeLure !== null ? Geocircle.fromPartial(object.activeLure) : void 0;
    message.closestLure = object.closestLure !== void 0 && object.closestLure !== null ? Geocircle.fromPartial(object.closestLure) : void 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/persistent_store.js
function createBasePersistentStore() {
  return { store: new Uint8Array(0) };
}
var PersistentStore = {
  encode(message, writer = new BinaryWriter()) {
    if (message.store.length !== 0) {
      writer.uint32(10).bytes(message.store);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePersistentStore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.store = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PersistentStore.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBasePersistentStore();
    message.store = (_a = object.store) !== null && _a !== void 0 ? _a : new Uint8Array(0);
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/snappable.js
var EncryptionData_EncryptionScheme;
(function(EncryptionData_EncryptionScheme2) {
  EncryptionData_EncryptionScheme2["NOT_APPLICABLE"] = "NOT_APPLICABLE";
  EncryptionData_EncryptionScheme2["SPOOKEY"] = "SPOOKEY";
  EncryptionData_EncryptionScheme2["REGISTRY"] = "REGISTRY";
  EncryptionData_EncryptionScheme2["FIDELIUS"] = "FIDELIUS";
  EncryptionData_EncryptionScheme2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(EncryptionData_EncryptionScheme || (EncryptionData_EncryptionScheme = {}));
function encryptionData_EncryptionSchemeFromJSON(object) {
  switch (object) {
    case 0:
    case "NOT_APPLICABLE":
      return EncryptionData_EncryptionScheme.NOT_APPLICABLE;
    case 1:
    case "SPOOKEY":
      return EncryptionData_EncryptionScheme.SPOOKEY;
    case 2:
    case "REGISTRY":
      return EncryptionData_EncryptionScheme.REGISTRY;
    case 3:
    case "FIDELIUS":
      return EncryptionData_EncryptionScheme.FIDELIUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EncryptionData_EncryptionScheme.UNRECOGNIZED;
  }
}
function encryptionData_EncryptionSchemeToNumber(object) {
  switch (object) {
    case EncryptionData_EncryptionScheme.NOT_APPLICABLE:
      return 0;
    case EncryptionData_EncryptionScheme.SPOOKEY:
      return 1;
    case EncryptionData_EncryptionScheme.REGISTRY:
      return 2;
    case EncryptionData_EncryptionScheme.FIDELIUS:
      return 3;
    case EncryptionData_EncryptionScheme.UNRECOGNIZED:
    default:
      return -1;
  }
}
var SnappableMessage_ReplyType;
(function(SnappableMessage_ReplyType2) {
  SnappableMessage_ReplyType2["NOT_APPLICABLE"] = "NOT_APPLICABLE";
  SnappableMessage_ReplyType2["CONTEXT"] = "CONTEXT";
  SnappableMessage_ReplyType2["INTERSTITIAL"] = "INTERSTITIAL";
  SnappableMessage_ReplyType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(SnappableMessage_ReplyType || (SnappableMessage_ReplyType = {}));
function createBaseEncryptionData() {
  return {
    key: new Uint8Array(0),
    ivStore: {},
    isKeyServerEncrypted: false,
    isKeyE2eEncrypted: false,
    encryptionScheme: EncryptionData_EncryptionScheme.NOT_APPLICABLE
  };
}
var EncryptionData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key.length !== 0) {
      writer.uint32(10).bytes(message.key);
    }
    Object.entries(message.ivStore).forEach(([key, value]) => {
      EncryptionData_IvStoreEntry.encode({ key, value }, writer.uint32(18).fork()).join();
    });
    if (message.isKeyServerEncrypted !== false) {
      writer.uint32(24).bool(message.isKeyServerEncrypted);
    }
    if (message.isKeyE2eEncrypted !== false) {
      writer.uint32(32).bool(message.isKeyE2eEncrypted);
    }
    if (message.encryptionScheme !== EncryptionData_EncryptionScheme.NOT_APPLICABLE) {
      writer.uint32(40).int32(encryptionData_EncryptionSchemeToNumber(message.encryptionScheme));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEncryptionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          const entry2 = EncryptionData_IvStoreEntry.decode(reader, reader.uint32());
          if (entry2.value !== void 0) {
            message.ivStore[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.isKeyServerEncrypted = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.isKeyE2eEncrypted = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.encryptionScheme = encryptionData_EncryptionSchemeFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return EncryptionData.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e;
    const message = createBaseEncryptionData();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array(0);
    message.ivStore = Object.entries((_b = object.ivStore) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = value;
      }
      return acc;
    }, {});
    message.isKeyServerEncrypted = (_c = object.isKeyServerEncrypted) !== null && _c !== void 0 ? _c : false;
    message.isKeyE2eEncrypted = (_d = object.isKeyE2eEncrypted) !== null && _d !== void 0 ? _d : false;
    message.encryptionScheme = (_e = object.encryptionScheme) !== null && _e !== void 0 ? _e : EncryptionData_EncryptionScheme.NOT_APPLICABLE;
    return message;
  }
};
function createBaseEncryptionData_IvStoreEntry() {
  return { key: "", value: new Uint8Array(0) };
}
var EncryptionData_IvStoreEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseEncryptionData_IvStoreEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return EncryptionData_IvStoreEntry.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseEncryptionData_IvStoreEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : new Uint8Array(0);
    return message;
  }
};
function createBasePlayerData() {
  return { store: {}, serializedStore: new Uint8Array(0) };
}
var PlayerData = {
  encode(message, writer = new BinaryWriter()) {
    Object.entries(message.store).forEach(([key, value]) => {
      PlayerData_StoreEntry.encode({ key, value }, writer.uint32(10).fork()).join();
    });
    if (message.serializedStore.length !== 0) {
      writer.uint32(18).bytes(message.serializedStore);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlayerData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          const entry1 = PlayerData_StoreEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.store[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.serializedStore = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PlayerData.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePlayerData();
    message.store = Object.entries((_a = object.store) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.serializedStore = (_b = object.serializedStore) !== null && _b !== void 0 ? _b : new Uint8Array(0);
    return message;
  }
};
function createBasePlayerData_StoreEntry() {
  return { key: "", value: "" };
}
var PlayerData_StoreEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBasePlayerData_StoreEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return PlayerData_StoreEntry.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBasePlayerData_StoreEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseSessionData() {
  return { playerData: {} };
}
var SessionData = {
  encode(message, writer = new BinaryWriter()) {
    Object.entries(message.playerData).forEach(([key, value]) => {
      SessionData_PlayerDataEntry.encode({ key, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSessionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          const entry1 = SessionData_PlayerDataEntry.decode(reader, reader.uint32());
          if (entry1.value !== void 0) {
            message.playerData[entry1.key] = entry1.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SessionData.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSessionData();
    message.playerData = Object.entries((_a = object.playerData) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
      if (value !== void 0) {
        acc[key] = PlayerData.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  }
};
function createBaseSessionData_PlayerDataEntry() {
  return { key: "", value: void 0 };
}
var SessionData_PlayerDataEntry = {
  encode(message, writer = new BinaryWriter()) {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== void 0) {
      PlayerData.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSessionData_PlayerDataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.value = PlayerData.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return SessionData_PlayerDataEntry.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseSessionData_PlayerDataEntry();
    message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
    message.value = object.value !== void 0 && object.value !== null ? PlayerData.fromPartial(object.value) : void 0;
    return message;
  }
};
function createBaseSnappable() {
  return {
    id: "",
    sessionId: "",
    playerId: "",
    sessionData: void 0,
    createdTime: "0",
    expireTime: "0",
    version: 0,
    encryptionData: void 0,
    sessionDepth: 0
  };
}
var Snappable = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.playerId !== "") {
      writer.uint32(26).string(message.playerId);
    }
    if (message.sessionData !== void 0) {
      SessionData.encode(message.sessionData, writer.uint32(34).fork()).join();
    }
    if (message.createdTime !== "0") {
      writer.uint32(40).int64(message.createdTime);
    }
    if (message.expireTime !== "0") {
      writer.uint32(48).int64(message.expireTime);
    }
    if (message.version !== 0) {
      writer.uint32(56).int32(message.version);
    }
    if (message.encryptionData !== void 0) {
      EncryptionData.encode(message.encryptionData, writer.uint32(66).fork()).join();
    }
    if (message.sessionDepth !== 0) {
      writer.uint32(72).int32(message.sessionDepth);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseSnappable();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.playerId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.sessionData = SessionData.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.createdTime = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.expireTime = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.version = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.encryptionData = EncryptionData.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.sessionDepth = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return Snappable.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseSnappable();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.sessionId = (_b = object.sessionId) !== null && _b !== void 0 ? _b : "";
    message.playerId = (_c = object.playerId) !== null && _c !== void 0 ? _c : "";
    message.sessionData = object.sessionData !== void 0 && object.sessionData !== null ? SessionData.fromPartial(object.sessionData) : void 0;
    message.createdTime = (_d = object.createdTime) !== null && _d !== void 0 ? _d : "0";
    message.expireTime = (_e = object.expireTime) !== null && _e !== void 0 ? _e : "0";
    message.version = (_f = object.version) !== null && _f !== void 0 ? _f : 0;
    message.encryptionData = object.encryptionData !== void 0 && object.encryptionData !== null ? EncryptionData.fromPartial(object.encryptionData) : void 0;
    message.sessionDepth = (_g = object.sessionDepth) !== null && _g !== void 0 ? _g : 0;
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/user_data.js
var UserData_Zodiac;
(function(UserData_Zodiac2) {
  UserData_Zodiac2["Invalid"] = "Invalid";
  UserData_Zodiac2["Aquarius"] = "Aquarius";
  UserData_Zodiac2["Aries"] = "Aries";
  UserData_Zodiac2["Cancer"] = "Cancer";
  UserData_Zodiac2["Capricorn"] = "Capricorn";
  UserData_Zodiac2["Gemini"] = "Gemini";
  UserData_Zodiac2["Leo"] = "Leo";
  UserData_Zodiac2["Libra"] = "Libra";
  UserData_Zodiac2["Pisces"] = "Pisces";
  UserData_Zodiac2["Sagittarius"] = "Sagittarius";
  UserData_Zodiac2["Scorpio"] = "Scorpio";
  UserData_Zodiac2["Taurus"] = "Taurus";
  UserData_Zodiac2["Virgo"] = "Virgo";
  UserData_Zodiac2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(UserData_Zodiac || (UserData_Zodiac = {}));
function userData_ZodiacFromJSON(object) {
  switch (object) {
    case 0:
    case "Invalid":
      return UserData_Zodiac.Invalid;
    case 1:
    case "Aquarius":
      return UserData_Zodiac.Aquarius;
    case 2:
    case "Aries":
      return UserData_Zodiac.Aries;
    case 3:
    case "Cancer":
      return UserData_Zodiac.Cancer;
    case 4:
    case "Capricorn":
      return UserData_Zodiac.Capricorn;
    case 5:
    case "Gemini":
      return UserData_Zodiac.Gemini;
    case 6:
    case "Leo":
      return UserData_Zodiac.Leo;
    case 7:
    case "Libra":
      return UserData_Zodiac.Libra;
    case 8:
    case "Pisces":
      return UserData_Zodiac.Pisces;
    case 9:
    case "Sagittarius":
      return UserData_Zodiac.Sagittarius;
    case 10:
    case "Scorpio":
      return UserData_Zodiac.Scorpio;
    case 11:
    case "Taurus":
      return UserData_Zodiac.Taurus;
    case 12:
    case "Virgo":
      return UserData_Zodiac.Virgo;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UserData_Zodiac.UNRECOGNIZED;
  }
}
function userData_ZodiacToNumber(object) {
  switch (object) {
    case UserData_Zodiac.Invalid:
      return 0;
    case UserData_Zodiac.Aquarius:
      return 1;
    case UserData_Zodiac.Aries:
      return 2;
    case UserData_Zodiac.Cancer:
      return 3;
    case UserData_Zodiac.Capricorn:
      return 4;
    case UserData_Zodiac.Gemini:
      return 5;
    case UserData_Zodiac.Leo:
      return 6;
    case UserData_Zodiac.Libra:
      return 7;
    case UserData_Zodiac.Pisces:
      return 8;
    case UserData_Zodiac.Sagittarius:
      return 9;
    case UserData_Zodiac.Scorpio:
      return 10;
    case UserData_Zodiac.Taurus:
      return 11;
    case UserData_Zodiac.Virgo:
      return 12;
    case UserData_Zodiac.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseBitmojiUserInfo() {
  return { avatarId: "", selfieId: "" };
}
var BitmojiUserInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.avatarId !== "") {
      writer.uint32(10).string(message.avatarId);
    }
    if (message.selfieId !== "") {
      writer.uint32(18).string(message.selfieId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseBitmojiUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.avatarId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.selfieId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return BitmojiUserInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b;
    const message = createBaseBitmojiUserInfo();
    message.avatarId = (_a = object.avatarId) !== null && _a !== void 0 ? _a : "";
    message.selfieId = (_b = object.selfieId) !== null && _b !== void 0 ? _b : "";
    return message;
  }
};
function createBaseFriendUserInfo() {
  return { friendshipStart: void 0, lastInteraction: void 0, streak: 0 };
}
var FriendUserInfo = {
  encode(message, writer = new BinaryWriter()) {
    if (message.friendshipStart !== void 0) {
      Timestamp.encode(toTimestamp4(message.friendshipStart), writer.uint32(10).fork()).join();
    }
    if (message.lastInteraction !== void 0) {
      Timestamp.encode(toTimestamp4(message.lastInteraction), writer.uint32(18).fork()).join();
    }
    if (message.streak !== 0) {
      writer.uint32(24).uint32(message.streak);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseFriendUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.friendshipStart = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lastInteraction = fromTimestamp4(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.streak = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return FriendUserInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c;
    const message = createBaseFriendUserInfo();
    message.friendshipStart = (_a = object.friendshipStart) !== null && _a !== void 0 ? _a : void 0;
    message.lastInteraction = (_b = object.lastInteraction) !== null && _b !== void 0 ? _b : void 0;
    message.streak = (_c = object.streak) !== null && _c !== void 0 ? _c : 0;
    return message;
  }
};
function createBaseUserData() {
  return {
    userId: "",
    username: "",
    birthdate: "",
    displayName: "",
    countrycode: "",
    score: "0",
    bitmojiInfo: void 0,
    friendInfo: void 0,
    zodiac: UserData_Zodiac.Invalid
  };
}
var UserData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.birthdate !== "") {
      writer.uint32(26).string(message.birthdate);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.countrycode !== "") {
      writer.uint32(42).string(message.countrycode);
    }
    if (message.score !== "0") {
      writer.uint32(56).uint64(message.score);
    }
    if (message.bitmojiInfo !== void 0) {
      BitmojiUserInfo.encode(message.bitmojiInfo, writer.uint32(66).fork()).join();
    }
    if (message.friendInfo !== void 0) {
      FriendUserInfo.encode(message.friendInfo, writer.uint32(74).fork()).join();
    }
    if (message.zodiac !== UserData_Zodiac.Invalid) {
      writer.uint32(80).int32(userData_ZodiacToNumber(message.zodiac));
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseUserData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.birthdate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.displayName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.countrycode = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.score = reader.uint64().toString();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }
          message.bitmojiInfo = BitmojiUserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }
          message.friendInfo = FriendUserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.zodiac = userData_ZodiacFromJSON(reader.int32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return UserData.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseUserData();
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    message.username = (_b = object.username) !== null && _b !== void 0 ? _b : "";
    message.birthdate = (_c = object.birthdate) !== null && _c !== void 0 ? _c : "";
    message.displayName = (_d = object.displayName) !== null && _d !== void 0 ? _d : "";
    message.countrycode = (_e = object.countrycode) !== null && _e !== void 0 ? _e : "";
    message.score = (_f = object.score) !== null && _f !== void 0 ? _f : "0";
    message.bitmojiInfo = object.bitmojiInfo !== void 0 && object.bitmojiInfo !== null ? BitmojiUserInfo.fromPartial(object.bitmojiInfo) : void 0;
    message.friendInfo = object.friendInfo !== void 0 && object.friendInfo !== null ? FriendUserInfo.fromPartial(object.friendInfo) : void 0;
    message.zodiac = (_g = object.zodiac) !== null && _g !== void 0 ? _g : UserData_Zodiac.Invalid;
    return message;
  }
};
function toTimestamp4(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp4(t2) {
  let millis = (globalThis.Number(t2.seconds) || 0) * 1e3;
  millis += (t2.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/launchdata.js
var LaunchData_EntryPoint;
(function(LaunchData_EntryPoint2) {
  LaunchData_EntryPoint2["LIVE_CAMERA"] = "LIVE_CAMERA";
  LaunchData_EntryPoint2["STORY_REPLY"] = "STORY_REPLY";
  LaunchData_EntryPoint2["CHAT_REPLY"] = "CHAT_REPLY";
  LaunchData_EntryPoint2["RESTART"] = "RESTART";
  LaunchData_EntryPoint2["PREVIEW_CANCEL"] = "PREVIEW_CANCEL";
  LaunchData_EntryPoint2["MAP"] = "MAP";
  LaunchData_EntryPoint2["BITMOJI_STICKERS"] = "BITMOJI_STICKERS";
  LaunchData_EntryPoint2["POST_CAPTURE_PREVIEW"] = "POST_CAPTURE_PREVIEW";
  LaunchData_EntryPoint2["POST_CAPTURE_TRANSCODING"] = "POST_CAPTURE_TRANSCODING";
  LaunchData_EntryPoint2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_EntryPoint || (LaunchData_EntryPoint = {}));
function launchData_EntryPointFromJSON(object) {
  switch (object) {
    case 0:
    case "LIVE_CAMERA":
      return LaunchData_EntryPoint.LIVE_CAMERA;
    case 1:
    case "STORY_REPLY":
      return LaunchData_EntryPoint.STORY_REPLY;
    case 2:
    case "CHAT_REPLY":
      return LaunchData_EntryPoint.CHAT_REPLY;
    case 3:
    case "RESTART":
      return LaunchData_EntryPoint.RESTART;
    case 4:
    case "PREVIEW_CANCEL":
      return LaunchData_EntryPoint.PREVIEW_CANCEL;
    case 5:
    case "MAP":
      return LaunchData_EntryPoint.MAP;
    case 6:
    case "BITMOJI_STICKERS":
      return LaunchData_EntryPoint.BITMOJI_STICKERS;
    case 7:
    case "POST_CAPTURE_PREVIEW":
      return LaunchData_EntryPoint.POST_CAPTURE_PREVIEW;
    case 8:
    case "POST_CAPTURE_TRANSCODING":
      return LaunchData_EntryPoint.POST_CAPTURE_TRANSCODING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_EntryPoint.UNRECOGNIZED;
  }
}
function launchData_EntryPointToNumber(object) {
  switch (object) {
    case LaunchData_EntryPoint.LIVE_CAMERA:
      return 0;
    case LaunchData_EntryPoint.STORY_REPLY:
      return 1;
    case LaunchData_EntryPoint.CHAT_REPLY:
      return 2;
    case LaunchData_EntryPoint.RESTART:
      return 3;
    case LaunchData_EntryPoint.PREVIEW_CANCEL:
      return 4;
    case LaunchData_EntryPoint.MAP:
      return 5;
    case LaunchData_EntryPoint.BITMOJI_STICKERS:
      return 6;
    case LaunchData_EntryPoint.POST_CAPTURE_PREVIEW:
      return 7;
    case LaunchData_EntryPoint.POST_CAPTURE_TRANSCODING:
      return 8;
    case LaunchData_EntryPoint.UNRECOGNIZED:
    default:
      return -1;
  }
}
var LaunchData_ApiDescriptor;
(function(LaunchData_ApiDescriptor2) {
  LaunchData_ApiDescriptor2["NONE"] = "NONE";
  LaunchData_ApiDescriptor2["EXPERIMENTAL"] = "EXPERIMENTAL";
  LaunchData_ApiDescriptor2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_ApiDescriptor || (LaunchData_ApiDescriptor = {}));
function launchData_ApiDescriptorFromJSON(object) {
  switch (object) {
    case 0:
    case "NONE":
      return LaunchData_ApiDescriptor.NONE;
    case 1:
    case "EXPERIMENTAL":
      return LaunchData_ApiDescriptor.EXPERIMENTAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_ApiDescriptor.UNRECOGNIZED;
  }
}
function launchData_ApiDescriptorToNumber(object) {
  switch (object) {
    case LaunchData_ApiDescriptor.NONE:
      return 0;
    case LaunchData_ApiDescriptor.EXPERIMENTAL:
      return 1;
    case LaunchData_ApiDescriptor.UNRECOGNIZED:
    default:
      return -1;
  }
}
var LaunchData_RenderConfig;
(function(LaunchData_RenderConfig2) {
  LaunchData_RenderConfig2["DEFAULT"] = "DEFAULT";
  LaunchData_RenderConfig2["REPLAY_STREAM"] = "REPLAY_STREAM";
  LaunchData_RenderConfig2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_RenderConfig || (LaunchData_RenderConfig = {}));
function launchData_RenderConfigFromJSON(object) {
  switch (object) {
    case 0:
    case "DEFAULT":
      return LaunchData_RenderConfig.DEFAULT;
    case 1:
    case "REPLAY_STREAM":
      return LaunchData_RenderConfig.REPLAY_STREAM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_RenderConfig.UNRECOGNIZED;
  }
}
function launchData_RenderConfigToNumber(object) {
  switch (object) {
    case LaunchData_RenderConfig.DEFAULT:
      return 0;
    case LaunchData_RenderConfig.REPLAY_STREAM:
      return 1;
    case LaunchData_RenderConfig.UNRECOGNIZED:
    default:
      return -1;
  }
}
var LaunchData_ActivationSource;
(function(LaunchData_ActivationSource2) {
  LaunchData_ActivationSource2["ACTIVATION_SOURCE_UNSET"] = "ACTIVATION_SOURCE_UNSET";
  LaunchData_ActivationSource2["ACTIVATION_SOURCE_DEFAULT"] = "ACTIVATION_SOURCE_DEFAULT";
  LaunchData_ActivationSource2["CREATIVE"] = "CREATIVE";
  LaunchData_ActivationSource2["SCAN"] = "SCAN";
  LaunchData_ActivationSource2["SCAN_HISTORY"] = "SCAN_HISTORY";
  LaunchData_ActivationSource2["CHAT_FEED_PSA"] = "CHAT_FEED_PSA";
  LaunchData_ActivationSource2["GROWTH_NOTIFICATION"] = "GROWTH_NOTIFICATION";
  LaunchData_ActivationSource2["MASS_SNAP"] = "MASS_SNAP";
  LaunchData_ActivationSource2["SMART_CTA"] = "SMART_CTA";
  LaunchData_ActivationSource2["MASS_CHAT"] = "MASS_CHAT";
  LaunchData_ActivationSource2["BILLBOARD_FHP"] = "BILLBOARD_FHP";
  LaunchData_ActivationSource2["LENS_ACTIVITY_CENTER"] = "LENS_ACTIVITY_CENTER";
  LaunchData_ActivationSource2["AR_BAR"] = "AR_BAR";
  LaunchData_ActivationSource2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(LaunchData_ActivationSource || (LaunchData_ActivationSource = {}));
function launchData_ActivationSourceFromJSON(object) {
  switch (object) {
    case 0:
    case "ACTIVATION_SOURCE_UNSET":
      return LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET;
    case 1:
    case "ACTIVATION_SOURCE_DEFAULT":
      return LaunchData_ActivationSource.ACTIVATION_SOURCE_DEFAULT;
    case 2:
    case "CREATIVE":
      return LaunchData_ActivationSource.CREATIVE;
    case 3:
    case "SCAN":
      return LaunchData_ActivationSource.SCAN;
    case 4:
    case "SCAN_HISTORY":
      return LaunchData_ActivationSource.SCAN_HISTORY;
    case 5:
    case "CHAT_FEED_PSA":
      return LaunchData_ActivationSource.CHAT_FEED_PSA;
    case 6:
    case "GROWTH_NOTIFICATION":
      return LaunchData_ActivationSource.GROWTH_NOTIFICATION;
    case 7:
    case "MASS_SNAP":
      return LaunchData_ActivationSource.MASS_SNAP;
    case 8:
    case "SMART_CTA":
      return LaunchData_ActivationSource.SMART_CTA;
    case 9:
    case "MASS_CHAT":
      return LaunchData_ActivationSource.MASS_CHAT;
    case 10:
    case "BILLBOARD_FHP":
      return LaunchData_ActivationSource.BILLBOARD_FHP;
    case 11:
    case "LENS_ACTIVITY_CENTER":
      return LaunchData_ActivationSource.LENS_ACTIVITY_CENTER;
    case 12:
    case "AR_BAR":
      return LaunchData_ActivationSource.AR_BAR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LaunchData_ActivationSource.UNRECOGNIZED;
  }
}
function launchData_ActivationSourceToNumber(object) {
  switch (object) {
    case LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET:
      return 0;
    case LaunchData_ActivationSource.ACTIVATION_SOURCE_DEFAULT:
      return 1;
    case LaunchData_ActivationSource.CREATIVE:
      return 2;
    case LaunchData_ActivationSource.SCAN:
      return 3;
    case LaunchData_ActivationSource.SCAN_HISTORY:
      return 4;
    case LaunchData_ActivationSource.CHAT_FEED_PSA:
      return 5;
    case LaunchData_ActivationSource.GROWTH_NOTIFICATION:
      return 6;
    case LaunchData_ActivationSource.MASS_SNAP:
      return 7;
    case LaunchData_ActivationSource.SMART_CTA:
      return 8;
    case LaunchData_ActivationSource.MASS_CHAT:
      return 9;
    case LaunchData_ActivationSource.BILLBOARD_FHP:
      return 10;
    case LaunchData_ActivationSource.LENS_ACTIVITY_CENTER:
      return 11;
    case LaunchData_ActivationSource.AR_BAR:
      return 12;
    case LaunchData_ActivationSource.UNRECOGNIZED:
    default:
      return -1;
  }
}
function createBaseLaunchData() {
  return {
    snappable: void 0,
    lures: void 0,
    userId: "",
    entryPoint: LaunchData_EntryPoint.LIVE_CAMERA,
    userData: void 0,
    persistentStore: void 0,
    launchParams: void 0,
    apiDescriptors: [],
    renderConfig: LaunchData_RenderConfig.DEFAULT,
    activationSource: LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET,
    overridenLaunchTime: void 0
  };
}
var LaunchData = {
  encode(message, writer = new BinaryWriter()) {
    if (message.snappable !== void 0) {
      Snappable.encode(message.snappable, writer.uint32(10).fork()).join();
    }
    if (message.lures !== void 0) {
      Lures.encode(message.lures, writer.uint32(18).fork()).join();
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.entryPoint !== LaunchData_EntryPoint.LIVE_CAMERA) {
      writer.uint32(32).int32(launchData_EntryPointToNumber(message.entryPoint));
    }
    if (message.userData !== void 0) {
      UserData.encode(message.userData, writer.uint32(42).fork()).join();
    }
    if (message.persistentStore !== void 0) {
      PersistentStore.encode(message.persistentStore, writer.uint32(50).fork()).join();
    }
    if (message.launchParams !== void 0) {
      LaunchParams.encode(message.launchParams, writer.uint32(58).fork()).join();
    }
    writer.uint32(66).fork();
    for (const v2 of message.apiDescriptors) {
      writer.int32(launchData_ApiDescriptorToNumber(v2));
    }
    writer.join();
    if (message.renderConfig !== LaunchData_RenderConfig.DEFAULT) {
      writer.uint32(72).int32(launchData_RenderConfigToNumber(message.renderConfig));
    }
    if (message.activationSource !== LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET) {
      writer.uint32(80).int32(launchData_ActivationSourceToNumber(message.activationSource));
    }
    if (message.overridenLaunchTime !== void 0) {
      Timestamp.encode(toTimestamp5(message.overridenLaunchTime), writer.uint32(90).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseLaunchData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.snappable = Snappable.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.lures = Lures.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.userId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.entryPoint = launchData_EntryPointFromJSON(reader.int32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.userData = UserData.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }
          message.persistentStore = PersistentStore.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }
          message.launchParams = LaunchParams.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag === 64) {
            message.apiDescriptors.push(launchData_ApiDescriptorFromJSON(reader.int32()));
            continue;
          }
          if (tag === 66) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.apiDescriptors.push(launchData_ApiDescriptorFromJSON(reader.int32()));
            }
            continue;
          }
          break;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }
          message.renderConfig = launchData_RenderConfigFromJSON(reader.int32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }
          message.activationSource = launchData_ActivationSourceFromJSON(reader.int32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }
          message.overridenLaunchTime = fromTimestamp5(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return LaunchData.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseLaunchData();
    message.snappable = object.snappable !== void 0 && object.snappable !== null ? Snappable.fromPartial(object.snappable) : void 0;
    message.lures = object.lures !== void 0 && object.lures !== null ? Lures.fromPartial(object.lures) : void 0;
    message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : "";
    message.entryPoint = (_b = object.entryPoint) !== null && _b !== void 0 ? _b : LaunchData_EntryPoint.LIVE_CAMERA;
    message.userData = object.userData !== void 0 && object.userData !== null ? UserData.fromPartial(object.userData) : void 0;
    message.persistentStore = object.persistentStore !== void 0 && object.persistentStore !== null ? PersistentStore.fromPartial(object.persistentStore) : void 0;
    message.launchParams = object.launchParams !== void 0 && object.launchParams !== null ? LaunchParams.fromPartial(object.launchParams) : void 0;
    message.apiDescriptors = ((_c = object.apiDescriptors) === null || _c === void 0 ? void 0 : _c.map((e2) => e2)) || [];
    message.renderConfig = (_d = object.renderConfig) !== null && _d !== void 0 ? _d : LaunchData_RenderConfig.DEFAULT;
    message.activationSource = (_e = object.activationSource) !== null && _e !== void 0 ? _e : LaunchData_ActivationSource.ACTIVATION_SOURCE_UNSET;
    message.overridenLaunchTime = (_f = object.overridenLaunchTime) !== null && _f !== void 0 ? _f : void 0;
    return message;
  }
};
function toTimestamp5(date) {
  const seconds = Math.trunc(date.getTime() / 1e3).toString();
  const nanos = date.getTime() % 1e3 * 1e6;
  return { seconds, nanos };
}
function fromTimestamp5(t2) {
  let millis = (globalThis.Number(t2.seconds) || 0) * 1e3;
  millis += (t2.nanos || 0) / 1e6;
  return new globalThis.Date(millis);
}

// node_modules/@snap/camera-kit/dist/lens/LensLaunchData.js
var zodiacMap = {
  aquarius: UserData_Zodiac.Aquarius,
  aries: UserData_Zodiac.Aries,
  cancer: UserData_Zodiac.Cancer,
  capricorn: UserData_Zodiac.Capricorn,
  gemini: UserData_Zodiac.Gemini,
  leo: UserData_Zodiac.Leo,
  libra: UserData_Zodiac.Libra,
  pisces: UserData_Zodiac.Pisces,
  sagittarius: UserData_Zodiac.Sagittarius,
  scorpio: UserData_Zodiac.Scorpio,
  taurus: UserData_Zodiac.Taurus,
  virgo: UserData_Zodiac.Virgo
};
var zodiacValueSet = new Set(Object.keys(zodiacMap));
function isZodiac(value) {
  return zodiacValueSet.has(value);
}
function isLensLaunchDataOrUndefined(value) {
  return isUndefined(value) || isLensLaunchData(value);
}
function isLensLaunchData(value) {
  return isRecord(value) && isStringOrUndefined(value.userId) && isLensUserDataOrUndefined(value.userData) && isLensLaunchParamsOrUndefined(value.launchParams);
}
function isLensUserDataOrUndefined(value) {
  return isUndefined(value) || isLensUserData(value);
}
function isLensUserData(value) {
  return isRecord(value) && isStringOrUndefined(value.userId) && isStringOrUndefined(value.username) && isStringOrUndefined(value.birthdate) && isStringOrUndefined(value.displayName) && isStringOrUndefined(value.countrycode) && isStringOrUndefined(value.score) && isBitmojiUserInfoOrUndefined(value.bitmojiInfo) && isFriendUserInfoOrUndefined(value.friendInfo) && isZodiacOrUndefined(value.zodiac);
}
function isBitmojiUserInfoOrUndefined(value) {
  return isUndefined(value) || isBitmojiUserInfo(value);
}
function isBitmojiUserInfo(value) {
  return isRecord(value) && isStringOrUndefined(value.avatarId) && isStringOrUndefined(value.selfieId);
}
function isFriendUserInfoOrUndefined(value) {
  return isUndefined(value) || isFriendUserInfo(value);
}
function isFriendUserInfo(value) {
  return isRecord(value) && isDateOrUndefined(value.friendshipStart) && isDateOrUndefined(value.lastInteraction) && isValidNumberOrUndefined(value.streak);
}
function isZodiacOrUndefined(value) {
  return isUndefined(value) || isZodiac(value);
}
function isLensLaunchParamsOrUndefined(value) {
  return isUndefined(value) || isLensLaunchParams(value);
}
function isLensLaunchParams(value) {
  return isRecord(value) && predicateRecordValues(isStringOrNumberOrArrayOfStringsOrNumbers)(value);
}
function isStringOrNumberOrArrayOfStringsOrNumbers(value) {
  return isString(value) || isValidNumber(value) || isArrayOfType(isString, value) || isArrayOfType(isValidNumber, value);
}
var encodeLensLaunchData = (launchData, persistentStore) => {
  var _a;
  return LaunchData.encode(LaunchData.fromPartial(Object.assign(Object.assign({}, launchData), { userData: launchData.userData ? Object.assign(Object.assign({}, launchData.userData), { zodiac: ((_a = launchData.userData) === null || _a === void 0 ? void 0 : _a.zodiac) ? zodiacMap[launchData.userData.zodiac] : void 0 }) : void 0, launchParams: launchData.launchParams ? encodeLensLaunchParams(launchData.launchParams) : void 0, persistentStore: { store: new Uint8Array(persistentStore) } }))).finish().slice();
};
function encodeLensLaunchParams(launchParams) {
  return { data: new TextEncoder().encode(JSON.stringify(launchParams)) };
}

// node_modules/@snap/camera-kit/dist/transforms/Transform2D.js
var Transform2D = class {
  constructor(matrix) {
    this.matrix = matrix;
  }
};
Transform2D.MirrorX = new Transform2D([-1, 0, 0, 0, 1, 0, 1, 0, 1]);
Transform2D.MirrorY = new Transform2D([1, 0, 0, 0, -1, 0, 0, 1, 1]);
Transform2D.Identity = new Transform2D([1, 0, 0, 0, 1, 0, 0, 0, 1]);
function isTransform2D(value) {
  return value instanceof Transform2D;
}

// node_modules/@snap/camera-kit/dist/media-sources/CameraKitSource.js
var defaultDeviceInfo = {
  cameraType: "user",
  fpsLimit: Number.POSITIVE_INFINITY
};
var createNotAttachedError = (message) => new Error(`${message}. This CameraKitSource is not attached to a CameraKitSession.`);
var cameraTypeValueSet = new Set(Object.keys({
  user: 0,
  environment: 0
}));
function isCameraKitSource(value) {
  return value instanceof CameraKitSource;
}
function isPartialCameraKitDeviceOptionsOrUndefined(value) {
  return isUndefined(value) || isPartialCameraKitDeviceOptions(value);
}
function isPartialCameraKitDeviceOptions(value) {
  return isRecord(value) && isCameraTypeOrUndefined(value.cameraType) && isValidNumberOrUndefined(value.fpsLimit);
}
function isCameraType(value) {
  return cameraTypeValueSet.has(value);
}
function isCameraTypeOrUndefined(value) {
  return isUndefined(value) || isCameraType(value);
}
var CameraKitSource = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _setRenderSize_decorators;
  let _setTransform_decorators;
  return _a = class CameraKitSource2 {
    constructor(sourceInfo, subscriber = {}, deviceInfo = {}) {
      this.sourceInfo = (__runInitializers(this, _instanceExtraInitializers), sourceInfo);
      this.subscriber = subscriber;
      this.deviceInfo = Object.assign(Object.assign({}, defaultDeviceInfo), copyDefinedProperties(deviceInfo));
    }
    attach(lensCore, reportError) {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.lensCore) {
          throw new Error("This CameraKitSource has already been attached to this CameraKitSession and cannot be reattached, even after detachment.");
        }
        this.lensCore = lensCore;
        yield lensCore.useMediaElement({
          autoplayNewMedia: false,
          autoplayPreviewCanvas: false,
          media: this.sourceInfo.media,
          pauseExistingMedia: false,
          replayTrackingData: this.sourceInfo.replayTrackingData,
          requestWebcam: false,
          startOnFrontCamera: ["user", "front"].includes(this.deviceInfo.cameraType),
          useManualFrameProcessing: this.sourceInfo.useManualFrameProcessing
        });
        const fps = this.deviceInfo.fpsLimit < Number.POSITIVE_INFINITY ? this.deviceInfo.fpsLimit : 0;
        yield lensCore.setFPSLimit({ fps });
        yield lensCore.setRenderSize({ mode: "matchInputResolution" });
        if (this.subscriber.onAttach)
          yield this.subscriber.onAttach(this, lensCore, reportError);
      });
    }
    copy(deviceInfo = {}) {
      return new CameraKitSource2(this.sourceInfo, this.subscriber, Object.assign(Object.assign({}, this.deviceInfo), deviceInfo));
    }
    detach(reportError) {
      if (!this.lensCore)
        return Promise.reject(createNotAttachedError("Cannot detach"));
      if (this.subscriber.onDetach)
        return this.subscriber.onDetach(reportError);
    }
    setRenderSize(width2, height2) {
      if (!this.lensCore)
        return Promise.reject(createNotAttachedError("Cannot setRenderSize"));
      const target = { width: width2, height: height2 };
      return this.lensCore.setRenderSize({ mode: "explicit", target });
    }
    setTransform(transform) {
      if (!this.lensCore)
        return Promise.reject(createNotAttachedError("Cannot setTransform"));
      const matrix = new Float32Array(transform.matrix);
      return this.lensCore.setInputTransform({ matrix });
    }
  }, (() => {
    _setRenderSize_decorators = [validate(isValidNumber, isValidNumber)];
    _setTransform_decorators = [validate(isTransform2D)];
    __esDecorate(_a, null, _setRenderSize_decorators, { kind: "method", name: "setRenderSize", static: false, private: false, access: { has: (obj) => "setRenderSize" in obj, get: (obj) => obj.setRenderSize } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _setTransform_decorators, { kind: "method", name: "setTransform", static: false, private: false, access: { has: (obj) => "setTransform" in obj, get: (obj) => obj.setTransform } }, null, _instanceExtraInitializers);
  })(), _a;
})();

// node_modules/@snap/camera-kit/dist/observable-operators/debounceTimeAfter.js
function debounceTimeAfter(amount, duration, scheduler = asyncScheduler) {
  return (source) => {
    return new Observable((subscriber) => {
      let iterationCount = 0;
      return source.pipe(tap((value) => {
        iterationCount++;
        if (iterationCount <= amount) {
          subscriber.next({ type: "initial", value });
        }
      }), buffer(source.pipe(debounceTime(duration, scheduler))), tap((values) => {
        if (iterationCount > amount) {
          subscriber.next({ type: "debounced", values: values.slice(amount) });
        }
        iterationCount = 0;
      })).subscribe();
    });
  };
}

// node_modules/@snap/camera-kit/dist/media-sources/MediaStreamSource.js
var defaultOptions3 = Object.assign(Object.assign({}, defaultDeviceInfo), { transform: Transform2D.Identity, disableSourceAudio: false });
function closeWorklet(worklet) {
  if (!worklet)
    return;
  worklet.port.close();
  worklet.port.onmessage = null;
  worklet.disconnect();
}
function closeAudioContext(audioContext) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!audioContext || audioContext.state === "closed")
      return;
    return audioContext.close();
  });
}
function handleAudioProcessingErrors(errors, reportError) {
  return errors.pipe(debounceTimeAfter(1, 1e3), map((event) => {
    if (event.type === "initial") {
      reportError(new Error("The first audio processing error before debouncing.", { cause: event.value }));
    } else if (event.type === "debounced") {
      const errorMessages = [...new Set(event.values.map(stringifyErrorMessage))].join("\n");
      reportError(new Error(`Debounced ${event.values.length} audio processing errors.`, {
        cause: new Error(errorMessages)
      }));
    }
  })).subscribe();
}
function createMediaStreamSource(stream, options = {}) {
  var _a;
  const { facingMode } = stream.getVideoTracks().length > 0 ? stream.getVideoTracks()[0].getSettings() : { facingMode: void 0 };
  const detectedCameraType = facingMode === "user" || facingMode === "environment" ? facingMode : void 0;
  const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaultOptions3), copyDefinedProperties(options)), { cameraType: (_a = options.cameraType) !== null && _a !== void 0 ? _a : detectedCameraType });
  const enableSourceAudio = stream.getAudioTracks().length > 0 && !optionsWithDefaults.disableSourceAudio;
  const simulateStereoAudio = true;
  const sampleRate = 44100;
  let audioContext = void 0;
  let audioSource = void 0;
  let worklet = void 0;
  let microphoneRecorderUrl;
  if (enableSourceAudio) {
    const microphoneRecorderWorklet = `
        class MicrophoneWorkletProcessor extends AudioWorkletProcessor {
            process(inputs, outputs, parameters) {
                this.port.postMessage({
                    eventType: 'data',
                    buffer: inputs
                });
                return true;
            }
        }
        registerProcessor('microphone-worklet', MicrophoneWorkletProcessor);`;
    const microphoneRecorderBlob = new Blob([microphoneRecorderWorklet], {
      type: "application/javascript"
    });
    microphoneRecorderUrl = URL.createObjectURL(microphoneRecorderBlob);
  }
  let audioProcessingErrorSubscription = void 0;
  return new CameraKitSource({ media: stream }, {
    onAttach: (source, lensCore, reportError) => __awaiter(this, void 0, void 0, function* () {
      yield source.setTransform(optionsWithDefaults.transform);
      if (enableSourceAudio) {
        const audioProcessingErrors = new Subject();
        audioProcessingErrorSubscription = handleAudioProcessingErrors(audioProcessingErrors, reportError);
        yield lensCore.setAudioParameters({
          parameters: {
            numChannels: simulateStereoAudio ? 2 : 1,
            sampleRate
          }
        });
        try {
          closeWorklet(worklet);
          audioSource === null || audioSource === void 0 ? void 0 : audioSource.disconnect();
          yield closeAudioContext(audioContext);
        } catch (error) {
          reportError(ensureError(error));
        }
        audioContext = new AudioContext();
        audioSource = audioContext.createMediaStreamSource(stream);
        const scopedAudioSource = audioSource;
        audioContext.audioWorklet.addModule(microphoneRecorderUrl).then(() => {
          if (audioContext) {
            worklet = new AudioWorkletNode(audioContext, "microphone-worklet");
            scopedAudioSource.connect(worklet);
            worklet.connect(audioContext.destination);
            worklet.port.onmessage = (e2) => {
              if (e2.data.eventType === "data") {
                const leftSamples = e2.data.buffer[0][0];
                if (!leftSamples)
                  return;
                let inputBuffers = [leftSamples];
                if (simulateStereoAudio) {
                  const rightSamples = e2.data.buffer[0].length > 1 ? e2.data.buffer[0][1] : leftSamples.slice();
                  inputBuffers.push(rightSamples);
                }
                lensCore.processAudioSampleBuffer({ input: inputBuffers }).catch((error) => audioProcessingErrors.next(error));
              }
            };
          }
        }).catch((error) => {
          reportError(error);
        });
      }
    }),
    onDetach: (reportError) => __awaiter(this, void 0, void 0, function* () {
      if (worklet) {
        closeWorklet(worklet);
        worklet = void 0;
      }
      if (audioSource) {
        audioSource.disconnect();
        audioSource = void 0;
      }
      if (audioContext) {
        yield closeAudioContext(audioContext).catch(reportError);
        audioContext = void 0;
      }
      if (audioProcessingErrorSubscription) {
        audioProcessingErrorSubscription.unsubscribe();
        audioProcessingErrorSubscription = void 0;
      }
    })
  }, optionsWithDefaults);
}

// node_modules/@snap/camera-kit/dist/media-sources/VideoSource.js
var defaultOptions4 = Object.assign(Object.assign({}, defaultDeviceInfo), { trackingData: new ArrayBuffer(0) });
function createVideoSource(video, options = {}) {
  const { trackingData } = Object.assign(Object.assign({}, defaultOptions4), copyDefinedProperties(options));
  const replayTrackingData = trackingData.byteLength > 0 ? { buffer: trackingData } : void 0;
  return new CameraKitSource({
    media: video,
    replayTrackingData
  }, {}, options);
}

// node_modules/@snap/camera-kit/dist/logger/logEntries.js
var logEntriesFactory = Injectable("logEntries", () => resetLogger().asObservable());

// node_modules/@snap/camera-kit/dist/session/LensPerformanceMeasurement.js
var getDefaultFrameMetricsState = () => ({
  avgFps: 0,
  averageProcessingTime: 0,
  n: 0,
  processingTimeBuckets: new Uint32Array(frameProcessingTimeMedianMax + 1),
  procFrameCount: 0,
  procFrameMean: 0,
  procFrameD2: 0
});
var frameDurationThreshold = 1;
var frameProcessingTimeMedianMax = 200;
var LensPerformanceMeasurement = class {
  constructor(instances) {
    this.instances = instances;
    this.state = Object.assign({}, getDefaultFrameMetricsState());
    this.instances.add(this);
  }
  update(processingTimeMs) {
    this.computeRunningStats(processingTimeMs);
  }
  measure() {
    let median = 0;
    let count2 = 0;
    for (; median < this.state.processingTimeBuckets.length; median++) {
      count2 += this.state.processingTimeBuckets[median];
      if (count2 >= (this.state.n + 1) / 2)
        break;
    }
    return {
      avgFps: this.state.avgFps,
      lensFrameProcessingTimeMsAvg: this.state.procFrameMean,
      lensFrameProcessingTimeMsStd: Math.sqrt(this.state.procFrameD2 / this.state.procFrameCount),
      lensFrameProcessingTimeMsMedian: this.state.n > 0 ? median : 0,
      lensFrameProcessingN: this.state.n
    };
  }
  reset() {
    this.state = Object.assign({}, getDefaultFrameMetricsState());
  }
  end() {
    this.instances.delete(this);
  }
  computeRunningStats(processingTimeMs) {
    const delta = processingTimeMs - this.state.procFrameMean;
    this.state.procFrameCount += 1;
    this.state.procFrameMean += delta / this.state.procFrameCount;
    const delta2 = processingTimeMs - this.state.procFrameMean;
    this.state.procFrameD2 += delta * delta2;
    if (this.priorFrameCompletedTime === void 0) {
      this.priorFrameCompletedTime = performance.now();
    } else {
      const frameDurationSec = (performance.now() - this.priorFrameCompletedTime) / 1e3;
      if (frameDurationSec < frameDurationThreshold) {
        this.state.avgFps = (this.state.avgFps + 1 / frameDurationSec) / 2;
      }
      this.priorFrameCompletedTime = performance.now();
    }
    this.state.n++;
    this.state.processingTimeBuckets[Math.min(Math.round(processingTimeMs), frameProcessingTimeMedianMax)]++;
  }
};

// node_modules/@snap/camera-kit/dist/session/LensPerformanceMetrics.js
var logger9 = getLogger("RenderingMetrics");
var LensPerformanceMetrics = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _beginMeasurement_decorators;
  return _a = class LensPerformanceMetrics {
    constructor(lensCore) {
      this.lensCore = (__runInitializers(this, _instanceExtraInitializers), lensCore);
      this.measurementInstances = /* @__PURE__ */ new Set();
      this.lensCore.setOnFrameProcessedCallback({
        onFrameProcessed: ({ processingTimeMs }) => {
          try {
            for (const measurement of this.measurementInstances.values()) {
              measurement.update(processingTimeMs);
            }
          } catch (error) {
            logger9.error(error);
          }
        }
      }).catch((error) => logger9.error(`Failed registering setOnFrameProcessedCallback with error: ${error.message}`));
    }
    beginMeasurement() {
      return new LensPerformanceMeasurement(this.measurementInstances);
    }
  }, (() => {
    _beginMeasurement_decorators = [errorLoggingDecorator(logger9)];
    __esDecorate(_a, null, _beginMeasurement_decorators, { kind: "method", name: "beginMeasurement", static: false, private: false, access: { has: (obj) => "beginMeasurement" in obj, get: (obj) => obj.beginMeasurement } }, null, _instanceExtraInitializers);
  })(), _a;
})();

// node_modules/@snap/camera-kit/dist/lens/LensPersistenceStore.js
var logger10 = getLogger("LensPersistenceStore");
var lensPersistenceStoreFactory = Injectable("lensPersistenceStore", [lensCoreFactory.token], (lensCore) => {
  const db = new IndexedDBPersistence({ databaseName: "lensPersistenceStore" });
  lensCore.registerSavePersistentStoreCallback((id, data) => __awaiter(void 0, void 0, void 0, function* () {
    try {
      yield db.store(id, data);
    } catch (error) {
      logger10.error(persistentStoreError(`Error occurred while storing data for lens ${id}.`, error));
    }
  }));
  return db;
});

// node_modules/@snap/camera-kit/dist/common/localization.js
function makeTemplate(keys) {
  return (template) => (values) => {
    const tag = (readonlyStrings) => {
      const strings = readonlyStrings.slice();
      return [strings.shift()].concat(keys.map((key) => {
        var _a;
        return `${(_a = values[key]) !== null && _a !== void 0 ? _a : ""}${strings.shift()}`;
      })).concat(strings).join("");
    };
    return template(tag);
  };
}
var legalPromptMessage = makeTemplate(["privacyPolicyUrl", "termsOfServiceUrl", "learnMoreUrl"]);
var allStrings = {
  "en-US": {
    legalPromptMessage: legalPromptMessage((tag) => tag`By using Lenses, you acknowledge reading Snaps <a href="${0}" target="_blank">Privacy Policy</a> and agree to Snaps <a href="${0}" target="_blank">Terms of Service</a>. Some lenses use information about your face, hands and voice to work. <a href="${0}" target="_blank">Learn More</a>, and if you want to agree and continue, tap below.`),
    legalPromptAccept: `I Agree`,
    legalPromptReject: `Dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `This feature uses information about face(s), hands and voice(s) detected by the camera and microphone to work. With this feature, you can apply fun and useful augmented reality effects on top of selfies and images. Our camera uses technology to locate certain features (like where your hands, eyes, and nose are) and uses that information to accurately position the feature with the image sensed by the camera. Any information that is collected will be deleted as soon as possible (typically soon after the app is closed) and always within no more than three years.<br/><br/>If you want to agree and continue, tap below.`,
    legalPromptVariantGAdultOrChild: `Are you an adult or child?`,
    legalPromptVariantGFindYourParent: `Please find your parent or legal guardian.`,
    legalPromptVariantGIAmGuardian: `I am the child's guardian`,
    legalPromptVariantGCancel: `Cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Child`
  },
  ar: {
    legalPromptMessage: legalPromptMessage((tag) => tag`     <a href="${0}" target="_blank"> </a>   <a href="${0}" target="_blank"> </a>  .          . <a href="${0}" target="_blank">    </a>      .`),
    legalPromptAccept: ` `,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `     ()  ()    .              .         (     )            .           (     )        .<br/><br/>      .`,
    legalPromptVariantGAdultOrChild: `     `,
    legalPromptVariantGFindYourParent: `       .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ` `,
    legalPromptVariantGChild: ``
  },
  "bn-BD": {
    legalPromptMessage: legalPromptMessage((tag) => tag`     Snap- <a href="${0}" target="_blank"> </a>   Snap- <a href="${0}" target="_blank"> </a>-             ,      <a href="${0}" target="_blank"> </a>             `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `          ,                             (  ,    )                              (    )          <br/><br/>            `,
    legalPromptVariantGAdultOrChild: `    ?`,
    legalPromptVariantGFindYourParent: `       `,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "bn-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap\' \"<a href="${0}" target="_blank">\" </a>   Snap\' <a href="${0}" target="_blank"> </a>-             ,       <a href="${0}" target="_blank"> </a>           `),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `           (),   ()       ,                         (  ,    )                    <br/><br/>       ,   `,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `   -    `,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "da-DK": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Nr du anvender Linser, bekrfter du, at du har lst Snaps <a href="${0}" target="_blank">privatlivspolitik</a> og accepterer Snaps <a href="${0}" target="_blank">servicevilkr</a>. Nogle Linser bruger information om dit ansigt, dine hnder og din stemme for at fungere. <a href="${0}" target="_blank">F mere at vide</a>, og tryk nedenfor, hvis du vil acceptere og fortstte.`),
    legalPromptAccept: `Jeg er enig`,
    legalPromptReject: `Afvis`,
    legalPromptTermsOfService: `Servicevilkr`,
    legalPromptVariantGMessage: `Denne funktion bruger oplysninger om ansigt(er), hnder og stemme(r), der registreres af kameraet og mikrofonen, for at kunne fungere. Med denne funktion kan du anvende sjove og nyttige augmented reality-effekter p selfies og billeder. Vores kamera bruger teknologi til at finde bestemte trk (f.eks. hvor dine hnder, jne og nse er) og bruger disse oplysninger til njagtigt at placere trkket i billedet, der opfanges af kameraet. Alle oplysninger, der indsamles, slettes s hurtigst som muligt (typisk kort efter, at appen lukkes) og altid inden for hjst tre r.<br/><br/>Tryk herunder, hvis du accepterer og vil fortstte.`,
    legalPromptVariantGAdultOrChild: `Er du voksen eller barn?`,
    legalPromptVariantGFindYourParent: `Find din forlder eller vrge.`,
    legalPromptVariantGIAmGuardian: `Jeg er barnets vrge`,
    legalPromptVariantGCancel: `Annuller`,
    legalPromptVariantGAdult: `Voksen`,
    legalPromptVariantGChild: `Barn`
  },
  "de-DE": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Wenn du Linsen verwendet, versicherst du, dass du die <a href="${0}" target="_blank">Datenschutzbestimmungen</a> von Snap gelesen hast und den <a href="${0}" target="_blank">Servicebestimmungen</a> von Snap zustimmst. Manche Linsen verarbeiten Informationen zu deinem Gesicht, deinen Hnden und deiner Stimme, um zu funktionieren. <a href="${0}" target="_blank">Hier erfhrst du mehr.</a> Tippe unten, wenn du zustimmen und fortfahren mchtest.`),
    legalPromptAccept: `Zustimmen`,
    legalPromptReject: `Ablehnen`,
    legalPromptTermsOfService: `Servicebestimmungen`,
    legalPromptVariantGMessage: `Diese Funktion verwendet Informationen ber Gesichter, Hnde und Stimmen, die von der Kamera und dem Mikrofon erkannt werden. Mit dieser Funktion kannst du lustige und ntzliche Augmented Reality-Effekte auf Selfies und Bilder anwenden. Unsere Kamera nutzt Technologien, um bestimmte Merkmale zu lokalisieren (z. B. wo sich deine Hnde, Augen und Nase befinden), und verwendet diese Informationen, um dieses Merkmal dann exakt ber das von der Kamera erfasste Bild zu positionieren. Alle gesammelten Informationen werden so schnell wie mglich gelscht (in der Regel kurz nach dem Schlieen der App), sptestens aber innerhalb von dreiJahren.<br/><br/>Tippe unten, um zuzustimmen und fortzufahren.`,
    legalPromptVariantGAdultOrChild: `Bist du erwachsen oder minderjhrig?`,
    legalPromptVariantGFindYourParent: `Bitte hole ein Elternteil oder Erziehungsberechtigten.`,
    legalPromptVariantGIAmGuardian: `Ich bin der Erziehungsberechtigte des Kindes.`,
    legalPromptVariantGCancel: `Abbrechen`,
    legalPromptVariantGAdult: `Erwachsen`,
    legalPromptVariantGChild: `Minderjhrig`
  },
  "el-GR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,      <a href="${0}" target="_blank"> </a>  Snap      <a href="${0}" target="_blank"> </a>  Snap.        ,         . <a href="${0}" target="_blank"> </a>        ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `        ,             ,   .                 .            (    ,      )                   .          (      )          .<br/><br/>     ,  .`,
    legalPromptVariantGAdultOrChild: `   ;`,
    legalPromptVariantGFindYourParent: `       .`,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "en-GB": {
    legalPromptMessage: legalPromptMessage((tag) => tag`By using Lenses, you acknowledge reading Snap\s <a href="${0}" target="_blank">Privacy Policy</a> and agree to Snap\s <a href="${0}" target="_blank">Terms of Service</a>. Some Lenses use information about your face, hands and voice to work. <a href="${0}" target="_blank">Learn More</a>, and if you want to agree and continue, tap below.`),
    legalPromptAccept: `I agree`,
    legalPromptReject: `Dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `This feature uses information about face(s), hands and voice(s) detected by the camera and microphone to work. With this feature, you can apply fun and useful augmented reality effects on top of selfies and images. Our camera uses technology to locate certain features (like where your hands, eyes and nose are) and uses that information to accurately position the feature with the image sensed by the camera. Any information that is collected will be deleted as soon as possible (typically soon after the app is closed) and always within no more than three years.<br/><br/>If you want to agree and continue, tap below.`,
    legalPromptVariantGAdultOrChild: `Are you an adult or child?`,
    legalPromptVariantGFindYourParent: `Please find your parent or legal guardian.`,
    legalPromptVariantGIAmGuardian: `I am the childs guardian`,
    legalPromptVariantGCancel: `Cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Child`
  },
  es: {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar Lentes, confirmas que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> de Snap y aceptas las <a href="${0}" target="_blank">Condiciones de servicio</a>. Algunos Lentes funcionan usando informacin acerca de tu cara, tus manos y tu voz. <a href="${0}" target="_blank">Obtn ms informacin</a> y, si quieres aceptar y continuar, toca a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Ignorar`,
    legalPromptTermsOfService: `Condiciones de servicio`,
    legalPromptVariantGMessage: `Esta funcin utiliza informacin sobre caras, manos y voces detectadas por la cmara y el micrfono para funcionar. Con esta funcin, puedes aplicar divertidos y tiles efectos de realidad aumentada sobre selfies e imgenes. Nuestra cmara utiliza tecnologa para localizar ciertos rasgos (como dnde estn las manos, los ojos y la nariz) y utiliza dicha informacin para posicionar correctamente el rasgo sobre la imagen detectada por la cmara. Toda la informacin recopilada se eliminar tan pronto como sea posible (por lo general, poco despus de que se cierre la app), siempre en un plazo menor a tres aos.<br/><br/>Para aceptar y continuar, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busca a tu padre, madre o tutor legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Mayor de edad`,
    legalPromptVariantGChild: `Menor de edad`
  },
  "es-AR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar los Lentes, confirms que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> de Snap y que acepts sus <a href="${0}" target="_blank">Condiciones de servicio</a>. Algunos Lentes usan informacin sobre tu cara, tus manos y tu voz para funcionar. <a href="${0}" target="_blank">Obten ms informacin</a>, y si quers aceptar y continuar, toc el botn que aparece ms abajo.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Omitir`,
    legalPromptTermsOfService: `Condiciones de servicio`,
    legalPromptVariantGMessage: `Esta funcin utiliza la informacin sobre caras, manos y voces detectadas por la cmara y el micrfono. Con esta funcin, pods aplicar divertidos y tiles efectos de realidad aumentada sobre selfies e imgenes. Nuestra cmara utiliza tecnologa para localizar ciertos rasgos (como dnde estn las manos, los ojos y la nariz) y utiliza esa informacin para posicionar con precisin el rasgo con la imagen detectada por la cmara. Toda la informacin recopilada se eliminar lo antes posible (normalmente poco despus de cerrar la aplicacin) y siempre en un plazo mximo de tresaos.<br/><br/>Si deseas aceptar y continuar, toc a continuacin.`,
    legalPromptVariantGAdultOrChild: `Sos mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busc a tu padre, madre o tutor legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Mayor de edad`,
    legalPromptVariantGChild: `Menor de edad`
  },
  "es-ES": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar las Lentes, reconoces haber ledo la <a href="${0}" target="_blank">Poltica de privacidad</a> y aceptas los <a href="${0}" target="_blank">Trminos del servicio</a> de Snap. Algunas Lentes funcionan utilizando informacin de tu cara, tus manos o tu voz. Puedes obtener <a href="${0}" target="_blank">ms informacin</a>, y si quieres aceptar y continuar, toca el botn a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Descartar`,
    legalPromptTermsOfService: `Trminos del servicio`,
    legalPromptVariantGMessage: `Para su funcionamiento, esta funcin hace uso de los datos sobre la cara, las manos y las voces detectados por la cmara y el micrfono. Con ella, puedes aplicar efectos de realidad aumentada, tanto tiles como divertidos, en selfies e imgenes. Nuestra cmara utiliza la tecnologa para localizar determinados elementos (como la posicin de las manos, los ojos o la nariz) y utiliza esta informacin para colocar el elemento sobre la imagen de forma fiel, segn lo detectado por la cmara. Cualquier informacin que se recopile se eliminar lo antes posible (normalmente, al cerrar la aplicacin) y nunca se almacenar durante ms de tres aos.<br/><br/>Si quieres aceptar y continuar, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres una persona adulta o eres menor?`,
    legalPromptVariantGFindYourParent: `Habla con tu padre, madre o tutor/a legal.`,
    legalPromptVariantGIAmGuardian: `Soy el tutor o tutora legal del menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Menor`
  },
  "es-MX": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Al usar Lentes, confirmas que leste la <a href="${0}" target="_blank">Poltica de privacidad</a> y aceptas los <a href="${0}" target="_blank">Trminos y condiciones de servicio</a> de Snap. Algunos lentes usan informacin sobre tu cara, manos o voz para funcionar. <a href="${0}" target="_blank">Obtn ms informacin</a> y, si quieres aceptarlo, toca a continuacin.`),
    legalPromptAccept: `Acepto`,
    legalPromptReject: `Ignorar`,
    legalPromptTermsOfService: `Trminos y condiciones de servicio`,
    legalPromptVariantGMessage: `Esta caracterstica utiliza informacin sobre la(s) cara(s), manos y voz o voces detectadas por la cmara y el micrfono para funcionar. Con ella, puedes aplicar efectos de realidad aumentada tiles y divertidos a selfies e imgenes. Nuestra cmara usa tecnologa para localizar ciertos rasgos (como dnde estn tus manos, ojos y nariz) y utiliza esa informacin para posicionar con precisin esta caracterstica con la imagen que la cmara percibi. Toda la informacin que se recopile se eliminar lo ms pronto posible (por lo general, poco despus de cerrar la app) y nunca exceder los tres das.<br/><br/>Si quieres aceptar y proseguir, toca a continuacin.`,
    legalPromptVariantGAdultOrChild: `Eres mayor o menor de edad?`,
    legalPromptVariantGFindYourParent: `Busca a tu madre, padre o quien tenga tu custodia legal.`,
    legalPromptVariantGIAmGuardian: `Tengo la custodia de la persona menor`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Persona adulta`,
    legalPromptVariantGChild: `Persona menor`
  },
  "fi-FI": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Kyttmll tehosteita ilmaiset lukeneesi Snapin <a href="${0}" target="_blank">tietosuojaselosteen</a> ja hyvksyvsi Snapin <a href="${0}" target="_blank">palveluehdot</a>. Jotkin tehosteet kyttvt toimintaan tietoja kasvoistasi, ksistsi ja nestsi. <a href="${0}" target="_blank">Listietoja saat tlt</a>. Hyvksy ja jatka napauttamalla alla olevaa painiketta.`),
    legalPromptAccept: `Hyvksyn`,
    legalPromptReject: `Hylk`,
    legalPromptTermsOfService: `Palveluehdot`,
    legalPromptVariantGMessage: `Tm ominaisuus kytt toimiakseen tietoja kameran ja mikrofonin havaitsemista kasvoista, ksist ja nist. Ominaisuudella voit list hauskoja ja hydyllisi listyn todellisuuden efektej selfieiden ja kuvien plle. Kameramme kytt teknologiaa tiettyjen piirteiden paikallistamiseen (kuten ksiesi, silmiesi ja nensi sijaintiin) ja kytt nit tietoja ominaisuuden asettamiseen oikeaan kohtaan kameran havaitsemassa kuvassa. Kaikki kertyt tiedot poistetaan mahdollisimman pian (yleens pian sovelluksen sulkemisen jlkeen) ja aina viimeistn kolmen vuoden kuluttua.<br/><br/>Jos haluat hyvksy ja jatkaa, napauta painiketta alla. `,
    legalPromptVariantGAdultOrChild: `Oletko aikuinen vai lapsi?`,
    legalPromptVariantGFindYourParent: `Etsi vanhempasi tai huoltajasi.`,
    legalPromptVariantGIAmGuardian: `Olen lapsen huoltaja`,
    legalPromptVariantGCancel: `Peruuta`,
    legalPromptVariantGAdult: `Aikuinen`,
    legalPromptVariantGChild: `Lapsi`
  },
  "fil-PH": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Sa pamamagitan ng paggamit sa Lenses, kinikilala mong binasa mo ang <a href="${0}" target="_blank">Privacy Policy</a> ng Snap at sumasang-ayon ka sa <a href="${0}" target="_blank">Terms of Service</a> ng Snap. Ang ilang lens ay gumagamit ng impormasyon tungkol sa iyong mukha , mga kamay at boses para gumana. <a href="${0}" target="_blank">Alamin Pa</a>, at kung gusto mong sumang-ayon at magpatuloy, mag-tap sa ibaba.`),
    legalPromptAccept: `Sang-ayon Ako`,
    legalPromptReject: `I-dismiss`,
    legalPromptTermsOfService: `Terms of Service`,
    legalPromptVariantGMessage: `Ang feature na ito ay gumagamit ng impormasyon tungkol sa (mga) mukha, mga kamay at (mga) boses na nade-detect ng camera at microphone para gumana ito. Gamit ang feature na ito, pwede kang mag-apply ng nakakatuwa at kapaki-pakinabang na augmented reality effects sa ibabaw ng mga selfie at image. Gumagamit ang camera namin ng technology para matukoy ang mga partikular na anyo (tulad ng kung nasaan ang iyong mga kamay, mga mata, at ilong) at ginagamit nito ang impormasyong iyon para eksaktong mapwesto ang anyong iyon sa image na nase-sense ng camera. Ang anumang impormasyong kinokolekta ay ide-delete sa lalong madaling panahon (karaniwan ay maikling panahon lang matapos isara ang app) at palaging hindi lalampas nang tatlong taon.<br/><br/>Kung gusto mong sumang-ayon at magpatuloy, mag-tap sa ibaba.`,
    legalPromptVariantGAdultOrChild: `Isa ka bang adult o bata?`,
    legalPromptVariantGFindYourParent: `Pakihanap ang iyong magulang o legal guardian.`,
    legalPromptVariantGIAmGuardian: `Ako ang guardian ng bata`,
    legalPromptVariantGCancel: `I-cancel`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Bata`
  },
  "fr-FR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`En utilisant les Lenses, vous reconnaissez avoir lu la <a href="${0}" target="_blank">Politique de confidentialit</a> de Snap et vous acceptez les <a href="${0}" target="_blank">Conditions d\'utilisation du service</a> de Snap. Le fonctionnement de certaines Lenses requiert l\'utilisation d\'informations sur votre visage, vos mains et votre voix. <a href="${0}" target="_blank">En savoir plus</a>. Si vous acceptez ces conditions et souhaitez continuer, appuyez ci-dessous.`),
    legalPromptAccept: `J'accepte`,
    legalPromptReject: `Ignorer`,
    legalPromptTermsOfService: `Conditions d'utilisation du service`,
    legalPromptVariantGMessage: `Pour fonctionner, cette fonctionnalit utilise des informations sur le ou les visages, les mains et la ou les voix dtects par l'appareil photo et le micro. Elle vous permet d'appliquer des effets en ralit augmente amusants et utiles sur vos selfies et vos images. Notre appareil photo utilise une technologie qui localise certaines caractristiques (comme l'emplacement de vos mains, de vos yeux et de votre nez) afin de positionner avec prcision la fonctionnalit sur l'image dtecte par l'appareil photo. Toutes les informations collectes sont supprimes ds que possible (gnralement peu aprs la fermeture de l'application) et toujours dans un dlai maximum de trois ans.<br/><br/>Si vous souhaitez accepter et continuer, appuyez ci-dessous.`,
    legalPromptVariantGAdultOrChild: `tes-vous adulte ou mineur?`,
    legalPromptVariantGFindYourParent: `Veuillez appeler votre parent ou votre tuteurrice.`,
    legalPromptVariantGIAmGuardian: `Je suis le ou la tuteurrice de l'enfant.`,
    legalPromptVariantGCancel: `Annuler`,
    legalPromptVariantGAdult: `Adulte`,
    legalPromptVariantGChild: `Mineur`
  },
  "gu-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,      Snap <a href="${0}" target="_blank"> </a>    Snap <a href="${0}" target="_blank"> </a>   .          ,      . <a href="${0}" target="_blank"> </a>,       ,    .`),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `            (),   ()     .                  .     (   ,      )                       .          (       )        .<br/><br/>        ,    .`,
    legalPromptVariantGAdultOrChild: `    ?`,
    legalPromptVariantGFindYourParent: `   -    .`,
    legalPromptVariantGIAmGuardian: `   .`,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "hi-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`   ,       Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank"> </a>           ,        <a href="${0}" target="_blank"> </a>,           ,    `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `          ,   ()                                   ( ,  ,     )                                         (     )            <br/><br/>        ,    `,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `  -      `,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "id-ID": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dengan menggunakan Lensa, kamu menyatakan bahwa kamu sudah membaca <a href="${0}" target="_blank">Kebijakan Privasi</a> Snap dan menyetujui <a href="${0}" target="_blank">Ketentuan Layanan</a> Snap. Beberapa lensa menggunakan informasi tentang wajah, tangan, dan suaramu agar bisa berfungsi dengan baik. <a href="${0}" target="_blank">Pelajari Selengkapnya</a>, dan silakan ketuk tombol di bawah jika kamu ingin menyetujuinya dan melanjutkan.`),
    legalPromptAccept: `Saya setuju`,
    legalPromptReject: `Tutup`,
    legalPromptTermsOfService: `Ketentuan Layanan`,
    legalPromptVariantGMessage: `Agar bisa berfungsi, fitur ini menggunakan informasi terkait wajah, tangan, dan suara yang dideteksi oleh kamera serta mikrofon. Dengan fitur ini, efek augmented reality yang menyenangkan dan berguna dapat diterapkan ke selfie dan gambar. Kamera kami menggunakan teknologi untuk menemukan lokasi fitur tertentu (misalnya menemukan bagian tangan, mata, dan hidung), lalu menggunakan informasi tersebut untuk menempatkan fitur secara akurat di gambar yang dideteksi oleh kamera. Informasi apa pun yang dikumpulkan akan segera dihapus (biasanya setelah aplikasi ditutup) dan selalu disimpan tidak lebih dari tiga tahun.<br/><br/>Jika ingin menyetujui dan melanjutkan, ketuk tombol di bawah ini.`,
    legalPromptVariantGAdultOrChild: `Apakah kamu orang dewasa atau anak-anak?`,
    legalPromptVariantGFindYourParent: `Panggil orang tua atau wali resmi.`,
    legalPromptVariantGIAmGuardian: `Saya wali si anak`,
    legalPromptVariantGCancel: `Batal`,
    legalPromptVariantGAdult: `Orang Dewasa`,
    legalPromptVariantGChild: `Anak-Anak`
  },
  "it-IT": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Usando le Lenti, confermi di aver letto l\'<a href="${0}" target="_blank">Informativa sulla Privacy</a> di Snap Inc. e di accettare i <a href="${0}" target="_blank">Termini di Servizio</a> di Snap Inc. Alcune Lenti utilizzano informazioni sul tuo viso, le tue mani e la tua voce per funzionare. <a href="${0}" target="_blank">Scopri di pi</a> e, se sei d\'accordo e vuoi continuare, tocca qui sotto.`),
    legalPromptAccept: `Accetto`,
    legalPromptReject: `Ignora`,
    legalPromptTermsOfService: `Termini di Servizio`,
    legalPromptVariantGMessage: `Questa funzionalit utilizza le informazioni su viso, mani e voce rilevate dalla fotocamera e dal microfono per funzionare. Ti consente di applicare effetti in realt aumentata divertenti e utili ai selfie e alle immagini. La nostra Fotocamera sfrutta una tecnologia specifica per individuare certe parti del corpo (ad esempio mani, occhi e naso) e usa questi dati per posizionarle in modo accurato sull'immagine rilevata. Qualsiasi informazione raccolta viene eliminata appena possibile (di solito poco dopo la chiusura dell'app) e, in ogni caso, entro 3 anni.<br/><br/>Se sei d'accordo e vuoi continuare, tocca qui sotto.`,
    legalPromptVariantGAdultOrChild: `Sei un adulto o un minore?`,
    legalPromptVariantGFindYourParent: `C' bisogno di un genitore o tutore legale.`,
    legalPromptVariantGIAmGuardian: `Sono il tutore del minore`,
    legalPromptVariantGCancel: `Annulla`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Minore`
  },
  "ja-JP": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Snap<a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `Snap3<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "kn-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  , Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank"> </a>  .     ,     . <a href="${0}" target="_blank"> </a>,       ,   .`),
    legalPromptAccept: ` `,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `       (),   ()   .  ,            .     ( ,     )             .       (    )      . <br/><br/>     ,   .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ko-KR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  Snap <a href="${0}" target="_blank"> </a>  Snap <a href="${0}" target="_blank"> </a>   .    ,     . <a href="${0}" target="_blank"> </a>,     .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `     , ,     .              . Snapchat   (: ,    )   ,          .      (   ) ,  3  .<br/><br/>   .`,
    legalPromptVariantGAdultOrChild: `, ?`,
    legalPromptVariantGFindYourParent: `     .`,
    legalPromptVariantGIAmGuardian: ` `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ml-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`   Snap- <a href="${0}" target="_blank"> </a>   Snap- <a href="${0}" target="_blank"> </a>  .     , ,    . <a href="${0}" target="_blank"></a>,     .`),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `   ,    (),  ()    .       ,     .       (  , ,   )  ,             .      (   )   () .<br/><br/>    .`,
    legalPromptVariantGAdultOrChild: `     ?`,
    legalPromptVariantGFindYourParent: `    .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "mr-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag` ,      Snap  <a href="${0}" target="_blank"> </a>    Snap  <a href="${0}" target="_blank"> </a>  .      ,      . <a href="${0}" target="_blank">  </a>          .`),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `        (),     .  ,             .     (   ,     )              .        (    )       .<br/><br/>       ,   .`,
    legalPromptVariantGAdultOrChild: `      ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "ms-MY": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dengan menggunakan Lensa, anda mengakui membaca <a href="${0}" target="_blank">Dasar Privasi</a> Snap dan bersetuju dengan <a href="${0}" target="_blank">Syarat Perkhidmatan</a> Snap. Sesetengan lensa menggunakan maklumat tentang muka anda, tangan dan suara untuk berfungsi. <a href="${0}" target="_blank">Ketahui Lebih Lanjut</a>, dan jika anda mahu bersetuju dan teruskan, ketik di bawah.`),
    legalPromptAccept: `Saya Setuju`,
    legalPromptReject: `Abaikan`,
    legalPromptTermsOfService: `Syarat Perkhidmatan`,
    legalPromptVariantGMessage: `Ciri ini menggunakan maklumat muka, tangan dan suara yang dikesan oleh kamera dan mikrofon untuk berfungsi. Dengan ciri ini, anda boleh menggunakan kesan realiti tambahan yang menyeronokkan dan berguna selain swafoto dan gambar. Kamera kami menggunakan teknologi untuk mengesan ciri tertentu (seperti di mana tangan, mata dan hidung anda) dan menggunakan maklumat tersebut untuk meletakkan ciri dengan tepat dengan imej yang dikesan oleh kamera. Sebarang maklumat yang dikumpul akan dipadamkan dengan segera (kebiasaannya sejurus aplikasi ditutup) dan sentiasa dalam tempoh tidak lebih daripada tiga tahun.<br/><br/>Jika anda bersetuju dan ingin teruskan, ketik dibawah.`,
    legalPromptVariantGAdultOrChild: `Adakah anda seorang dewasa atau kanak-kanak?`,
    legalPromptVariantGFindYourParent: `Sila cari ibu bapa atau penjaga anda yang sah.`,
    legalPromptVariantGIAmGuardian: `Saya penjaga kanak-kanak ini`,
    legalPromptVariantGCancel: `Batal`,
    legalPromptVariantGAdult: `Dewasa`,
    legalPromptVariantGChild: `Kanak-kanak`
  },
  "nb-NO": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ved  ta i bruk Linser bekrefter du at du har lest <a href="${0}" target="_blank">personvernbetingelsene</a> og at du godtar <a href="${0}" target="_blank">tjenestevilkrene</a> til Snap. Noen Linser bruker informasjon om ansiktet ditt, hendene dine og stemmen din for  fungere. <a href="${0}" target="_blank">Finn ut mer</a>. Hvis du godtar dette og vil g videre, klikker du nedenfor.`),
    legalPromptAccept: `Jeg godtar`,
    legalPromptReject: `Avvis`,
    legalPromptTermsOfService: `Tjenestevilkr`,
    legalPromptVariantGMessage: `Denne funksjonen bruker informasjon om ansikter, hender og stemmer som oppdages av kameraet og mikrofonen, for  fungere. Med denne funksjonen kan du legge til artige og nyttige effekter i utvidet virkelighet p selfier og bilder. Kameraet vrt bruker teknologi for  oppdage visse trekk (som hvor hendene, ynene og nesen er), og bruker denne informasjonen til  plassere funksjonen opp bildet som kameraet har fanget opp. All informasjon som samles inn, blir slettet s snart som mulig (vanligvis rett etter at appen lukkes) og alltid innen maks trer.<br/><br/>Hvis du nsker  godta og fortsette, trykker du nedenfor.`,
    legalPromptVariantGAdultOrChild: `Er du en voksen eller et barn?`,
    legalPromptVariantGFindYourParent: `Finn en forelder eller foresatt.`,
    legalPromptVariantGIAmGuardian: `Jeg er barnets foresatt`,
    legalPromptVariantGCancel: `Avbryt`,
    legalPromptVariantGAdult: `Voksen`,
    legalPromptVariantGChild: `Barn`
  },
  "nl-NL": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Door Lenzen te gebruiken, geef je aan dat je het <a href="${0}" target="_blank">Privacybeleid</a> van Snap hebt gelezen en dat je akkoord gaat met de <a href="${0}" target="_blank">Servicevoorwaarden</a> van Snap. Sommige Lenzen gebruiken informatie over je gezicht, handen en stem om te functioneren. Lees <a href="${0}" target="_blank">meer informatie</a> en tik hieronder als je akkoord gaat en wilt doorgaan.`),
    legalPromptAccept: `Ik ga akkoord`,
    legalPromptReject: `Annuleren`,
    legalPromptTermsOfService: `Servicevoorwaarden`,
    legalPromptVariantGMessage: `Voor de werking van deze functie wordt informatie over gezicht(en), handen en stem(men) gebruikt die door camera en microfoon worden gedetecteerd. Je kunt met deze functie leuke en nuttige augmented reality-effecten op selfies en afbeeldingen plaatsen. Onze camera gebruikt technologie om de locatie te bepalen van bepaalde kenmerken (bijvoorbeeld waar je handen, ogen en neus zich bevinden) en gebruikt die informatie om het kenmerk nauwkeurig te positioneren in de afbeelding die is gedetecteerd met de camera. De verzamelde informatie wordt zo snel mogelijk verwijderd (gewoonlijk kort nadat de app is gesloten) en altijd binnen een periode van maximaal drie jaar.<br/><br/>Tik hieronder als je hiermee akkoord gaat en wilt doorgaan.`,
    legalPromptVariantGAdultOrChild: `Ben je een volwassene of een kind?`,
    legalPromptVariantGFindYourParent: `Vraag toestemming aan een ouder of wettelijke voogd.`,
    legalPromptVariantGIAmGuardian: `Ik ben de voogd van het kind`,
    legalPromptVariantGCancel: `Annuleren`,
    legalPromptVariantGAdult: `Volwassene`,
    legalPromptVariantGChild: `Kind`
  },
  pa: {
    legalPromptMessage: legalPromptMessage((tag) => tag`   ,          Snap  <a href="${0}" target="_blank">  </a>       Snap  <a href="${0}" target="_blank">  </a>          ,           <a href="${0}" target="_blank"> </a>          ,    `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `         (),   ()           ,                      (   ,     )                                          (  '      )      <br/><br/>        ,    `,
    legalPromptVariantGAdultOrChild: `      ?`,
    legalPromptVariantGFindYourParent: `   -    `,
    legalPromptVariantGIAmGuardian: `    `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "pl-PL": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Korzystajc z nakadek, potwierdzasz zapoznanie si z <a href="${0}" target="_blank">Polityk prywatnoci</a> i akceptujesz <a href="${0}" target="_blank">Regulamin usugi</a>. Niektre nakadki wykorzystuj informacje o Twojej twarzy, doniach i gosie, aby dziaa poprawnie. <a href="${0}" target="_blank">Dowiedz si wicej</a>, a jeli chcesz wyrazi zgod i kontynuowa, stuknij poniej.`),
    legalPromptAccept: `Zgadzam si`,
    legalPromptReject: `Odrzu`,
    legalPromptTermsOfService: `Regulamin`,
    legalPromptVariantGMessage: `Ta funkcja wykorzystuje do dziaania informacje o twarzy (twarzach), rkach i gosie (gosach) wykrytych przez kamer i mikrofon. Dziki niej moesz nakada na selfie i zdjcia zabawne i przydatne efekty rozszerzonej rzeczywistoci. Nasza kamera wykorzystuje technologi do lokalizowania okrelonych cech (takich jak miejsce, w ktrym znajduj si Twoje rce, oczy i nos) i wykorzystuje te informacje do dokadnego umiejscowienia danej cechy na obrazie wykrywanym przez kamer. Wszelkie zebrane informacje zostan usunite moliwie jak najszybciej (zazwyczaj wkrtce po zamkniciu aplikacji) i zawsze nie pniej ni w cigu trzech lat.<br/><br/>Jeli chcesz wyrazi zgod i kontynuowa, stuknij poniej.`,
    legalPromptVariantGAdultOrChild: `Jeste osob doros czy dzieckiem?`,
    legalPromptVariantGFindYourParent: `Zwr si do swojego rodzica lub opiekuna prawnego.`,
    legalPromptVariantGIAmGuardian: `Jestem opiekunem prawnym dziecka`,
    legalPromptVariantGCancel: `Anuluj`,
    legalPromptVariantGAdult: `Osoba dorosa`,
    legalPromptVariantGChild: `Dziecko`
  },
  "pt-BR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ao usar as Lentes, voc reconhece ter lido a <a href="${0}" target="_blank">Poltica de Privacidade</a> da Snap e concorda com os <a href="${0}" target="_blank">Termos de Servio</a> da Snap. Algumas Lentes usam informaes sobre seu rosto, mos e voz para funcionar. <a href="${0}" target="_blank">Saiba mais</a> e, se quiser concordar e continuar, toque abaixo.`),
    legalPromptAccept: `Eu concordo`,
    legalPromptReject: `Recusar`,
    legalPromptTermsOfService: `Termos de Servio`,
    legalPromptVariantGMessage: `Este recurso usa informaes sobre rosto(s), mos e voz(es) detectados pela cmera e pelo microfone para funcionar. Com este recurso, voc pode aplicar efeitos divertidos e teis de realidade aumentada em selfies e imagens. Nossa cmera usa tecnologia para localizar certos recursos (como onde esto suas mos, olhos e nariz) e usa esta informao para posicionar corretamente o recurso na imagem detectada pela cmera. Qualquer informao coletada ser apagada o mais rpido possvel (geralmente logo depois que o aplicativo  fechado) e sempre antes de trs dias.<br/><br/>Se voc quiser concordar e continuar, toque abaixo.`,
    legalPromptVariantGAdultOrChild: `Voc  adulto ou criana?`,
    legalPromptVariantGFindYourParent: `Localize seu pai/me ou representante legal.`,
    legalPromptVariantGIAmGuardian: `Sou representante da criana`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Criana`
  },
  "pt-PT": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Ao utilizares as Lentes, confirmas a leitura da <a href="${0}" target="_blank">Poltica de Privacidade</a> da Snap e aceitas as <a href="${0}" target="_blank">Condies de Servio</a> da Snap. Algumas Lentes utilizam informaes sobre a tua cara, mos e voz para funcionarem. <a href="${0}" target="_blank">Obtm mais informaes</a> e, se quiseres aceitar e continuar, toca abaixo.`),
    legalPromptAccept: `Aceito`,
    legalPromptReject: `Fechar`,
    legalPromptTermsOfService: `Condies de Servio`,
    legalPromptVariantGMessage: `Esta funcionalidade utiliza informaes relacionadas com caras, mos e vozes detetadas pela cmara e o microfone para poder funcionar. Com esta funcionalidade, pode aplicar efeitos de realidade aumentada de forma divertida e til a selfies e imagens. A nossa cmara recorre a tecnologia para localizar determinadas caratersticas (como a localizao das tuas mos, dos olhos e do nariz) e utiliza essas informaes para posicionar de forma precisa a caraterstica na imagem captada pela cmara. Quaisquer informaes recolhidas sero eliminadas logo que possvel (normalmente pouco depois de a app ser fechada) e nunca aps um mximo de trs anos. <br/><br/>Se quiser aceitar e continuar, toque abaixo.`,
    legalPromptVariantGAdultOrChild: `s um adulto ou uma criana?`,
    legalPromptVariantGFindYourParent: `Recorre ao teus pais ou ao() teu(tua) representante legal`,
    legalPromptVariantGIAmGuardian: `Sou o(a) representante da criana`,
    legalPromptVariantGCancel: `Cancelar`,
    legalPromptVariantGAdult: `Adulto`,
    legalPromptVariantGChild: `Criana`
  },
  "ro-RO": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Dac foloseti lentile, confirmi c ai citit <a href="${0}" target="_blank">Politica de confidenialitate</a> Snap i c eti de acord cu <a href="${0}" target="_blank">Condiiile de utilizare</a> Snap. Unele lentile folosesc informaii despre faa ta, despre minile tale i despre vocea ta pentru a funciona. <a href="${0}" target="_blank">Afl mai multe</a>, iar dac doreti s accepi i s continui, atinge dedesubt.`),
    legalPromptAccept: `Accept`,
    legalPromptReject: `Respinge`,
    legalPromptTermsOfService: `Termeni de utilizare`,
    legalPromptVariantGMessage: `Pentru a rula, funcia utilizeaz informaii despre chipul tu, minile tale i vocea ta detectate de camer i microfon. Cu ajutorul acestei funcii, poi s aplici efecte de realitate augumentat amuzante i utile peste selfie-uri i imagini. Camera noastr folosete tehnologia pentru a gsi anumite caracteristici (de exemplu, unde se afl minile, ochii i nasul tu) i utilizeaz aceste informaii pentru a poziiona corect funcia n imaginea detectat de camer. Toate informaiile colectate sunt terse ct mai curnd posibil (de obicei, la scurt timp dup ce se nchide aplicaia), limita maxim fiind de trei ani.<br/><br/>Dac eti de acord i doreti s continui, atinge mai jos.`,
    legalPromptVariantGAdultOrChild: `Eti adult sau copil?`,
    legalPromptVariantGFindYourParent: `Este necesar prezena printelui sau a tutorelui.`,
    legalPromptVariantGIAmGuardian: `Sunt tutorele copilului`,
    legalPromptVariantGCancel: `Anuleaz`,
    legalPromptVariantGAdult: `Adult`,
    legalPromptVariantGChild: `Copil`
  },
  "ru-RU": {
    legalPromptMessage: legalPromptMessage((tag) => tag` ,  ,   <a href="${0}" target="_blank"> </a> Snap   <a href="${0}" target="_blank">  </a>.         ,   . <a href="${0}" target="_blank"></a>.    ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `           ,   .               .    ,      (,  ,   ),          ,   .        ( ,    ),   ,    .<br/><br/>     ,  .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `    .`,
    legalPromptVariantGIAmGuardian: `   `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "sv-SE": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Genom att anvnda linser intygar du att du har lst Snaps <a href="${0}" target="_blank">sekretessvillkor</a> och godknner Snaps <a href="${0}" target="_blank">anvndarvillkor</a>. Vissa linser anvnder information om ditt ansikte, dina hnder och din rst fr att fungera. <a href="${0}" target="_blank">Ls mer</a> och om du vill godknna och fortstta s trycker du nedan.`),
    legalPromptAccept: `Jag godknner`,
    legalPromptReject: `Avvisa`,
    legalPromptTermsOfService: `Anvndarvillkor`,
    legalPromptVariantGMessage: `Fr att fungera anvnder funktionen information om ansikte(n), hnder och rst(er) som upptckts av kameran och mikrofonen. Funktionen gr att du kan tillmpa roliga och anvndbara AR-effekter ver selfies och bilder. Med hjlp av teknik kan vr kamera lokalisera vissa srdrag (som dina hnder, gon och din nsa). Informationen anvnds sedan fr att korrekt positionera funktionen ver bilden som kameran fngat upp. All information som samlats in raderas s snart som mjligt (vanligtvis inom kort efter att appen stngts) och alltid inom tre r.<br/><br/>Tryck nedan om du vill godknna och fortstta.`,
    legalPromptVariantGAdultOrChild: `r du vuxen eller ett barn?`,
    legalPromptVariantGFindYourParent: `Leta upp din frlder eller vrdnadshavare`,
    legalPromptVariantGIAmGuardian: `Jag r barnets vrdnadshavare`,
    legalPromptVariantGCancel: `Avbryt`,
    legalPromptVariantGAdult: `Vuxen`,
    legalPromptVariantGChild: `Barn`
  },
  "ta-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap  <a href="${0}" target="_blank"> </a>    Snap  <a href="${0}" target="_blank"> </a> .      ,      . <a href="${0}" target="_blank"> </a>,    ,  .`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `         (),   ()   .             .      (,  , ,      )  ,         .       (,  ). ,      .<br/><br/>   ,  .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `     .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "te-IN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`  ,  Snap  <a href="${0}" target="_blank"> </a>    Snap <a href="${0}" target="_blank"> </a> .      ,      . <a href="${0}" target="_blank"> </a>,   ,   .`),
    legalPromptAccept: ` `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: ` `,
    legalPromptVariantGMessage: `         (),   ()   .  ,  ,         .     ( ,     )              .      (   )      .<br/><br/>  ,   .`,
    legalPromptVariantGAdultOrChild: `   ?`,
    legalPromptVariantGFindYourParent: `      .`,
    legalPromptVariantGIAmGuardian: `  `,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "th-TH": {
    legalPromptMessage: legalPromptMessage((tag) => tag` <a href="${0}" target="_blank"></a>  Snap  <a href="${0}" target="_blank"></a>  Snap    <a href="${0}" target="_blank"></a>  `),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `     (AR)   (   )     () <br/><br/> `,
    legalPromptVariantGAdultOrChild: `?`,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "tr-TR": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Lensleri kullanarak, Snap\'in <a href="${0}" target="_blank">Gizlilik Politikas</a> ieriini okuduunu dorulam ve Snap\'in <a href="${0}" target="_blank">Kullanm artlar</a> ieriini kabul etmi olursun. Baz lenslerin almas iin yzn, ellerin ve sesinle ilgili bilgiler kullanlr. <a href="${0}" target="_blank">Daha Fazlasn ren</a> ve kabul edip devam etmek istiyorsan aaya dokun.`),
    legalPromptAccept: `Kabul Ediyorum`,
    legalPromptReject: `Yoksay`,
    legalPromptTermsOfService: `Kullanm artlar`,
    legalPromptVariantGMessage: `Bu zelliin almas iin kamera ve mikrofon tarafndan alglanan yzler, eller ve sesler hakkndaki bilgiler kullanlr. Bu zellik sayesinde selfie'lerin ve grntlerin zerine elenceli ve kullanl artrlm gereklik efektleri uygulayabilirsin. Kameramz, belirli zellikleri (ellerinin, gzlerinin ve burnunun nerede olduu gibi) bulmak iin teknolojiden yararlanr ve bu bilgileri, kamera tarafndan alglanan grntyle zellii doru ekilde konumlandrmak iin kullanr. Toplanan tm bilgiler mmkn olan en ksa srede (genellikle uygulama kapatldktan ksa sre sonra) ve mutlaka en fazla  yl iinde silinir.<br/><br/>Kabul edip devam etmek istiyorsan aaya dokun.`,
    legalPromptVariantGAdultOrChild: `Yetikin mi yoksa ocuk musun?`,
    legalPromptVariantGFindYourParent: `Ltfen ebeveynini veya yasal vasini bul.`,
    legalPromptVariantGIAmGuardian: `Ben ocuun vasisiyim`,
    legalPromptVariantGCancel: `ptal Et`,
    legalPromptVariantGAdult: `Yetikin`,
    legalPromptVariantGChild: `ocuk`
  },
  "ur-PK": {
    legalPromptMessage: legalPromptMessage((tag) => tag`        Snap  <a href="${0}" target="_blank"> </a>       Snap  <a href="${0}" target="_blank">  </a>                      <a href="${0}" target="_blank"> </a>               `),
    legalPromptAccept: `  `,
    legalPromptReject: ` `,
    legalPromptTermsOfService: `  `,
    legalPromptVariantGMessage: `      ()                                                     (         )                                           (      )            <br/><br/>             `,
    legalPromptVariantGAdultOrChild: `      `,
    legalPromptVariantGFindYourParent: `   /      `,
    legalPromptVariantGIAmGuardian: `  /  `,
    legalPromptVariantGCancel: ` `,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "vi-VN": {
    legalPromptMessage: legalPromptMessage((tag) => tag`Bng cch s dng ng Knh, bn xc nhn  c <a href="${0}" target="_blank">Chnh Sch Bo Mt</a> ca Snap v ng  vi <a href="${0}" target="_blank">iu Khon Dch V</a>ca Snap. Mt s ng knh s dng thng tin v khun mt, bn tay v ging ni ca bn  hot ng. Bn c th <a href="${0}" target="_blank">Tm Hiu Thm</a>, cn nu bn mun ng  v tip tc, hy chm vo bn di.`),
    legalPromptAccept: `Ti ng `,
    legalPromptReject: `B Qua`,
    legalPromptTermsOfService: `iu Khon Dch V`,
    legalPromptVariantGMessage: `Tnh nng ny hot ng da trn vic s dng thng tin v khun mt, bn tay v ging ni m camera v micr pht hin c. Bn c th s dng tnh nng ny  p dng cc hiu ng thc t tng cng th v v hu ch ln nh t sng v hnh nh. Camera ca chng ti p dng cng ngh  tm nhng c im nht nh (chng hn nh v tr bn tay, mt v mi ca bn), ri s dng thng tin   xc nh chnh xc v tr ca c im trong hnh nh m camera chp c. Chng ti s xa mi thng tin c thu thp sm nht c th (thng ngay sau khi bn ng ng dng) v lun xa trong khong thi gian khng qu ba nm.<br/><br/>Nu bn mun ng  v tip tc, hy chm vo bn di.`,
    legalPromptVariantGAdultOrChild: `Bn l ngi ln hay tr em?`,
    legalPromptVariantGFindYourParent: `Vui lng tm ph huynh hoc ngi gim h hp php.`,
    legalPromptVariantGIAmGuardian: `Ti l ngi gim h ca tr`,
    legalPromptVariantGCancel: `Hy B`,
    legalPromptVariantGAdult: `Ngi ln`,
    legalPromptVariantGChild: `Tr em`
  },
  "zh-Hans": {
    legalPromptMessage: legalPromptMessage((tag) => tag` Snap <a href="${0}" target="_blank"></a> Snap <a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: `<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  },
  "zh-Hant": {
    legalPromptMessage: legalPromptMessage((tag) => tag` Snap <a href="${0}" target="_blank"></a> Snap <a href="${0}" target="_blank"></a><a href="${0}" target="_blank"></a>`),
    legalPromptAccept: ``,
    legalPromptReject: ``,
    legalPromptTermsOfService: ``,
    legalPromptVariantGMessage: ` () ()<br/><br/>`,
    legalPromptVariantGAdultOrChild: ``,
    legalPromptVariantGFindYourParent: ``,
    legalPromptVariantGIAmGuardian: ``,
    legalPromptVariantGCancel: ``,
    legalPromptVariantGAdult: ``,
    legalPromptVariantGChild: ``
  }
};
var languageDefaultLocale = {
  bn: "bn-BD",
  da: "da-DK",
  de: "de-DE",
  el: "el-GR",
  en: "en-US",
  es: "es-ES",
  fi: "fi-FI",
  fil: "fil-PH",
  fr: "fr-FR",
  gu: "gu-IN",
  hi: "hi-IN",
  id: "id-ID",
  it: "it-IT",
  ja: "ja-JP",
  kn: "kn-IN",
  ko: "ko-KR",
  ml: "ml-IN",
  mr: "mr-IN",
  ms: "ms-MY",
  nb: "nb-NO",
  nl: "nl-NL",
  pl: "pl-PL",
  pt: "pt-BR",
  ro: "ro-RO",
  ru: "ru-RU",
  sv: "sv-SE",
  ta: "ta-IN",
  te: "te-IN",
  th: "th-TH",
  tr: "tr-TR",
  ur: "ur-PK",
  vi: "vi-VN",
  zh: "zh-Hans"
};
var synonyms = {
  "zh-TW": "zh-Hant",
  "zh-CN": "zh-Hans"
};
var isLocaleString = (value) => value in allStrings;
var defaultLocale = "en-US";
function getSupportedLocale() {
  const locale = getPlatformInfo().locale;
  if (isLocaleString(locale))
    return locale;
  const synonym = synonyms[locale];
  if (synonym && synonym in allStrings)
    return synonym;
  const langCode = locale.split("-")[0];
  if (langCode && langCode in allStrings)
    return langCode;
  if (langCode && langCode in languageDefaultLocale)
    return languageDefaultLocale[langCode];
  return defaultLocale;
}
var supportedLocale = getSupportedLocale();
function localizedString(stringId) {
  return allStrings[supportedLocale][stringId];
}

// node_modules/@snap/camera-kit/dist/common/dialog.js
var stylesCss = `
dialog {
    display: flex;
    flex-direction: column;

    background-color: #fff;
    border: #efefef 1px solid;
    border-radius: 20px;
    box-shadow: 0px 10px 20px rgba(0, 0, 0, 0.3);

    max-width: 80vw;
    max-height: 80vh;
    padding: 44px 0 24px 0;

    font-size: 16px;
    font-family: sans-serif;
    font-style: normal;
    font-weight: 600;
    line-height: 24px;
}

dialog::backdrop {
    background-color: rgba(0, 0, 0, 0.4);
}

.title {
    color: #16191C;
    padding: 0 32px;
    text-align: center;
}

.body {
    color: #656D78;
    font-size: 14px;
    font-weight: 500;
    margin-top: 16px;
    max-width: 350px;
    padding: 0 32px;
    overflow: auto;
}

a {
    color: rgb(78, 171, 248);
}

button {
    cursor: pointer;
}

button.dismiss {
    position: absolute;
    top: 7px;
    right: 7px;
    padding: 0;
    height: 36px;
    width: 36px;
    margin: 0;
    background-color: transparent;
    border: 0;
}

button.dismiss svg {
    fill: black;
}

.buttons {
    margin-top: 8px;
    padding: 0 32px;
}

.buttons button {
    background: #0FADFF;
    border: 0;
    border-radius: 25px;

    width: 100%;
    padding: 1rem;
    margin-top: 8px;

    color: #fff;
    font-weight: inherit;
    font-family: inherit;
    font-size: inherit;
    font-style: inherit;
}

.buttons button.secondary {
    background-color: transparent;
    color: #656D78;
}

// Proper filling of X button in High Contrast themes
@media (forced-colors: active) {
    button.dismiss svg {
        fill: ButtonText;
    }
}
`;
function getDismissButtonHtml(button) {
  return `
        <button class="dismiss" autofocus data-key=${button.key}>
            <svg xmlns="http://www.w3.org/2000/svg" role="img" width="36" height="36" viewBox="0 0 36 36">
                <title>${button.text}</title>
                <path fill-rule="evenodd" clip-rule="evenodd" d="M12.6763 11.2621C12.2858 10.8716 11.6527 10.8716 11.2621 11.2621C10.8716 11.6527 10.8716 12.2858 11.2621 12.6763L16.5858 18L11.2621 23.3237C10.8716 23.7142 10.8716 24.3474 11.2621 24.7379C11.6527 25.1284 12.2858 25.1284 12.6764 24.7379L18 19.4142L23.3237 24.7379C23.7142 25.1284 24.3474 25.1284 24.7379 24.7379C25.1284 24.3474 25.1284 23.7142 24.7379 23.3237L19.4142 18L24.7379 12.6763C25.1284 12.2858 25.1284 11.6527 24.7379 11.2621C24.3474 10.8716 23.7142 10.8716 23.3237 11.2621L18 16.5858L12.6763 11.2621Z" fill-opacity="0.4"/>
            </svg>
        </button>`;
}
function getTitleHtml(title) {
  return title ? `<div class="title" role="heading">${title}</div>` : "";
}
function getBodyHtml(body) {
  return body ? `<div class="body">${body}</div>` : "";
}
function getButtonHtml(button) {
  return `<button data-key="${button.key}"${button.isSecondary ? ` class="secondary"` : ""}>${button.text}</button>`;
}
function getButtonsHtml(buttons) {
  if (buttons.length === 0)
    return "";
  return `
        <div class="buttons">
        ${buttons.map((b2) => getButtonHtml(b2)).join("\n")}
        </div>`;
}
function setAttribute(element, attr, value) {
  if (value)
    element.setAttribute(attr, value);
}
function showDialog(options) {
  return new Promise((res) => {
    var _a, _b, _c;
    const element = document.createElement("div");
    setAttribute(element, "data-testid", options.dataTestId);
    const shadow = element.attachShadow({ mode: "open" });
    const style = document.createElement("style");
    shadow.appendChild(style);
    style.innerHTML = stylesCss;
    const prompt = document.createElement("dialog");
    setAttribute(prompt, "aria-label", (_a = options.titleText) !== null && _a !== void 0 ? _a : options.title);
    setAttribute(prompt, "lang", options.lang);
    setAttribute(prompt, "dir", "auto");
    shadow.appendChild(prompt);
    prompt.innerHTML = `
            ${getDismissButtonHtml({ key: "dismiss", text: (_b = options.dismissButtonText) !== null && _b !== void 0 ? _b : "Dismiss" })}
            ${getTitleHtml(options.title)}
            ${getBodyHtml(options.body)}
            ${getButtonsHtml((_c = options.buttons) !== null && _c !== void 0 ? _c : [])}
        `;
    const buttonsElements = Array.from(prompt.querySelectorAll("button"));
    merge(...buttonsElements.map((b2) => fromEvent(b2, "click").pipe(map(() => b2.dataset.key))), fromEvent(prompt, "cancel").pipe(map(() => "dismiss"))).pipe(take(1)).subscribe({ next: res, complete: () => element.remove() });
    options.container.appendChild(element);
    prompt.showModal();
  });
}

// node_modules/@snap/camera-kit/dist/common/hash.js
var computeHash = (str) => {
  let h1 = 3735928559;
  let h2 = 1103547991;
  for (let i = 0; i < str.length; i++) {
    const ch = str.charCodeAt(i);
    h1 = Math.imul(h1 ^ ch, 2654435761);
    h2 = Math.imul(h2 ^ ch, 1597334677);
  }
  h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
  return (4294967296 * (2097151 & h2) + (h1 >>> 0)).toString(16);
};

// node_modules/@snap/camera-kit/dist/legal/legalPrompt.js
var snapIcon = `
<svg xmlns="http://www.w3.org/2000/svg" role="img" viewBox="0 0 32 32" height="48px">
    <g>
        <path
            d="M 30.898 23.477 C 30.77 23.045 30.148 22.743 30.148 22.743 C 30.092 22.71 30.039 22.684 29.994 22.663 C 28.962 22.161 28.048 21.561 27.277 20.876 C 26.659 20.325 26.128 19.719 25.701 19.074 C 25.182 18.288 24.937 17.632 24.831 17.275 C 24.773 17.043 24.782 16.951 24.831 16.832 C 24.873 16.731 24.99 16.632 25.049 16.588 C 25.397 16.341 25.96 15.976 26.303 15.75 C 26.602 15.556 26.859 15.389 27.009 15.283 C 27.494 14.944 27.824 14.596 28.02 14.223 C 28.275 13.74 28.303 13.208 28.107 12.684 C 27.84 11.978 27.184 11.556 26.35 11.556 C 26.163 11.556 25.974 11.577 25.785 11.62 C 25.308 11.723 24.852 11.894 24.474 12.042 C 24.446 12.054 24.416 12.032 24.418 12.002 C 24.457 11.059 24.502 9.79 24.399 8.584 C 24.306 7.493 24.082 6.576 23.717 5.776 C 23.351 4.972 22.874 4.376 22.5 3.947 C 22.143 3.536 21.519 2.936 20.577 2.394 C 19.251 1.631 17.742 1.244 16.09 1.244 C 14.443 1.244 12.934 1.631 11.605 2.394 C 10.607 2.966 9.97 3.614 9.678 3.947 C 9.304 4.376 8.827 4.972 8.46 5.776 C 8.096 6.576 7.872 7.496 7.778 8.584 C 7.673 9.792 7.715 10.96 7.76 11.999 C 7.762 12.03 7.732 12.051 7.704 12.039 C 7.325 11.892 6.87 11.72 6.393 11.617 C 6.204 11.575 6.012 11.554 5.828 11.554 C 4.994 11.554 4.337 11.976 4.071 12.682 C 3.875 13.205 3.903 13.738 4.157 14.221 C 4.354 14.594 4.685 14.941 5.169 15.281 C 5.318 15.387 5.575 15.553 5.874 15.748 C 6.211 15.968 6.758 16.323 7.108 16.569 C 7.152 16.599 7.299 16.712 7.346 16.827 C 7.397 16.951 7.404 17.045 7.341 17.289 C 7.234 17.648 6.989 18.298 6.479 19.069 C 6.052 19.715 5.522 20.32 4.902 20.871 C 4.132 21.556 3.218 22.157 2.186 22.658 C 2.137 22.682 2.078 22.712 2.015 22.748 C 2.015 22.748 1.399 23.064 1.282 23.472 C 1.109 24.075 1.567 24.64 2.036 24.943 C 2.8 25.438 3.732 25.703 4.272 25.849 C 4.421 25.889 4.559 25.926 4.683 25.964 C 4.76 25.989 4.956 26.062 5.038 26.17 C 5.143 26.306 5.155 26.473 5.192 26.66 C 5.253 26.977 5.384 27.373 5.774 27.643 C 6.204 27.941 6.75 27.962 7.444 27.99 C 8.168 28.018 9.07 28.054 10.1 28.394 C 10.579 28.553 11.011 28.818 11.514 29.128 C 12.56 29.773 13.864 30.578 16.09 30.578 C 18.318 30.578 19.629 29.768 20.685 29.119 C 21.183 28.811 21.612 28.546 22.08 28.391 C 23.11 28.049 24.011 28.014 24.735 27.988 C 25.427 27.962 25.974 27.941 26.404 27.641 C 26.822 27.35 26.943 26.918 26.997 26.59 C 27.027 26.428 27.046 26.285 27.14 26.165 C 27.219 26.064 27.399 25.992 27.483 25.964 C 27.609 25.924 27.751 25.886 27.906 25.844 C 28.445 25.698 29.123 25.527 29.945 25.061 C 30.933 24.511 31.001 23.82 30.898 23.477"
            fill="#ffffff"
            stroke="#00000000"
            stroke-width="1"
        />
    </g>
    <g>
        <path
            d="M 29.56 24.299 C 28.21 25.045 27.312 24.965 26.613 25.414 C 26.021 25.795 26.37 26.618 25.939 26.915 C 25.411 27.279 23.843 26.889 21.822 27.555 C 20.155 28.107 19.09 29.689 16.089 29.689 C 13.081 29.689 12.047 28.114 10.357 27.555 C 8.335 26.889 6.768 27.279 6.24 26.915 C 5.809 26.618 6.16 25.795 5.566 25.414 C 4.869 24.965 3.969 25.045 2.619 24.299 C 1.758 23.825 2.247 23.53 2.532 23.393 C 7.426 21.027 8.204 17.372 8.24 17.096 C 8.282 16.769 8.328 16.509 7.966 16.175 C 7.615 15.853 6.066 14.895 5.636 14.593 C 4.925 14.098 4.612 13.6 4.841 12.99 C 5 12.569 5.395 12.41 5.812 12.41 C 5.94 12.41 6.071 12.426 6.2 12.452 C 6.981 12.623 7.741 13.013 8.179 13.118 C 8.24 13.132 8.293 13.139 8.34 13.139 C 8.574 13.139 8.656 13.022 8.639 12.754 C 8.59 11.9 8.469 10.234 8.602 8.677 C 8.787 6.536 9.477 5.476 10.298 4.538 C 10.693 4.087 12.543 2.133 16.082 2.133 C 19.633 2.133 21.474 4.087 21.867 4.538 C 22.688 5.478 23.378 6.536 23.563 8.677 C 23.698 10.234 23.581 11.898 23.525 12.754 C 23.506 13.034 23.591 13.139 23.825 13.139 C 23.872 13.139 23.925 13.132 23.986 13.118 C 24.426 13.013 25.184 12.62 25.965 12.452 C 26.091 12.424 26.222 12.41 26.353 12.41 C 26.77 12.41 27.165 12.569 27.324 12.99 C 27.555 13.6 27.242 14.095 26.529 14.593 C 26.098 14.892 24.547 15.85 24.199 16.175 C 23.836 16.509 23.883 16.767 23.925 17.096 C 23.96 17.372 24.739 21.025 29.633 23.393 C 29.932 23.53 30.421 23.825 29.56 24.299 M 31.709 23.12 C 31.489 22.523 31.07 22.203 30.594 21.939 C 30.505 21.887 30.423 21.845 30.355 21.812 C 30.212 21.74 30.067 21.667 29.922 21.592 C 28.435 20.806 27.275 19.812 26.469 18.635 C 26.198 18.238 26.008 17.88 25.877 17.587 C 25.809 17.391 25.811 17.281 25.86 17.178 C 25.898 17.101 25.996 17.019 26.05 16.979 C 26.305 16.811 26.57 16.64 26.748 16.525 C 27.067 16.319 27.317 16.156 27.481 16.043 C 28.093 15.617 28.519 15.164 28.786 14.658 C 29.163 13.945 29.21 13.131 28.919 12.363 C 28.517 11.301 27.509 10.642 26.291 10.642 C 26.038 10.642 25.783 10.67 25.527 10.726 C 25.46 10.74 25.394 10.756 25.328 10.773 C 25.34 10.05 25.324 9.278 25.258 8.524 C 25.029 5.872 24.099 4.48 23.129 3.371 C 22.724 2.908 22.021 2.232 20.964 1.628 C 19.491 0.781 17.821 0.356 16 0.356 C 14.185 0.356 12.518 0.781 11.044 1.623 C 9.983 2.229 9.278 2.905 8.875 3.366 C 7.905 4.475 6.975 5.867 6.746 8.52 C 6.68 9.273 6.663 10.045 6.675 10.768 C 6.61 10.752 6.544 10.735 6.476 10.721 C 6.221 10.665 5.965 10.637 5.713 10.637 C 4.494 10.637 3.487 11.297 3.084 12.359 C 2.794 13.126 2.841 13.94 3.218 14.654 C 3.485 15.159 3.911 15.613 4.522 16.039 C 4.686 16.153 4.937 16.314 5.256 16.52 C 5.427 16.633 5.68 16.794 5.926 16.958 C 5.963 16.984 6.097 17.082 6.141 17.173 C 6.193 17.279 6.195 17.393 6.118 17.604 C 5.987 17.891 5.801 18.242 5.535 18.631 C 4.747 19.782 3.62 20.757 2.18 21.536 C 1.419 21.941 0.54 22.355 0.29 23.118 C 0.039 23.88 0.203 24.582 0.842 25.239 C 1.053 25.466 1.318 25.665 1.653 25.85 C 2.438 26.283 3.105 26.496 3.63 26.641 C 3.721 26.669 3.937 26.736 4.031 26.819 C 4.265 27.022 4.23 27.331 4.543 27.78 C 4.731 28.061 4.949 28.25 5.129 28.374 C 5.783 28.826 6.516 28.854 7.294 28.881 C 7.997 28.908 8.793 28.94 9.702 29.24 C 10.079 29.364 10.47 29.605 10.922 29.883 C 12.011 30.552 13.501 31.467 15.998 31.467 C 18.493 31.467 19.995 30.547 21.091 29.876 C 21.541 29.6 21.93 29.361 22.297 29.242 C 23.206 28.942 24.003 28.912 24.706 28.884 C 25.483 28.854 26.216 28.826 26.87 28.377 C 27.076 28.234 27.331 28.004 27.535 27.651 C 27.76 27.272 27.753 27.003 27.964 26.821 C 28.05 26.746 28.238 26.68 28.338 26.65 C 28.868 26.505 29.545 26.292 30.344 25.852 C 30.697 25.658 30.976 25.443 31.192 25.2 C 31.194 25.197 31.196 25.192 31.199 25.19 C 31.805 24.544 31.955 23.787 31.709 23.12"
            fill="#000000"
            stroke="#00000000"
            stroke-width="1"
        />
    </g>
</svg>`;
function showTosDialog(title, titleText, body) {
  return __awaiter(this, void 0, void 0, function* () {
    const result = yield showDialog({
      container: document.body,
      dataTestId: "tos-dialog",
      lang: supportedLocale,
      title,
      titleText,
      body,
      dismissButtonText: localizedString("legalPromptReject"),
      buttons: [
        {
          text: localizedString("legalPromptAccept"),
          key: "accept"
        }
      ]
    });
    return result === "accept";
  });
}
function showAdultOrChildDialog() {
  return showDialog({
    container: document.body,
    dataTestId: "adult-or-child-dialog",
    lang: supportedLocale,
    title: localizedString("legalPromptVariantGAdultOrChild"),
    buttons: [
      {
        text: localizedString("legalPromptVariantGAdult"),
        key: "adult"
      },
      {
        text: localizedString("legalPromptVariantGChild"),
        key: "child"
      }
    ]
  });
}
function showFindGuardianDialog() {
  return showDialog({
    container: document.body,
    dataTestId: "find-guardian-dialog",
    lang: supportedLocale,
    title: localizedString("legalPromptVariantGFindYourParent"),
    buttons: [
      {
        text: localizedString("legalPromptVariantGIAmGuardian"),
        key: "guardian"
      },
      {
        text: localizedString("legalPromptVariantGCancel"),
        key: "cancel",
        isSecondary: true
      }
    ]
  });
}
var legalPromptFactory = Injectable("legalPrompt", () => {
  return function legalPrompt(privacyPolicy, termsOfService, learnMore, childrenProtectionActRestricted) {
    const legalMessage = childrenProtectionActRestricted ? localizedString("legalPromptVariantGMessage") : localizedString("legalPromptMessage")({
      privacyPolicyUrl: privacyPolicy.webUrl,
      termsOfServiceUrl: termsOfService.webUrl,
      learnMoreUrl: learnMore.webUrl
    });
    const legalTitleText = localizedString("legalPromptTermsOfService");
    const legalTitle = childrenProtectionActRestricted ? legalTitleText : snapIcon;
    return {
      contentHash: computeHash(legalMessage),
      show() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!childrenProtectionActRestricted) {
            return showTosDialog(legalTitle, legalTitleText, legalMessage);
          }
          while (true) {
            const adultOrChild = yield showAdultOrChildDialog();
            switch (adultOrChild) {
              case "child": {
                const findGuardian = yield showFindGuardianDialog();
                switch (findGuardian) {
                  case "cancel":
                    continue;
                  case "guardian":
                    return showTosDialog(legalTitle, legalTitleText, legalMessage);
                  case "dismiss":
                    return false;
                  default:
                    assertUnreachable(findGuardian);
                }
              }
              case "adult":
                return showTosDialog(legalTitle, legalTitleText, legalMessage);
              case "dismiss":
                return false;
              default:
                assertUnreachable(adultOrChild);
            }
          }
        });
      }
    };
  };
});

// node_modules/@snap/camera-kit/dist/legal/legalState.js
var logger11 = getLogger("LegalState");
var tosContentHashExpiry = 12 * 60 * 60;
var tosContentHashKey = "lastAcceptedTosContentHash";
var createLegalState = () => {
  const states = defineStates(defineState("unknown")(), defineState("accepted")(), defineState("rejected")());
  const actions = defineActions(defineAction("requestLegalPrompt")(), defineAction("accept")(), defineAction("reject")());
  return new StateMachine(actions, states, states.unknown(), (actions2) => {
    return merge(actions2.pipe(inStates("unknown"), forActions("accept"), map(() => states.accepted())), actions2.pipe(inStates("unknown"), forActions("reject"), map(() => states.rejected())), actions2.pipe(inStates("rejected"), forActions("requestLegalPrompt"), map(() => states.unknown())));
  });
};
var defaultLegalDocumentDate = /* @__PURE__ */ new Date("2021-09-30T00:00:00+00:00");
var defaultLegalPrompt = LegalPrompt.fromPartial({
  documents: [
    LegalDocument.fromPartial({
      type: LegalDocument_Type.PRIVACY_POLICY,
      webUrl: "https://values.snap.com/privacy/privacy-policy",
      version: "1",
      timestamp: defaultLegalDocumentDate
    }),
    LegalDocument.fromPartial({
      type: LegalDocument_Type.TERMS_OF_SERVICE,
      webUrl: "https://snap.com/terms",
      version: "1",
      timestamp: defaultLegalDocumentDate
    }),
    LegalDocument.fromPartial({
      type: LegalDocument_Type.LEARN_MORE,
      webUrl: "https://support.snapchat.com/article/camera-information-use",
      version: "1",
      timestamp: defaultLegalDocumentDate
    })
  ],
  disabled: true
});
var defaultInitConfig = GetInitializationConfigResponse.fromPartial({});
var hasAnyValue = (c2) => {
  var _a, _b;
  return ((_b = (_a = c2.value) === null || _a === void 0 ? void 0 : _a.anyValue) === null || _b === void 0 ? void 0 : _b.value) instanceof Uint8Array;
};
var getDocumentOrDefault = (documents) => (type) => {
  var _a;
  return (_a = documents.find((d2) => d2.type === type)) !== null && _a !== void 0 ? _a : defaultLegalPrompt.documents.find((d2) => d2.type === type);
};
var legalStateFactory = Injectable("legalState", [remoteConfigurationFactory.token, legalPromptFactory.token], (remoteConfig, legalPrompt) => {
  const persistance = new ExpiringPersistence(() => tosContentHashExpiry, new IndexedDBPersistence({ databaseName: "Legal" }));
  const getLastAcceptedTosContentHash = () => from(persistance.retrieve(tosContentHashKey).catch((error) => logger11.warn(error)));
  const setLastAcceptedTosContentHash = (hash) => persistance.store(tosContentHashKey, hash).catch((error) => logger11.warn(error));
  const legalState = createLegalState();
  legalState.events.pipe(inStates("unknown"), forActions("requestLegalPrompt"), switchMap(() => forkJoin({
    cofConfig: remoteConfig.get("CAMERA_KIT_LEGAL_PROMPT").pipe(map((configResults) => {
      const config2 = configResults.find(hasAnyValue);
      if (!config2)
        return defaultLegalPrompt;
      return LegalPrompt.decode(config2.value.anyValue.value);
    }), catchError((error) => {
      logger11.error(error);
      return of(defaultLegalPrompt);
    })),
    initConfig: remoteConfig.getInitializationConfig().pipe(catchError((error) => {
      logger11.error(error);
      return of(defaultInitConfig);
    }))
  })), switchMap(({ cofConfig, initConfig }) => {
    var _a;
    if ((_a = initConfig.legalPrompt) === null || _a === void 0 ? void 0 : _a.disabled) {
      return of(legalState.actions.accept("disabled"));
    }
    if (cofConfig.disabled) {
      return of(legalState.actions.accept("disabled"));
    }
    const documentOfType = getDocumentOrDefault(cofConfig.documents);
    const prompt = legalPrompt(documentOfType(LegalDocument_Type.PRIVACY_POLICY), documentOfType(LegalDocument_Type.TERMS_OF_SERVICE), documentOfType(LegalDocument_Type.LEARN_MORE), initConfig.childrenProtectionActRestricted);
    return getLastAcceptedTosContentHash().pipe(switchMap((lastAcceptedTosContentHash) => {
      if (prompt.contentHash === lastAcceptedTosContentHash)
        return of(true);
      return prompt.show();
    }), map((didAccept) => {
      if (!didAccept)
        return legalState.actions.reject(prompt.contentHash);
      setLastAcceptedTosContentHash(prompt.contentHash);
      return legalState.actions.accept(prompt.contentHash);
    }));
  }), dispatch(legalState)).subscribe({
    error: logger11.error
  });
  return legalState;
});

// node_modules/@snap/camera-kit/dist/observable-operators/unsubscribed.js
function unsubscribed(callback) {
  return (source) => defer(() => {
    let completedOrErrored = false;
    return source.pipe(tap({
      complete: () => completedOrErrored = true,
      error: () => completedOrErrored = true
    }), finalize(() => {
      if (completedOrErrored)
        return;
      callback();
    }));
  });
}

// node_modules/@snap/camera-kit/dist/lens/fetchWatermarkLens.js
var logger12 = getLogger("fetchWatermarkLens");
var watermarksLensGroup = "watermarks";
var fetchWatermarkLens = Injectable("fetchWatermarkLens", [remoteConfigurationFactory.token, lensRepositoryFactory.token], (remoteConfiguration, lensRepository) => {
  remoteConfiguration.getInitializationConfig().pipe(take(1)).subscribe({
    next: (config2) => __awaiter(void 0, void 0, void 0, function* () {
      if (config2.watermarkEnabled) {
        const lens = yield lensRepository.loadLens("", watermarksLensGroup);
        yield lensRepository.cacheLensContent([lens]);
      }
    }),
    error: logger12.error
  });
});

// node_modules/@snap/camera-kit/dist/lens/userDataAccessResolver.js
var userDataAccessResolverFactory = Injectable("userDataAccessResolver", () => () => "unrestricted");

// node_modules/@snap/camera-kit/dist/session/lensState.js
var logger13 = getLogger("LensState");
var createLensState = () => {
  const actions = defineActions(defineAction("applyLens")(), defineAction("downloadComplete")(), defineAction("turnedOn")(), defineAction("resourcesLoaded")(), defineAction("firstFrameProcessed")(), defineAction("applyLensComplete")(), defineAction("applyLensFailed")(), defineAction("applyLensAborted")(), defineAction("removeLens")(), defineAction("turnedOff")(), defineAction("removeLensComplete")(), defineAction("removeLensFailed")());
  const states = defineStates(defineState("noLensApplied")(), defineState("applyingLens")(), defineState("lensApplied")());
  return new StateMachine(actions, states, states.noLensApplied(), (events) => merge(events.pipe(inStates("noLensApplied", "applyingLens", "lensApplied"), forActions("applyLens"), map(([a2]) => states.applyingLens(a2.data.lens))), events.pipe(inStates("applyingLens"), forActions("applyLensComplete"), map(([a2]) => states.lensApplied(a2.data))), events.pipe(inStates("applyingLens"), forActions("applyLensFailed"), map(() => states.noLensApplied())), events.pipe(inStates("lensApplied"), forActions("removeLensComplete"), map(() => states.noLensApplied()))));
};
var lensStateFactory = Injectable("lensState", [
  lensCoreFactory.token,
  lensRepositoryFactory.token,
  lensAssetRepositoryFactory.token,
  lensPersistenceStoreFactory.token,
  legalStateFactory.token,
  metricsClientFactory.token,
  remoteConfigurationFactory.token,
  userDataAccessResolverFactory.token
], (lensCore, lensRepository, lensAssetRepository, lensPersistence, legalState, metrics, remoteConfig, getUserDataAccess) => {
  const lensState = createLensState();
  let firstLensApply = true;
  lensState.events.pipe(forActions("applyLens"), exhaustMap(([a2]) => of(legalState.actions.requestLegalPrompt()).pipe(dispatch(legalState), inStates("accepted", "rejected"), take(1), map(([, { name }]) => {
    if (name === "accepted")
      return a2;
    return lensState.actions.applyLensFailed({
      error: legalError(`Failed to apply lens ${a2.data.lens.id}. Required legal terms were not accepted.`),
      lens: a2.data.lens
    });
  }))), switchMap((a2) => {
    if (a2.name === "applyLensFailed")
      return of(a2);
    const { lens } = a2.data;
    const dispatch2 = (action) => {
      lensState.dispatch(action, lens);
    };
    const applyTimer = new Timer("lens").mark("apply", { first: `${firstLensApply}` });
    firstLensApply = false;
    return forkJoin({
      watermarkInput: remoteConfig.getInitializationConfig().pipe(mergeMap((config2) => {
        if (!config2.watermarkEnabled)
          return of(void 0);
        return from(lensRepository.loadLens("", watermarksLensGroup)).pipe(mergeMap((watermark) => from(lensRepository.getLensContent(watermark)).pipe(map(({ lensBuffer, lensChecksum }) => {
          return {
            lensId: watermark.id,
            lensDataBuffer: lensBuffer.slice(0),
            lensChecksum,
            launchData: new ArrayBuffer(0)
          };
        }))));
      })),
      lensInput: of(a2.data).pipe(mergeMap(({ lens: lens2, launchData }) => {
        return from(lensPersistence.retrieve(lens2.id).catch(() => void 0)).pipe(map((persistentStore) => ({ lens: lens2, launchData, persistentStore })));
      }), map(({ lens: lens2, launchData, persistentStore }) => {
        const lensDetails = lensRepository.getLensMetadata(lens2.id);
        if (!lensDetails) {
          throw new Error(`Cannot apply lens ${lens2.id}. It has not been loaded by the Lens repository. Use CameraKit.lensRepository.loadLens (or loadLensGroups) to load lens metadata before calling CameraKitSession.applyLens.`);
        }
        const { content, isThirdParty } = lensDetails;
        if (!content) {
          throw new Error(`Cannot apply lens ${lens2.id}. Metadata retrieved for this lens does not include the lens content URL.`);
        }
        return {
          lens: lens2,
          launchData: encodeLensLaunchData(launchData !== null && launchData !== void 0 ? launchData : {}, persistentStore !== null && persistentStore !== void 0 ? persistentStore : new ArrayBuffer(0)),
          content,
          isThirdParty
        };
      }), mergeMap(({ lens: lens2, launchData, content, isThirdParty }) => {
        const networkTimer = applyTimer.mark("network");
        return from(Promise.all([
          lensRepository.getLensContent(lens2).finally(() => networkTimer.measure("lens")),
          isThirdParty ? getUserDataAccess(lens2) : void 0,
          content.assetManifest.length > 0 ? lensAssetRepository.cacheAssets(content.assetManifest, lens2).finally(() => networkTimer.measure("assets")) : Promise.resolve()
        ])).pipe(tap(() => {
          networkTimer.measure();
          lensState.dispatch("downloadComplete", lens2);
        }), map(([{ lensBuffer, lensChecksum }, userDataAccess]) => {
          const lensDataBuffer = lensBuffer.slice(0);
          return {
            lensId: lens2.id,
            lensDataBuffer,
            lensChecksum,
            launchData,
            apiVisibility: isThirdParty ? lensCore.LensApiVisibility.Public : lensCore.LensApiVisibility.Private,
            publicApiUserDataAccess: userDataAccess === "restricted" ? lensCore.UserDataAccess.Restricted : lensCore.UserDataAccess.Unrestricted
          };
        }));
      }))
    }).pipe(takeUntil(lensState.events.pipe(forActions("removeLens"))), mergeMap(({ lensInput, watermarkInput }) => new Observable((subscriber) => {
      const coreTimer = applyTimer.mark("core");
      lensCore.replaceLenses({
        lenses: [
          Object.assign(Object.assign({}, lensInput), { onTurnOn: () => dispatch2("turnedOn"), onResourcesLoaded: () => dispatch2("resourcesLoaded"), onFirstFrameProcessed: () => {
            coreTimer.measure("first-frame");
            applyTimer.measure("success");
            applyTimer.stopAndReport(metrics);
            dispatch2("firstFrameProcessed");
          }, onTurnOff: () => dispatch2("turnedOff") }),
          ...watermarkInput ? [watermarkInput] : []
        ]
      }).then(() => {
        coreTimer.measure("success");
        subscriber.next(lensState.actions.applyLensComplete(lens));
        subscriber.complete();
      }).catch((lensCoreError) => {
        coreTimer.measure("failure");
        applyTimer.measure("failure");
        applyTimer.stopAndReport(metrics);
        const message = `Failed to apply lens ${lensInput.lensId}.`;
        const error = /validation failed/.test(lensCoreError.message) ? lensContentValidationError(message, lensCoreError) : lensError(message, lensCoreError);
        subscriber.next(lensState.actions.applyLensFailed({ error, lens }));
        subscriber.complete();
      });
    })), catchError((error) => {
      applyTimer.measure("failure");
      applyTimer.stopAndReport(metrics);
      return of(lensState.actions.applyLensFailed({ error, lens }));
    }), unsubscribed(() => {
      applyTimer.measure("abort");
      applyTimer.stopAndReport(metrics);
    }));
  }), dispatch(lensState)).subscribe({
    error: logger13.error
  });
  lensState.events.pipe(inStates("lensApplied", "noLensApplied"), forActions("removeLens"), mergeMap(() => new Observable((subscriber) => {
    lensCore.clearAllLenses().then(() => {
      subscriber.next(lensState.actions.removeLensComplete());
      subscriber.complete();
    }).catch((lensCoreError) => {
      const error = new Error("Failed to remove lenses.", { cause: lensCoreError });
      subscriber.next(lensState.actions.removeLensFailed(error));
      subscriber.complete();
    });
  })), dispatch(lensState)).subscribe({
    error: logger13.error
  });
  lensState.events.pipe(inStates("applyingLens"), forActions("removeLens"), switchMap(([a2]) => lensState.events.pipe(inStates("lensApplied"), takeUntil(lensState.events.pipe(forActions("applyLens"))), map(() => a2))), dispatch(lensState)).subscribe({
    error: logger13.error
  });
  lensState.events.subscribe(([a2, s2]) => {
    const data = extractLoggableData(a2);
    logger13.debug(`Action: "${a2.name}", state: "${s2.name}"${data ? ", data: " + JSON.stringify(data) : ""}`);
  });
  return lensState;
});
function extractLoggableData(action) {
  switch (action.name) {
    case "applyLens":
      return { lensId: action.data.lens.id };
    case "applyLensFailed":
      return { lensId: action.data.lens.id, error: action.data.error.message };
    case "downloadComplete":
    case "turnedOn":
    case "resourcesLoaded":
    case "firstFrameProcessed":
    case "applyLensComplete":
    case "applyLensAborted":
    case "turnedOff":
      return { lensId: action.data.id };
    case "removeLens":
    case "removeLensComplete":
      return void 0;
    case "removeLensFailed":
      return { error: action.data.message };
    default:
      assertUnreachable(action);
  }
}

// node_modules/@snap/camera-kit/dist/session/sessionState.js
var createSessionState = () => {
  const actions = defineActions(defineAction("suspend")(), defineAction("resume")(), defineAction("destroy")());
  const states = defineStates(defineState("inactive")(), defineState("active")(), defineState("destroyed")());
  return new StateMachine(actions, states, defineState("inactive")()(), (events) => {
    return merge(events.pipe(forActions("resume"), map(([a2]) => states.active(a2.data))), events.pipe(forActions("suspend"), map(() => states.inactive())), events.pipe(forActions("destroy"), map(() => states.destroyed())));
  });
};
var sessionStateFactory = Injectable("sessionState", () => createSessionState());

// node_modules/@snap/camera-kit/dist/session/LensKeyboard.js
var logger14 = getLogger("LensKeyboard");
var LensKeyboard = class {
  constructor(lensState) {
    this.lensState = lensState;
    this.active = false;
    this.text = void 0;
    this.reply = () => {
    };
    this.onElementKeyPress = this.onElementKeyPress.bind(this);
    this.events = new TypedEventTarget();
    this.element = document.createElement("textarea");
    this.element.addEventListener("keypress", this.onElementKeyPress);
    this.uriHandler = {
      uri: "app://textInput/",
      handleRequest: (request, reply) => {
        if (request.uri === "app://textInput/requestKeyboard") {
          const data = JSON.parse(new TextDecoder().decode(request.data));
          this.element.value = data.text;
          this.text = data.text;
          this.reply = reply;
          this.active = true;
          this.notifyClient();
          this.element.focus();
        } else if (request.uri === "app://textInput/dismissKeyboard") {
          this.active = false;
          this.sendReply({ keyboardOpen: false });
          this.notifyClient();
        } else {
          logger14.error(new Error(`Unhandled lens keyboard request '${request.uri}'.`));
        }
      }
    };
    lensState.events.pipe(forActions("turnedOff")).subscribe(() => {
      this.dismiss();
    });
  }
  dismiss() {
    this.active = false;
    this.element.value = "";
    this.text = "";
    this.sendReply({ keyboardOpen: false });
    this.notifyClient();
  }
  getElement() {
    return this.element;
  }
  sendInputToLens(text) {
    this.element.value = text;
    this.text = text;
    this.sendReply({
      text,
      start: text.length,
      end: text.length,
      done: true,
      shouldNotify: true
    });
  }
  addEventListener(type, callback, options) {
    this.events.addEventListener(type, callback, options);
  }
  removeEventListener(type, callback) {
    this.events.removeEventListener(type, callback);
  }
  toPublicInterface() {
    return {
      addEventListener: this.addEventListener.bind(this),
      removeEventListener: this.removeEventListener.bind(this),
      sendInputToLens: this.sendInputToLens.bind(this),
      dismiss: this.dismiss.bind(this),
      getElement: this.getElement.bind(this)
    };
  }
  destroy() {
    this.element.removeEventListener("keypress", this.onElementKeyPress);
  }
  sendReply(data) {
    this.reply({
      code: 200,
      description: "",
      contentType: "application/json",
      data: new TextEncoder().encode(JSON.stringify(data))
    });
  }
  notifyClient() {
    var _a;
    const state = this.lensState.getState();
    if (isState(state, "noLensApplied"))
      return;
    this.events.dispatchEvent(new TypedCustomEvent("active", {
      element: this.element,
      active: this.active,
      text: (_a = this.text) !== null && _a !== void 0 ? _a : "",
      lens: state.data
    }));
  }
  onElementKeyPress(event) {
    if (event.code === "Enter" && !event.shiftKey) {
      event.preventDefault();
      this.sendInputToLens(this.element.value);
    }
  }
};
var lensKeyboardFactory = Injectable("lensKeyboard", [lensStateFactory.token], (lensState) => new LensKeyboard(lensState));

// node_modules/@snap/camera-kit/dist/session/CameraKitSessionEvents.js
var isReachable = (_) => false;
function isPublicLensError(value) {
  if (!(value instanceof Error))
    return false;
  const maybeSessionErrorName = value.name;
  switch (maybeSessionErrorName) {
    case "LensAbortError":
    case "LensExecutionError":
    case "LensImagePickerError":
      return true;
    default:
      return isReachable(maybeSessionErrorName);
  }
}

// node_modules/@snap/camera-kit/dist/session/CameraKitSession.js
var logger15 = getLogger("CameraKitSession");
function isAllowedSource(value) {
  return isCameraKitSource(value) || isMediaStream(value) || isHTMLVideoElement(value);
}
function isMediaStream(value) {
  return value instanceof MediaStream;
}
function isHTMLVideoElement(value) {
  return value instanceof HTMLVideoElement;
}
function isRenderTargetOrUndefined(value) {
  return isUndefined(value) || value === "live" || value === "capture";
}
var CameraKitSession2 = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _applyLens_decorators;
  let _removeLens_decorators;
  let _play_decorators;
  let _pause_decorators;
  let _mute_decorators;
  let _unmute_decorators;
  let _setSource_decorators;
  let _setFPSLimit_decorators;
  let _destroy_decorators;
  return _a = class CameraKitSession {
    constructor(innerKeyboard, lensCore, sessionState, lensState, logEntries, pageVisibility) {
      this.innerKeyboard = (__runInitializers(this, _instanceExtraInitializers), innerKeyboard);
      this.lensCore = lensCore;
      this.sessionState = sessionState;
      this.lensState = lensState;
      this.events = new TypedEventTarget();
      this.keyboard = innerKeyboard.toPublicInterface();
      const outputs = this.lensCore.getOutputCanvases();
      this.output = {
        live: outputs[this.lensCore.CanvasType.Preview.value],
        capture: outputs[this.lensCore.CanvasType.Capture.value]
      };
      this.playing = {
        live: false,
        capture: false
      };
      this.metrics = new LensPerformanceMetrics(this.lensCore);
      const removeOnHidden = pageVisibility.onPageHidden(() => this.sessionState.dispatch("suspend", this));
      const removeOnVisible = pageVisibility.onPageVisible(() => this.sessionState.dispatch("resume", this));
      this.removePageVisibilityHandlers = () => {
        removeOnHidden();
        removeOnVisible();
      };
      this.subscriptions = [
        lensCore.errors.pipe(filter((error) => error.name === "LensCoreAbortError")).subscribe(() => this.destroy()),
        lensCore.errors.pipe(filter((error) => error.name !== "LensCoreAbortError" && error.isFrameError)).subscribe(() => this.removeLens()),
        logEntries.pipe(filter((entry) => entry.level === "error"), map((entry) => entry.messages.find((e2) => e2 instanceof Error)), filter(isPublicLensError)).subscribe((error) => {
          const state = lensState.getState();
          if (!isState(state, "noLensApplied")) {
            this.events.dispatchEvent(new TypedCustomEvent("error", { error, lens: state.data }));
          } else {
            logger15.warn("Lens error occurred even though there is no active lens.", error);
          }
        })
      ];
    }
    applyLens(lens, launchData) {
      return __awaiter(this, void 0, void 0, function* () {
        const action = this.lensState.actions.applyLens({ lens, launchData });
        return firstValueFrom(of(action).pipe(dispatch(this.lensState), takeUntil(this.lensState.events.pipe(forActions("applyLens"), filter(([a2]) => a2 !== action))), tap(([a2]) => {
          if (isAction(a2, "applyLensFailed") && a2.data.lens.id === lens.id)
            throw a2.data.error;
        }), inStates("lensApplied"), map(() => true)), { defaultValue: false });
      });
    }
    removeLens() {
      return __awaiter(this, void 0, void 0, function* () {
        if (isState(this.lensState.getState(), "noLensApplied"))
          return true;
        return firstValueFrom(of(this.lensState.actions.removeLens()).pipe(dispatch(this.lensState), tap(([a2]) => {
          if (isAction(a2, "removeLensFailed"))
            throw a2.data;
        }), inStates("noLensApplied"), takeUntil(this.lensState.events.pipe(forActions("applyLens"))), map(() => true)), { defaultValue: false });
      });
    }
    play(target = "live") {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.playing[target])
          return;
        this.playing[target] = true;
        const type = this.renderTargetToCanvasType(target);
        return this.lensCore.playCanvas({ type }).catch((error) => {
          this.playing[target] = false;
          throw error;
        });
      });
    }
    pause(target = "live") {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.playing[target] === false)
          return;
        this.playing[target] = false;
        const type = this.renderTargetToCanvasType(target);
        return this.lensCore.pauseCanvas({ type }).catch((error) => {
          this.playing[target] = true;
          throw error;
        });
      });
    }
    mute(fade = false) {
      this.lensCore.setAllSoundsMuted({
        muted: true,
        fade
      });
    }
    unmute(fade = false) {
      this.lensCore.setAllSoundsMuted({
        muted: false,
        fade
      });
    }
    setSource(source, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        yield this.safelyDetachSource();
        const cameraKitSource = isMediaStream(source) ? createMediaStreamSource(source, options) : isHTMLVideoElement(source) ? createVideoSource(source, options) : source;
        const priorPlayingState = this.playing;
        this.playing = {
          live: false,
          capture: false
        };
        yield cameraKitSource.attach(this.lensCore, (error) => {
          logger15.error(cameraKitSourceError("Error occurred during source attachment.", error));
        });
        this.source = cameraKitSource;
        if (priorPlayingState.live)
          yield this.play("live");
        if (priorPlayingState.capture)
          yield this.play("capture");
        return cameraKitSource;
      });
    }
    setFPSLimit(fpsLimit) {
      return __awaiter(this, void 0, void 0, function* () {
        const fps = fpsLimit < Number.POSITIVE_INFINITY ? fpsLimit : 0;
        return this.lensCore.setFPSLimit({ fps });
      });
    }
    destroy() {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield this.lensCore.clearAllLenses();
          yield this.lensCore.teardown();
        } catch (error) {
          logger15.warn("An error occurred in LensCore during the session termination process.", error);
        }
        this.subscriptions.forEach((sub) => sub.unsubscribe());
        yield this.safelyDetachSource();
        this.removePageVisibilityHandlers();
        this.sessionState.dispatch("destroy", void 0);
        this.innerKeyboard.destroy();
      });
    }
    renderTargetToCanvasType(target) {
      return target === "capture" ? this.lensCore.CanvasType.Capture : this.lensCore.CanvasType.Preview;
    }
    safelyDetachSource() {
      return __awaiter(this, void 0, void 0, function* () {
        if (this.source) {
          try {
            yield this.source.detach((error) => {
              logger15.error(cameraKitSourceError("Error occurred during source detachment.", error));
            });
          } catch (error) {
            logger15.error(cameraKitSourceError(`Detaching prior source of type ${getTypeName(this.source)} failed.`, error));
          }
        }
      });
    }
  }, (() => {
    _applyLens_decorators = [validate(isLens, isLensLaunchDataOrUndefined), errorLoggingDecorator(logger15)];
    _removeLens_decorators = [errorLoggingDecorator(logger15)];
    _play_decorators = [validate(isRenderTargetOrUndefined), errorLoggingDecorator(logger15)];
    _pause_decorators = [validate(isRenderTargetOrUndefined), errorLoggingDecorator(logger15)];
    _mute_decorators = [errorLoggingDecorator(logger15)];
    _unmute_decorators = [errorLoggingDecorator(logger15)];
    _setSource_decorators = [validate(isAllowedSource, isPartialCameraKitDeviceOptionsOrUndefined), errorLoggingDecorator(logger15)];
    _setFPSLimit_decorators = [validate(isValidNumber), errorLoggingDecorator(logger15)];
    _destroy_decorators = [errorLoggingDecorator(logger15)];
    __esDecorate(_a, null, _applyLens_decorators, { kind: "method", name: "applyLens", static: false, private: false, access: { has: (obj) => "applyLens" in obj, get: (obj) => obj.applyLens } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _removeLens_decorators, { kind: "method", name: "removeLens", static: false, private: false, access: { has: (obj) => "removeLens" in obj, get: (obj) => obj.removeLens } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _play_decorators, { kind: "method", name: "play", static: false, private: false, access: { has: (obj) => "play" in obj, get: (obj) => obj.play } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _pause_decorators, { kind: "method", name: "pause", static: false, private: false, access: { has: (obj) => "pause" in obj, get: (obj) => obj.pause } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _mute_decorators, { kind: "method", name: "mute", static: false, private: false, access: { has: (obj) => "mute" in obj, get: (obj) => obj.mute } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _unmute_decorators, { kind: "method", name: "unmute", static: false, private: false, access: { has: (obj) => "unmute" in obj, get: (obj) => obj.unmute } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _setSource_decorators, { kind: "method", name: "setSource", static: false, private: false, access: { has: (obj) => "setSource" in obj, get: (obj) => obj.setSource } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _setFPSLimit_decorators, { kind: "method", name: "setFPSLimit", static: false, private: false, access: { has: (obj) => "setFPSLimit" in obj, get: (obj) => obj.setFPSLimit } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _destroy_decorators, { kind: "method", name: "destroy", static: false, private: false, access: { has: (obj) => "destroy" in obj, get: (obj) => obj.destroy } }, null, _instanceExtraInitializers);
  })(), _a;
})();
var cameraKitSessionFactory = Injectable("CameraKitSession", [
  lensCoreFactory.token,
  logEntriesFactory.token,
  lensKeyboardFactory.token,
  sessionStateFactory.token,
  lensStateFactory.token,
  pageVisibilityFactory.token
], (lensCore, logEntries, keyboard, sessionState, lensState, pageVisibility) => new CameraKitSession2(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility));

// node_modules/@snap/camera-kit/dist/lens/assets/LensAssetsProvider.js
var logger16 = getLogger("LensAssetProvider");
var maxConsecutiveErrors = 3;
var registerLensAssetsProvider = Injectable("registerLensAssetsProvider", [
  lensCoreFactory.token,
  lensRepositoryFactory.token,
  lensAssetRepositoryFactory.token,
  lensStateFactory.token
], (lensCore, lensRepository, lensAssetRepository, lensState) => {
  const consecutiveErrorsPerAsset = /* @__PURE__ */ new Map();
  lensCore.setRemoteAssetsProvider((assetDescriptor) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e;
    const { assetId, assetType, effectId } = assetDescriptor;
    try {
      if (((_a = consecutiveErrorsPerAsset.get(assetId)) !== null && _a !== void 0 ? _a : 0) > maxConsecutiveErrors) {
        throw new Error(`Maximum consecutive asset load errors reached for asset ${assetId}`);
      }
      const lensId = effectId !== null && effectId !== void 0 ? effectId : (_b = lensState.getState().data) === null || _b === void 0 ? void 0 : _b.id;
      const lens = lensId ? lensRepository.getLensMetadata(lensId) : void 0;
      yield lensAssetRepository.loadAsset({
        assetDescriptor,
        lens: lens && toPublicLens(lens),
        assetManifest: (_d = (_c = lens === null || lens === void 0 ? void 0 : lens.content) === null || _c === void 0 ? void 0 : _c.assetManifest) !== null && _d !== void 0 ? _d : [],
        lowPriority: false
      });
      consecutiveErrorsPerAsset.set(assetId, 0);
    } catch (error) {
      lensCore.provideRemoteAssetsResponse({
        assetId,
        assetType
      });
      const consecutiveErrors = ((_e = consecutiveErrorsPerAsset.get(assetId)) !== null && _e !== void 0 ? _e : 0) + 1;
      consecutiveErrorsPerAsset.set(assetId, consecutiveErrors);
      if (consecutiveErrors <= maxConsecutiveErrors) {
        logger16.error(lensAssetError(`Error occurred while handling lens asset ${assetId} request.`, error));
      } else {
        logger16.warn(`Maximum consecutive asset load errors reached for asset ${assetId}`);
      }
    }
  }));
});

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/remote_api_spec.js
var RemoteEndpoint_HttpRequestMethod;
(function(RemoteEndpoint_HttpRequestMethod2) {
  RemoteEndpoint_HttpRequestMethod2[RemoteEndpoint_HttpRequestMethod2["METHOD_UNSET"] = 0] = "METHOD_UNSET";
  RemoteEndpoint_HttpRequestMethod2[RemoteEndpoint_HttpRequestMethod2["GET"] = 1] = "GET";
  RemoteEndpoint_HttpRequestMethod2[RemoteEndpoint_HttpRequestMethod2["POST"] = 2] = "POST";
  RemoteEndpoint_HttpRequestMethod2[RemoteEndpoint_HttpRequestMethod2["PUT"] = 3] = "PUT";
  RemoteEndpoint_HttpRequestMethod2[RemoteEndpoint_HttpRequestMethod2["DELETE"] = 4] = "DELETE";
  RemoteEndpoint_HttpRequestMethod2[RemoteEndpoint_HttpRequestMethod2["PATCH"] = 5] = "PATCH";
  RemoteEndpoint_HttpRequestMethod2[RemoteEndpoint_HttpRequestMethod2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RemoteEndpoint_HttpRequestMethod || (RemoteEndpoint_HttpRequestMethod = {}));
var RemoteParameter_ParameterLocation;
(function(RemoteParameter_ParameterLocation2) {
  RemoteParameter_ParameterLocation2[RemoteParameter_ParameterLocation2["LOCATION_UNSET"] = 0] = "LOCATION_UNSET";
  RemoteParameter_ParameterLocation2[RemoteParameter_ParameterLocation2["QUERY"] = 1] = "QUERY";
  RemoteParameter_ParameterLocation2[RemoteParameter_ParameterLocation2["HEADER"] = 2] = "HEADER";
  RemoteParameter_ParameterLocation2[RemoteParameter_ParameterLocation2["PATH"] = 3] = "PATH";
  RemoteParameter_ParameterLocation2[RemoteParameter_ParameterLocation2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(RemoteParameter_ParameterLocation || (RemoteParameter_ParameterLocation = {}));
function createBaseGetRemoteApiSpecsRequest() {
  return {};
}
var GetRemoteApiSpecsRequest = {
  encode(_, writer = new BinaryWriter()) {
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetRemoteApiSpecsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetRemoteApiSpecsRequest.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(_) {
    const message = createBaseGetRemoteApiSpecsRequest();
    return message;
  }
};
function createBaseGetRemoteApiSpecsResponse() {
  return { remoteApiSpecs: [] };
}
var GetRemoteApiSpecsResponse = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.remoteApiSpecs) {
      RemoteApiSpec.encode(v2, writer.uint32(10).fork()).join();
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseGetRemoteApiSpecsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.remoteApiSpecs.push(RemoteApiSpec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return GetRemoteApiSpecsResponse.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseGetRemoteApiSpecsResponse();
    message.remoteApiSpecs = ((_a = object.remoteApiSpecs) === null || _a === void 0 ? void 0 : _a.map((e2) => RemoteApiSpec.fromPartial(e2))) || [];
    return message;
  }
};
function createBaseRemoteApiSpec() {
  return {
    id: "",
    host: "",
    endpoints: [],
    tlsRequired: false,
    maxRequestSizeBytes: 0,
    maxResponseSizeBytes: 0,
    maxResponseTimeMillis: 0
  };
}
var RemoteApiSpec = {
  encode(message, writer = new BinaryWriter()) {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    for (const v2 of message.endpoints) {
      RemoteEndpoint.encode(v2, writer.uint32(26).fork()).join();
    }
    if (message.tlsRequired !== false) {
      writer.uint32(32).bool(message.tlsRequired);
    }
    if (message.maxRequestSizeBytes !== 0) {
      writer.uint32(40).int32(message.maxRequestSizeBytes);
    }
    if (message.maxResponseSizeBytes !== 0) {
      writer.uint32(48).int32(message.maxResponseSizeBytes);
    }
    if (message.maxResponseTimeMillis !== 0) {
      writer.uint32(56).int32(message.maxResponseTimeMillis);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteApiSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }
          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.endpoints.push(RemoteEndpoint.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }
          message.tlsRequired = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }
          message.maxRequestSizeBytes = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.maxResponseSizeBytes = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }
          message.maxResponseTimeMillis = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RemoteApiSpec.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f, _g;
    const message = createBaseRemoteApiSpec();
    message.id = (_a = object.id) !== null && _a !== void 0 ? _a : "";
    message.host = (_b = object.host) !== null && _b !== void 0 ? _b : "";
    message.endpoints = ((_c = object.endpoints) === null || _c === void 0 ? void 0 : _c.map((e2) => RemoteEndpoint.fromPartial(e2))) || [];
    message.tlsRequired = (_d = object.tlsRequired) !== null && _d !== void 0 ? _d : false;
    message.maxRequestSizeBytes = (_e = object.maxRequestSizeBytes) !== null && _e !== void 0 ? _e : 0;
    message.maxResponseSizeBytes = (_f = object.maxResponseSizeBytes) !== null && _f !== void 0 ? _f : 0;
    message.maxResponseTimeMillis = (_g = object.maxResponseTimeMillis) !== null && _g !== void 0 ? _g : 0;
    return message;
  }
};
function createBaseRemoteEndpoint() {
  return { path: "", methods: [], parameters: [], refId: "" };
}
var RemoteEndpoint = {
  encode(message, writer = new BinaryWriter()) {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    writer.uint32(18).fork();
    for (const v2 of message.methods) {
      writer.int32(v2);
    }
    writer.join();
    for (const v2 of message.parameters) {
      RemoteParameter.encode(v2, writer.uint32(26).fork()).join();
    }
    if (message.refId !== "") {
      writer.uint32(34).string(message.refId);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteEndpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.methods.push(reader.int32());
            continue;
          }
          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.methods.push(reader.int32());
            }
            continue;
          }
          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }
          message.parameters.push(RemoteParameter.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.refId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RemoteEndpoint.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d;
    const message = createBaseRemoteEndpoint();
    message.path = (_a = object.path) !== null && _a !== void 0 ? _a : "";
    message.methods = ((_b = object.methods) === null || _b === void 0 ? void 0 : _b.map((e2) => e2)) || [];
    message.parameters = ((_c = object.parameters) === null || _c === void 0 ? void 0 : _c.map((e2) => RemoteParameter.fromPartial(e2))) || [];
    message.refId = (_d = object.refId) !== null && _d !== void 0 ? _d : "";
    return message;
  }
};
function createBaseRemoteParameter() {
  return { name: "", location: 0, optional: false, externalName: "", defaultValue: "", constant: false };
}
var RemoteParameter = {
  encode(message, writer = new BinaryWriter()) {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.location !== 0) {
      writer.uint32(16).int32(message.location);
    }
    if (message.optional !== false) {
      writer.uint32(24).bool(message.optional);
    }
    if (message.externalName !== "") {
      writer.uint32(34).string(message.externalName);
    }
    if (message.defaultValue !== "") {
      writer.uint32(42).string(message.defaultValue);
    }
    if (message.constant !== false) {
      writer.uint32(48).bool(message.constant);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteParameter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }
          message.location = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }
          message.optional = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }
          message.externalName = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }
          message.defaultValue = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }
          message.constant = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RemoteParameter.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a, _b, _c, _d, _e, _f;
    const message = createBaseRemoteParameter();
    message.name = (_a = object.name) !== null && _a !== void 0 ? _a : "";
    message.location = (_b = object.location) !== null && _b !== void 0 ? _b : 0;
    message.optional = (_c = object.optional) !== null && _c !== void 0 ? _c : false;
    message.externalName = (_d = object.externalName) !== null && _d !== void 0 ? _d : "";
    message.defaultValue = (_e = object.defaultValue) !== null && _e !== void 0 ? _e : "";
    message.constant = (_f = object.constant) !== null && _f !== void 0 ? _f : false;
    return message;
  }
};
var RemoteApiSpecsDefinition = {
  name: "RemoteApiSpecs",
  fullName: "com.snap.camerakit.v3.RemoteApiSpecs",
  methods: {
    getRemoteApiSpecs: {
      name: "GetRemoteApiSpecs",
      requestType: GetRemoteApiSpecsRequest,
      requestStream: false,
      responseType: GetRemoteApiSpecsResponse,
      responseStream: false,
      options: { idempotencyLevel: "NO_SIDE_EFFECTS" }
    }
  }
};

// node_modules/@snap/camera-kit/dist/clients/remoteApiSpecsClient.js
var remoteApiSpecsClientFactory = Injectable("remoteApiSpecsClient", [grpcHandlerFactory.token], (grpcHandler) => createTsProtoClient(RemoteApiSpecsDefinition, grpcHandler));

// node_modules/@snap/camera-kit/dist/uri-handlers/uriRequestProcessor.js
function callCancellationHandler(cancellationHandlers, ...keys) {
  var _a;
  for (const key of keys) {
    (_a = cancellationHandlers.get(key)) === null || _a === void 0 ? void 0 : _a();
    cancellationHandlers.delete(key);
  }
}
function handleLensApplicationEnd(lensRequestState, ...lensIds) {
  for (const lensId of lensIds) {
    const state = lensRequestState.get(lensId);
    if (state) {
      callCancellationHandler(state.cancellationHandlers, ...state.cancellationHandlers.keys());
      lensRequestState.delete(lensId);
    }
  }
}
function createUriRequestProcessor({ uri, lensState, sessionState, createLensRequestState, processRequest, processInternalError }) {
  const uriRequests = new Subject();
  const uriCancelRequests = new Subject();
  const lensRequestState = /* @__PURE__ */ new Map();
  const lensTurnOffEvents = lensState.events.pipe(forActions("turnedOff"), tap(([action]) => handleLensApplicationEnd(lensRequestState, action.data.id)));
  const uriRequestEvents = uriRequests.pipe(map(({ request, lens, reply }) => {
    if (!lensRequestState.has(lens.id)) {
      const custom = createLensRequestState === null || createLensRequestState === void 0 ? void 0 : createLensRequestState(request, lens);
      const state = {
        cancellationHandlers: /* @__PURE__ */ new Map(),
        custom
      };
      lensRequestState.set(lens.id, state);
    }
    const requestState = lensRequestState.get(lens.id);
    return {
      request,
      reply,
      lens,
      state: requestState.custom,
      setCancellationHandler: (fn) => {
        requestState.cancellationHandlers.set(request.identifier, fn);
      }
    };
  }), tap(processRequest));
  const uriCancelRequestEvents = uriCancelRequests.pipe(tap((uriRequest) => {
    var _a;
    const cancellationHandlers = (_a = lensRequestState.get(uriRequest.lens.id)) === null || _a === void 0 ? void 0 : _a.cancellationHandlers;
    if (cancellationHandlers) {
      callCancellationHandler(cancellationHandlers, uriRequest.request.requestId);
    }
  }));
  merge(lensTurnOffEvents, uriRequestEvents, uriCancelRequestEvents).pipe(catchError((error, sourcePipe) => {
    processInternalError(error);
    return sourcePipe;
  }), retry(), takeUntil(sessionState.events.pipe(forActions("destroy")))).subscribe({
    complete: () => handleLensApplicationEnd(lensRequestState, ...lensRequestState.keys())
  });
  return {
    uri,
    handleRequest(request, reply, lens) {
      uriRequests.next({ request, reply, lens });
    },
    cancelRequest(request, lens) {
      uriCancelRequests.next({ request, lens });
    }
  };
}

// node_modules/@snap/camera-kit/dist/uri-handlers/internal-handlers/httpValidators.js
var requestValidationErrorName = "RequestValidationError";
var requestValidationError = namedError(requestValidationErrorName);
function validateRequest(request, specs) {
  var _a;
  const url = new URL(request.uri);
  for (const spec of specs) {
    if (url.host !== spec.host || url.protocol !== (spec.tlsRequired ? "https:" : "http:")) {
      continue;
    }
    const path = url.pathname.replace(/^\/|\/$/g, "");
    for (const endpoint of spec.endpoints) {
      const endpointPath = endpoint.path.replace(/^\/|\/$/g, "");
      if (!path.startsWith(endpointPath))
        continue;
      const method = (_a = RemoteEndpoint_HttpRequestMethod[request.method]) !== null && _a !== void 0 ? _a : RemoteEndpoint_HttpRequestMethod.UNRECOGNIZED;
      if (!endpoint.methods.includes(method))
        continue;
      validatePath(path.split(endpointPath)[1], endpoint.parameters);
      validateHeaders(request.metadata, endpoint.parameters);
      validateQuery(url.searchParams, endpoint.parameters);
      return;
    }
  }
  throw requestValidationError("The request does not match any of the Remote API specifications.");
}
function validatePath(path, parameters) {
  const pathComponents = path.split("/").filter(Boolean);
  let paramIndex = 0;
  for (const param of parameters) {
    if (param.location !== RemoteParameter_ParameterLocation.PATH)
      continue;
    const paramNameComponent = pathComponents[paramIndex];
    const paramValueComponent = pathComponents[paramIndex + 1];
    if (param.constant) {
      if (paramNameComponent === param.name && paramValueComponent === param.defaultValue) {
        paramIndex += 2;
      } else {
        throw requestValidationError(`Expected constant parameter '${param.name}' with value '${param.defaultValue}' at position ${paramIndex}, but found '${paramNameComponent}' and '${paramValueComponent}'.`);
      }
    } else if (param.optional) {
      if (paramNameComponent === param.name) {
        if (paramValueComponent !== void 0) {
          paramIndex += 2;
        } else {
          paramIndex += 1;
        }
      }
    } else {
      if (paramNameComponent === param.name && paramValueComponent !== void 0) {
        paramIndex += 2;
      } else {
        throw requestValidationError(`Expected parameter '${param.name}' with a value at position ${paramIndex}, but found '${paramNameComponent}' and '${paramValueComponent}'.`);
      }
    }
  }
  if (paramIndex !== pathComponents.length) {
    const invalidPath = pathComponents.slice(paramIndex).join("/");
    throw requestValidationError(`Unexpected extra path components starting at position ${paramIndex}: '${invalidPath}'.`);
  }
}
function validateHeaders(headers, parameters) {
  for (const param of parameters) {
    if (param.location !== RemoteParameter_ParameterLocation.HEADER)
      continue;
    const headerValue = headers[param.name];
    if (param.constant) {
      if (headerValue !== param.defaultValue) {
        throw requestValidationError(`Expected constant header '${param.name}' with value '${param.defaultValue}', but found '${headerValue !== null && headerValue !== void 0 ? headerValue : "undefined"}'.`);
      }
    } else if (param.optional) {
    } else {
      if (headerValue == void 0 || isEmptyString(headerValue)) {
        throw requestValidationError(`Required header '${param.name}' is missing or empty.`);
      }
    }
  }
}
function validateQuery(queryParams, parameters) {
  for (const param of parameters) {
    if (param.location !== RemoteParameter_ParameterLocation.QUERY)
      continue;
    const paramValue = queryParams.get(param.name);
    if (param.constant) {
      if (paramValue !== param.defaultValue) {
        throw requestValidationError(`Expected constant query parameter '${param.name}' with value '${param.defaultValue}', but found '${paramValue !== null && paramValue !== void 0 ? paramValue : "undefined"}'.`);
      }
    } else if (param.optional) {
    } else {
      if (paramValue == void 0 || isEmptyString(paramValue)) {
        throw requestValidationError(`Required query parameter '${param.name}' is missing or empty.`);
      }
    }
  }
}

// node_modules/@snap/camera-kit/dist/uri-handlers/internal-handlers/httpUriHandler.js
var logger17 = getLogger("lensHttpHandler");
var lensHttpHandlerErrorName = "LensHttpHandlerError";
var lensHttpHandlerError = namedError(lensHttpHandlerErrorName);
var allowedResponseHeaders = [
  "Accept-Ranges",
  "Cache-Control",
  "Content-Language",
  "Content-Length",
  "Content-Type",
  "Date",
  "ETag",
  "Expires",
  "Last-Modified",
  "Location"
];
var requestHeadersToExclude = ["x-sc-lenses-remote-api-spec-id"];
function createHttpUriHandler(lensState, sessionState, remoteApiSpecsClient, customLentFetchHandler) {
  let allowlistPromise = void 0;
  return createUriRequestProcessor({
    uri: ["http://", "https://"],
    lensState,
    sessionState,
    processRequest({ request, lens, reply, setCancellationHandler }) {
      return __awaiter(this, void 0, void 0, function* () {
        allowlistPromise = allowlistPromise !== null && allowlistPromise !== void 0 ? allowlistPromise : getAllowlist(remoteApiSpecsClient);
        const allowlist = yield allowlistPromise;
        handleHttpUriRequest(request, lens, reply, setCancellationHandler, allowlist, customLentFetchHandler);
      });
    },
    processInternalError(error) {
      logger17.error(error);
    }
  });
}
function getAllowlist(remoteApiSpecsClient) {
  var _a, _b;
  return __awaiter(this, void 0, void 0, function* () {
    const result = yield remoteApiSpecsClient.getRemoteApiSpecs({});
    if (!result.ok)
      throw new Error("Failed getting Remote API specs.", { cause: result.unwrapErr() });
    return (_b = (_a = result.unwrap().message) === null || _a === void 0 ? void 0 : _a.remoteApiSpecs) !== null && _b !== void 0 ? _b : [];
  });
}
function handleHttpUriRequest(request, lens, reply, setCancellationHandler, allowlist, customLensHttpHandler) {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      validateRequest(request, allowlist);
      const { url, init } = mapLensToFetchRequest(request);
      const abortController = new AbortController();
      init.signal = abortController.signal;
      setCancellationHandler(() => abortController.abort());
      let response;
      if (customLensHttpHandler) {
        const handlerName = "lensHttpHandler";
        try {
          const { uri, identifier, method, metadata, data } = request;
          const responsePromise = customLensHttpHandler(url, init, {
            url: uri,
            identifier,
            method,
            data,
            headers: metadata,
            lens
          });
          if (!isPromise2(responsePromise)) {
            throw lensHttpHandlerError(`The '${handlerName}' callback provided to Camera Kit must return a Promise.`);
          }
          response = yield responsePromise;
        } catch (error) {
          error = error instanceof Error && error.name === lensHttpHandlerErrorName ? error : lensHttpHandlerError(`The '${handlerName}' callback provided to Camera Kit configuration failed.`, error);
          throw error;
        }
      } else {
        response = yield fetch(url, init);
      }
      reply(yield mapFetchToLensResponse(response));
    } catch (error) {
      if (error instanceof Error && error.name === lensHttpHandlerErrorName) {
        logger17.warn(error);
        reply(getErrorResponse("LensHttpHandlerError", `The lens HTTP request handler provided to Camera Kit failed.`));
      } else if (error instanceof Error && error.name === requestValidationErrorName) {
        logger17.warn(error);
        reply(getErrorResponse("RequestValidationError", error.message));
      } else {
        logger17.error(error);
        reply(getErrorResponse("UnknownError", "An unknown error occurred."));
      }
    }
  });
}
function getErrorResponse(errorType, message) {
  return {
    code: 400,
    description: "",
    contentType: "text/plain",
    metadata: {
      "x-camera-kit-error-type": errorType
    },
    data: new TextEncoder().encode(message)
  };
}
function mapLensToFetchRequest({ uri, method, metadata, data }) {
  const headers = new Headers(metadata);
  for (const header of requestHeadersToExclude) {
    headers.delete(header);
  }
  return {
    url: uri,
    init: {
      headers: Object.fromEntries(headers.entries()),
      body: method !== "GET" && method !== "HEAD" && method !== void 0 ? data : void 0,
      method
    }
  };
}
function mapFetchToLensResponse(response) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    const metadata = {};
    for (const allowedHeader of allowedResponseHeaders) {
      const value = response.headers.get(allowedHeader);
      if (value) {
        metadata[allowedHeader.toLowerCase()] = value;
      }
    }
    return {
      code: response.status,
      description: "",
      contentType: (_a = response.headers.get("Content-Type")) !== null && _a !== void 0 ? _a : "",
      metadata,
      data: yield response.arrayBuffer()
    };
  });
}

// node_modules/@snap/camera-kit/dist/uri-handlers/UriHandlers.js
var SEPARATOR = "://";
function extractSchemeAndRoute(uri) {
  const separatorIndex = uri.indexOf(SEPARATOR);
  const scheme = uri.slice(0, separatorIndex);
  const route = uri.slice(separatorIndex + SEPARATOR.length);
  return { scheme, route };
}
function isUri(value) {
  return isString(value) && value.includes(SEPARATOR);
}
function isUriHandler(value) {
  return isRecord(value) && (isUri(value.uri) || isArrayOfType(isUri, value.uri)) && isFunction2(value.handleRequest) && (isUndefined(value.cancelRequest) || isFunction2(value.cancelRequest));
}
function isUriHandlers(value) {
  return isArrayOfType(isUriHandler, value);
}
function isUriResponse(value) {
  return isRecord(value) && isNumber(value.code) && isString(value.description) && isString(value.contentType) && (isArrayBuffer(value.data) || isTypedArray(value.data)) && (isUndefined(value.metadata) || predicateRecordValues(isString)(value.metadata));
}
var uriHandlersFactory = Injectable("UriHandlers", () => {
  const uriHandlers = [];
  return uriHandlers;
});

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/camera_kit/v3/features/remote_api_info.js
function createBaseRemoteApiInfo() {
  return { apiSpecIds: [] };
}
var RemoteApiInfo = {
  encode(message, writer = new BinaryWriter()) {
    for (const v2 of message.apiSpecIds) {
      writer.uint32(10).string(v2);
    }
    return writer;
  },
  decode(input, length) {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === void 0 ? reader.len : reader.pos + length;
    const message = createBaseRemoteApiInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }
          message.apiSpecIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },
  create(base) {
    return RemoteApiInfo.fromPartial(base !== null && base !== void 0 ? base : {});
  },
  fromPartial(object) {
    var _a;
    const message = createBaseRemoteApiInfo();
    message.apiSpecIds = ((_a = object.apiSpecIds) === null || _a === void 0 ? void 0 : _a.map((e2) => e2)) || [];
    return message;
  }
};

// node_modules/@snap/camera-kit/dist/generated-proto/pb_schema/lenses/remote_api/remote_api_service.js
var HttpRequestMethod;
(function(HttpRequestMethod2) {
  HttpRequestMethod2["HTTP_METHOD_UNSET"] = "HTTP_METHOD_UNSET";
  HttpRequestMethod2["HTTP_METHOD_GET"] = "HTTP_METHOD_GET";
  HttpRequestMethod2["HTTP_METHOD_POST"] = "HTTP_METHOD_POST";
  HttpRequestMethod2["HTTP_METHOD_PUT"] = "HTTP_METHOD_PUT";
  HttpRequestMethod2["HTTP_METHOD_DELETE"] = "HTTP_METHOD_DELETE";
  HttpRequestMethod2["HTTP_METHOD_PATCH"] = "HTTP_METHOD_PATCH";
  HttpRequestMethod2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(HttpRequestMethod || (HttpRequestMethod = {}));
var ResponseCode;
(function(ResponseCode2) {
  ResponseCode2["RESPONSE_CODE_UNSET"] = "RESPONSE_CODE_UNSET";
  ResponseCode2["SUCCESS"] = "SUCCESS";
  ResponseCode2["REDIRECTED"] = "REDIRECTED";
  ResponseCode2["BAD_REQUEST"] = "BAD_REQUEST";
  ResponseCode2["ACCESS_DENIED"] = "ACCESS_DENIED";
  ResponseCode2["NOT_FOUND"] = "NOT_FOUND";
  ResponseCode2["TIMEOUT"] = "TIMEOUT";
  ResponseCode2["REQUEST_TOO_LARGE"] = "REQUEST_TOO_LARGE";
  ResponseCode2["SERVER_ERROR"] = "SERVER_ERROR";
  ResponseCode2["CANCELLED"] = "CANCELLED";
  ResponseCode2["PROXY_ERROR"] = "PROXY_ERROR";
  ResponseCode2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(ResponseCode || (ResponseCode = {}));
function responseCodeToNumber(object) {
  switch (object) {
    case ResponseCode.RESPONSE_CODE_UNSET:
      return 0;
    case ResponseCode.SUCCESS:
      return 1;
    case ResponseCode.REDIRECTED:
      return 2;
    case ResponseCode.BAD_REQUEST:
      return 3;
    case ResponseCode.ACCESS_DENIED:
      return 4;
    case ResponseCode.NOT_FOUND:
      return 5;
    case ResponseCode.TIMEOUT:
      return 6;
    case ResponseCode.REQUEST_TOO_LARGE:
      return 7;
    case ResponseCode.SERVER_ERROR:
      return 8;
    case ResponseCode.CANCELLED:
      return 9;
    case ResponseCode.PROXY_ERROR:
      return 10;
    case ResponseCode.UNRECOGNIZED:
    default:
      return -1;
  }
}
var GetOAuth2InfoResponse_GrantType;
(function(GetOAuth2InfoResponse_GrantType2) {
  GetOAuth2InfoResponse_GrantType2["GRANT_TYPE_UNSET"] = "GRANT_TYPE_UNSET";
  GetOAuth2InfoResponse_GrantType2["AUTHORIZATION_CODE"] = "AUTHORIZATION_CODE";
  GetOAuth2InfoResponse_GrantType2["AUTHORIZATION_CODE_WITH_PKCE"] = "AUTHORIZATION_CODE_WITH_PKCE";
  GetOAuth2InfoResponse_GrantType2["IMPLICIT"] = "IMPLICIT";
  GetOAuth2InfoResponse_GrantType2["CLIENT_CREDENTIALS"] = "CLIENT_CREDENTIALS";
  GetOAuth2InfoResponse_GrantType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(GetOAuth2InfoResponse_GrantType || (GetOAuth2InfoResponse_GrantType = {}));
var TokenExchangeError_TokenExchangeErrorType;
(function(TokenExchangeError_TokenExchangeErrorType2) {
  TokenExchangeError_TokenExchangeErrorType2["ERROR_TYPE_UNSET"] = "ERROR_TYPE_UNSET";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_REQUEST"] = "INVALID_REQUEST";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_CLIENT"] = "INVALID_CLIENT";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_GRANT"] = "INVALID_GRANT";
  TokenExchangeError_TokenExchangeErrorType2["UNAUTHORIZED_CLIENT"] = "UNAUTHORIZED_CLIENT";
  TokenExchangeError_TokenExchangeErrorType2["UNSUPPORTED_GRANT_TYPE"] = "UNSUPPORTED_GRANT_TYPE";
  TokenExchangeError_TokenExchangeErrorType2["INVALID_SCOPE"] = "INVALID_SCOPE";
  TokenExchangeError_TokenExchangeErrorType2["UNRECOGNIZED"] = "UNRECOGNIZED";
})(TokenExchangeError_TokenExchangeErrorType || (TokenExchangeError_TokenExchangeErrorType = {}));

// node_modules/@snap/camera-kit/dist/uri-handlers/internal-handlers/remoteApiUriHandler.js
var logger18 = getLogger("RemoteApiServices");
var uriResponseOkCode = 200;
var apiResponseStatusHeader = ":sc_lens_api_status";
var apiBinaryContentType = "application/octet-stream";
var remoteApiInfoProtobufTypeUrl = "type.googleapis.com/com.snap.camerakit.v3.features.RemoteApiInfo";
var remoteApiUploadImageSpecId = "af3f69c8-2e62-441f-8b1c-d3956f7b336c";
var statusToResponseCodeMap = {
  success: ResponseCode.SUCCESS,
  redirected: ResponseCode.REDIRECTED,
  badRequest: ResponseCode.BAD_REQUEST,
  accessDenied: ResponseCode.ACCESS_DENIED,
  notFound: ResponseCode.NOT_FOUND,
  timeout: ResponseCode.TIMEOUT,
  requestTooLarge: ResponseCode.REQUEST_TOO_LARGE,
  serverError: ResponseCode.SERVER_ERROR,
  cancelled: ResponseCode.CANCELLED,
  proxyError: ResponseCode.PROXY_ERROR
};
var remoteApiServicesFactory = Injectable("remoteApiServices", () => {
  const remoteApiServices = [];
  return remoteApiServices;
});
function getFirstRequestHandler(services, remoteApiRequest, lens) {
  for (const service of services) {
    try {
      return service.getRequestHandler(remoteApiRequest, lens);
    } catch (error) {
      logger18.warn("Client's Remote API request handler factory threw an error.", error);
    }
  }
  return void 0;
}
function createRemoteApiUriHandler(registeredServices, sessionState, lensState, lensRepository, metrics) {
  const registeredServiceMap = /* @__PURE__ */ new Map();
  for (const service of registeredServices) {
    const existingServices = registeredServiceMap.get(service.apiSpecId) || [];
    registeredServiceMap.set(service.apiSpecId, [...existingServices, service]);
  }
  return createUriRequestProcessor({
    uri: "app://remote-api/performApiRequest",
    lensState,
    sessionState,
    createLensRequestState(_request, lens) {
      var _a, _b;
      return {
        supportedSpecIds: /* @__PURE__ */ new Set([
          ...((_b = (_a = lensRepository.getLensMetadata(lens.id)) === null || _a === void 0 ? void 0 : _a.featureMetadata) !== null && _b !== void 0 ? _b : []).filter((feature) => feature.typeUrl === remoteApiInfoProtobufTypeUrl).flatMap((any) => RemoteApiInfo.decode(any.value).apiSpecIds),
          remoteApiUploadImageSpecId
        ])
      };
    },
    processRequest({ request, reply, lens, setCancellationHandler, state }) {
      var _a, _b;
      const { route } = extractSchemeAndRoute(request.uri);
      const [specId, endpointIdWithQuery] = route.split("/").slice(2);
      const [endpointId] = endpointIdWithQuery.split("?");
      const dimensions = { specId };
      const reportSingleCount = (name) => {
        metrics.setOperationalMetrics(Count.count(joinMetricNames(["lens", "remote-api", name]), 1, dimensions));
      };
      reportSingleCount("requests");
      if (!(state === null || state === void 0 ? void 0 : state.supportedSpecIds.has(specId)))
        return;
      const remoteApiRequest = {
        apiSpecId: specId,
        body: request.data,
        endpointId,
        parameters: request.metadata
      };
      let requestHandler = getFirstRequestHandler((_a = registeredServiceMap.get(specId)) !== null && _a !== void 0 ? _a : [], remoteApiRequest, lens);
      if (!requestHandler && globalThis.__snap_camkit_ra_1) {
        requestHandler = getFirstRequestHandler((_b = registeredServiceMap.get(globalThis.__snap_camkit_ra_1)) !== null && _b !== void 0 ? _b : [], remoteApiRequest, lens);
      }
      if (!requestHandler)
        return;
      reportSingleCount("handled-requests");
      let cancellationHandler = void 0;
      try {
        cancellationHandler = requestHandler((response) => {
          var _a2;
          reportSingleCount("responses");
          const responseCode = (_a2 = statusToResponseCodeMap[response.status]) !== null && _a2 !== void 0 ? _a2 : ResponseCode.UNRECOGNIZED;
          const uriResponse = {
            code: uriResponseOkCode,
            description: "",
            contentType: apiBinaryContentType,
            data: response.body,
            metadata: Object.assign(Object.assign({}, response.metadata), { [apiResponseStatusHeader]: responseCodeToNumber(responseCode).toString() })
          };
          reply(uriResponse);
        });
      } catch (error) {
        logger18.warn("Client's Remote API request handler threw an error.", error);
      }
      if (typeof cancellationHandler === "function") {
        setCancellationHandler(() => {
          try {
            cancellationHandler();
          } catch (error) {
            logger18.warn("Client's Remote API request cancellation handler threw an error.", error);
          }
        });
      }
    },
    processInternalError(error) {
      logger18.error(error);
      metrics.setOperationalMetrics(Count.count(joinMetricNames(["lens", "remote-api", "errors"]), 1));
    }
  });
}

// node_modules/@snap/camera-kit/dist/uri-handlers/uriHandlersRegister.js
var logger19 = getLogger("uriHandlersRegister");
var registerUriHandlers = Injectable("registerUriHandlers", [
  configurationToken,
  lensCoreFactory.token,
  lensStateFactory.token,
  uriHandlersFactory.token,
  lensKeyboardFactory.token,
  remoteApiServicesFactory.token,
  lensRepositoryFactory.token,
  sessionStateFactory.token,
  metricsClientFactory.token,
  remoteApiSpecsClientFactory.token
], (configuration, lensCore, lensState, userHandlers, lensKeyboard, remoteApiServices, lensRepository, sessionState, metrics, remoteApiSpecsClient) => {
  if (!isUriHandlers(userHandlers)) {
    throw new Error("Expected an array of UriHandler objects");
  }
  const allHandlers = [
    createHttpUriHandler(lensState, sessionState, remoteApiSpecsClient, configuration.lensHttpHandler),
    ...userHandlers,
    lensKeyboard.uriHandler,
    createRemoteApiUriHandler(remoteApiServices, sessionState, lensState, lensRepository, metrics)
  ];
  for (const { uri, handleRequest, cancelRequest } of allHandlers) {
    const uris = Array.isArray(uri) ? uri : [uri];
    for (const { scheme, route } of uris.map(extractSchemeAndRoute)) {
      lensCore.registerUriListener(scheme, route, {
        handleRequest: (request) => {
          const reply = (response) => {
            if (!isUriResponse(response)) {
              throw new Error("Expected UriResponse object");
            }
            lensCore.provideUriResponse(request.identifier, response);
          };
          const state = lensState.getState();
          if (isState(state, "noLensApplied")) {
            logger19.warn(`Got a URI request for ${request.uri}, but there is no active lens. The request will not be processed.`);
            return;
          }
          handleRequest(request, reply, state.data);
        },
        cancelRequest: (request) => {
          if (cancelRequest) {
            const state = lensState.getState();
            if (isState(state, "noLensApplied")) {
              logger19.warn(`Got a URI cancel request for ${request.uri}, but there is no active lens. The cancel request will not be processed.`);
              return;
            }
            cancelRequest(request, state.data);
          }
        }
      });
    }
  }
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportGlobalException.js
var logMethods = entries2(logLevelMap).map(([level]) => level);
var maxBufferedEntries = 15;
var contextSeparator = "\n\n----------------- Context -----------------\n\n";
var methodLength = logMethods.reduce((max2, method) => Math.max(max2, method.length), 0);
function getContextString(logEntries) {
  const result = [];
  for (const { entry, count: count2, lastTime } of logEntries) {
    const time = entry.time.toISOString();
    const method = entry.level.padStart(methodLength);
    const messages = entry.messages.map(prettyPrintMessage).join(" ");
    let dupSuffix = count2 > 1 ? ` (Repeated ${count2} times with the last occurrence at ${lastTime.toISOString()})` : "";
    result.push(`${time} [${entry.module}] ${method}: ${messages}${dupSuffix}`);
  }
  return result.join("\n");
}
function prettyPrintMessage(message) {
  if (message instanceof Error)
    return stringifyErrorMessage(message);
  if (message instanceof Date)
    return message.toISOString();
  return message + "";
}
function reportExceptionToBlizzard(logEntries, metricsEventTarget, metrics, lensState) {
  logEntries.pipe(scan(({ entries: entries3 }, newEntry) => {
    const lastEntry = entries3[entries3.length - 1];
    const isNewEntryRepeated = lastEntry && lastEntry.entry.messages.join() === newEntry.messages.join() && lastEntry.entry.level === newEntry.level;
    if (isNewEntryRepeated) {
      lastEntry.count += 1;
      lastEntry.lastTime = newEntry.time;
    } else {
      entries3.push({
        entry: newEntry,
        count: 1,
        lastTime: newEntry.time
      });
    }
    return {
      entries: entries3.slice(-maxBufferedEntries),
      recent: newEntry
    };
  }, { entries: [], recent: { time: /* @__PURE__ */ new Date(), module: "any", level: "debug", messages: [] } }), filter(({ recent }) => recent.level === "error"), map(({ entries: entries3, recent }) => ({
    context: entries3,
    error: recent.messages.find((e2) => e2 instanceof Error)
  })), filter(({ error }) => !!error)).subscribe(({ error, context: context2 }) => {
    const currentLensState = lensState === null || lensState === void 0 ? void 0 : lensState.getState();
    const lensId = currentLensState && !isState(currentLensState, "noLensApplied") ? currentLensState.data.id : "none";
    metricsEventTarget.dispatchEvent(new TypedCustomEvent("exception", {
      name: "exception",
      lensId,
      type: error.name,
      reason: `${stringifyError(error)}${contextSeparator}${getContextString(context2)}`
    }));
    metrics.setOperationalMetrics(Count.count("handled_exception", 1, { type: error.name }));
  });
}
var reportGlobalException = Injectable("reportGlobalException", [logEntriesFactory.token, metricsEventTargetFactory.token, metricsClientFactory.token], (logEntries, metricsEventTarget, metrics) => {
  const cancellationSubject = new Subject();
  reportExceptionToBlizzard(logEntries.pipe(takeUntil(cancellationSubject)), metricsEventTarget, metrics);
  return {
    attachLensContext: (lensState) => {
      cancellationSubject.next();
      reportExceptionToBlizzard(logEntries, metricsEventTarget, metrics, lensState);
    }
  };
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportSessionException.js
var reportSessionException = Injectable("reportSessionException", [reportGlobalException.token, lensStateFactory.token], (globalExceptionReporter, lensState) => {
  globalExceptionReporter.attachLensContext(lensState);
});

// node_modules/@snap/camera-kit/dist/metrics/operational/Histogram.js
var Histogram = class _Histogram extends Metric {
  static level(name, level, dimensions = {}) {
    const histogram = new _Histogram(name, dimensions);
    histogram.add(level);
    return histogram;
  }
  constructor(name, dimensions = {}) {
    super(name, dimensions);
    this.name = name;
    this.levels = [];
  }
  add(level) {
    this.levels.push(level);
  }
  toOperationalMetric() {
    const timestamp2 = /* @__PURE__ */ new Date();
    const name = `${this.name}${serializeMetricDimensions(this.dimensions)}`;
    return this.levels.map((level) => ({
      name,
      timestamp: timestamp2,
      metric: { $case: "histogram", histogram: `${Math.ceil(level)}` }
    }));
  }
};

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportBenchmarks.js
var reportableBenchmarks = ["gflops"];
var reportBenchmarks = Injectable("reportBenchmarks", [metricsEventTargetFactory.token, metricsClientFactory.token, configurationToken], (metricsEventTarget, metrics, config2) => __awaiter(void 0, void 0, void 0, function* () {
  if (config2.lensPerformance === void 0)
    return;
  const lensPerformance = yield config2.lensPerformance;
  const baseBenchmark = {
    name: "benchmarkComplete",
    performanceCluster: `${lensPerformance.cluster}`,
    webglRendererInfo: lensPerformance.webglRendererInfo
  };
  const dimensions = { performance_cluster: lensPerformance.cluster.toString() };
  for (const benchmark of lensPerformance.benchmarks) {
    if (!reportableBenchmarks.includes(benchmark.name))
      continue;
    const benchmarkComplete = Object.assign(Object.assign({}, baseBenchmark), { benchmarkName: benchmark.name, benchmarkValue: benchmark.value });
    metricsEventTarget.dispatchEvent(new TypedCustomEvent("benchmarkComplete", benchmarkComplete));
    metrics.setOperationalMetrics(Histogram.level(`benchmark.${benchmark.name}`, benchmark.value, dimensions));
  }
}));

// node_modules/@snap/camera-kit/dist/events/scan.js
var scan2 = (seedState) => (source, eventTypes, accumulator) => {
  let state = seedState;
  const sink = new TypedEventTarget();
  const listener = (event) => {
    state = accumulator(state, event);
    sink.dispatchEvent(new TypedCustomEvent("state", state));
  };
  let hasListener = false;
  sink.addEventListener = new Proxy(sink.addEventListener, {
    apply: (target, thisArg, args) => {
      if (hasListener)
        throw new Error("Cannot add another event listener. The TypedEventTarget returned by scan only supports a single listener, and one has already been added.");
      hasListener = true;
      eventTypes.forEach((eventType) => source.addEventListener(eventType, listener));
      target.apply(thisArg, args);
    }
  });
  sink.removeEventListener = new Proxy(sink.removeEventListener, {
    apply: (target, thisArg, args) => {
      eventTypes.forEach((eventType) => source.removeEventListener(eventType, listener));
      target.apply(thisArg, args);
    }
  });
  return sink;
};

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportHttpMetrics.js
var reportableMetricRequestTypes = [
  "asset",
  "lens_content",
  LENS_CORE_JS_REQUEST_TYPE,
  LENS_CORE_WASM_REQUEST_TYPE,
  COF_REQUEST_TYPE,
  GRPC_CALL_REQUEST_TYPE
];
var getAdditionalDimensions = (dimensions) => {
  switch (dimensions.requestType) {
    case COF_REQUEST_TYPE:
      return [["delta", dimensions.delta]];
    case GRPC_CALL_REQUEST_TYPE:
      return [["method", dimensions.methodName]];
    case LENS_CORE_JS_REQUEST_TYPE:
    case LENS_CORE_WASM_REQUEST_TYPE:
      return [["custom", dimensions.customBuild]];
    default:
      return [];
  }
};
var getContentType = (dimensions) => {
  if (dimensions.requestType === "asset") {
    return dimensions.assetType;
  }
  return dimensions.requestType;
};
var getSizeKb = (event) => {
  switch (event.type) {
    case "started":
    case "errored":
      return 0;
    case "completed":
      return event.detail.sizeByte / 1024;
    default:
      assertUnreachable(event);
  }
};
var getStatus = (event) => {
  switch (event.type) {
    case "started":
    case "errored":
      return "0";
    case "completed":
      return event.detail.status.toString();
    default:
      assertUnreachable(event);
  }
};
var isRelevantRequest = (value) => {
  const reportableMetricDimensions = value;
  return reportableMetricRequestTypes.includes(reportableMetricDimensions.requestType);
};
var reportHttpMetrics = Injectable("reportHttpMetrics", [metricsClientFactory.token, requestStateEventTargetFactory.token], (metrics, requestStateEventTarget) => {
  scan2({ name: "inProgress", inProgress: /* @__PURE__ */ new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
    var _a;
    const { inProgress } = state;
    const { dimensions, requestId: requestId2 } = event.detail;
    if (!isRelevantRequest(dimensions))
      return state;
    switch (event.type) {
      case "started":
        const timer2 = event.detail.timer;
        inProgress.set(requestId2, { timer: timer2 });
        return { name: "inProgress", inProgress };
      case "completed":
      case "errored":
        const completedRequest = inProgress.get(requestId2);
        if (!completedRequest)
          return state;
        inProgress.delete(requestId2);
        const downloadSizeKb = getSizeKb(event);
        const status = getStatus(event);
        const operationalDimensions = {
          content_type: getContentType(dimensions),
          network_type: (_a = getPlatformInfo().connectionType) !== null && _a !== void 0 ? _a : "unknown",
          status
        };
        for (const [key, value] of getAdditionalDimensions(dimensions)) {
          operationalDimensions[key] = value;
        }
        completedRequest.timer.measure(operationalDimensions);
        return {
          name: "completed",
          inProgress: state.inProgress,
          dimensions: operationalDimensions,
          downloadSizeKb,
          timer: completedRequest.timer
        };
      default:
        assertUnreachable(event);
    }
  }).addEventListener("state", ({ detail: state }) => {
    if (state.name !== "completed")
      return;
    const { dimensions, timer: timer2, downloadSizeKb } = state;
    metrics.setOperationalMetrics(Count.count("download_finished", 1, dimensions));
    metrics.setOperationalMetrics(Histogram.level("download_size_kb", downloadSizeKb, dimensions));
    metrics.setOperationalMetrics(timer2);
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLegalState.js
var reportLegalState = Injectable("reportLegalState", [legalStateFactory.token, metricsEventTargetFactory.token, metricsClientFactory.token], (legalState, metricsEventTarget, metrics) => {
  legalState.events.pipe(forActions("accept", "reject"), map(([{ data, name }]) => ({
    name: "legalPrompt",
    legalPromptId: data,
    legalPromptResult: name === "accept" ? CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_ACCEPTED : CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_DISMISSED
  }))).subscribe({
    next: (legalPromptEvent) => {
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("legalPrompt", legalPromptEvent));
      metrics.setOperationalMetrics(Count.count("legal_prompt_interaction", 1, {
        accepted: (legalPromptEvent.legalPromptResult === CameraKitLegalPromptResult.CAMERA_KIT_LEGAL_PROMPT_ACCEPTED).toString()
      }));
    }
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensAndAssetDownload.js
var relevantRequestTypes = ["lens_content", "asset"];
var isLensOrAssetRequest = (value) => {
  const requestType = value["requestType"];
  return typeof requestType === "string" && relevantRequestTypes.includes(requestType);
};
var reportLensAndAssetDownload = Injectable("reportLensAndAssetDownload", [metricsEventTargetFactory.token, metricsClientFactory.token, requestStateEventTargetFactory.token], (metricsEventTarget, metrics, requestStateEventTarget) => {
  scan2({ name: "inProgress", inProgress: /* @__PURE__ */ new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
    var _a;
    const { inProgress } = state;
    const { dimensions, requestId: requestId2 } = event.detail;
    if (!isLensOrAssetRequest(dimensions))
      return state;
    switch (event.type) {
      case "started":
        const timer2 = event.detail.timer;
        inProgress.set(requestId2, { timer: timer2 });
        return { name: "inProgress", inProgress };
      case "completed":
        const completedRequest = inProgress.get(requestId2);
        if (!completedRequest)
          return state;
        inProgress.delete(requestId2);
        const { duration } = (_a = completedRequest.timer.measure()) !== null && _a !== void 0 ? _a : { duration: 0 };
        const downloadTimeSec = duration / 1e3;
        const { sizeByte } = event.detail;
        switch (dimensions.requestType) {
          case "lens_content":
            return {
              name: "completed",
              inProgress,
              event: new TypedCustomEvent("lensDownload", {
                name: "lensDownload",
                lensId: dimensions.lensId,
                automaticDownload: false,
                sizeByte: `${Math.ceil(sizeByte)}`,
                downloadTimeSec
              })
            };
          case "asset":
            return {
              name: "completed",
              inProgress,
              event: new TypedCustomEvent("assetDownload", {
                name: "assetDownload",
                assetId: dimensions.assetId,
                automaticDownload: false,
                sizeByte: `${Math.ceil(sizeByte)}`,
                downloadTimeSec
              })
            };
          default:
            assertUnreachable(dimensions);
        }
      case "errored":
        const erroredRequest = inProgress.get(requestId2);
        if (!erroredRequest)
          return state;
        inProgress.delete(requestId2);
        const error = event.detail.error;
        return {
          name: "completed",
          inProgress,
          event: new TypedCustomEvent("exception", {
            name: "exception",
            lensId: dimensions.lensId,
            type: dimensions.requestType === "lens_content" ? "lens" : "asset",
            reason: stringifyError(error)
          })
        };
      default:
        assertUnreachable(event);
    }
  }).addEventListener("state", ({ detail: state }) => {
    if (state.name !== "completed")
      return;
    metricsEventTarget.dispatchEvent(state.event);
    if (state.event.detail.name === "exception") {
      metrics.setOperationalMetrics(Count.count("handled_exception", 1, { type: state.event.detail.type }));
    }
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensValidationFailed.js
var reportLensValidationFailed = Injectable("reportLensValidationFailed", [lensStateFactory.token, metricsEventTargetFactory.token], (lensState, metricsEventTarget) => {
  lensState.events.pipe(forActions("applyLensFailed"), filter(([a2]) => a2.data.error.name === "LensContentValidationError")).subscribe({
    next: ([{ data }]) => {
      const { lens } = data;
      const lensContentValidationFailed = {
        name: "lensContentValidationFailed",
        lensId: lens.id
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensContentValidationFailed", lensContentValidationFailed));
    }
  });
});

// node_modules/@snap/camera-kit/dist/common/date.js
var DEFAULT_TIMEZONE = "America/Los_Angeles";
var dayFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: DEFAULT_TIMEZONE,
  year: "numeric",
  month: "numeric",
  day: "numeric"
});
var monthFormatter = new Intl.DateTimeFormat("en-US", {
  timeZone: DEFAULT_TIMEZONE,
  year: "numeric",
  month: "numeric"
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensView.js
var viewTimeThresholdSec = 0.1;
function isFirstTimeWithinPeriods(lensId, persistence) {
  return __awaiter(this, void 0, void 0, function* () {
    let isLensFirstWithinDay = false;
    let isLensFirstWithinMonth = false;
    try {
      const lensLastViewDate = yield persistence.retrieve(lensId);
      const currentDate = /* @__PURE__ */ new Date();
      if (!lensLastViewDate) {
        isLensFirstWithinDay = true;
        isLensFirstWithinMonth = true;
      } else {
        isLensFirstWithinDay = dayFormatter.format(lensLastViewDate) !== dayFormatter.format(currentDate);
        isLensFirstWithinMonth = monthFormatter.format(lensLastViewDate) !== monthFormatter.format(currentDate);
      }
      yield persistence.store(lensId, currentDate);
    } catch (error) {
      console.error(`Error handling persistence for lensId ${lensId}: ${error}`);
      isLensFirstWithinDay = false;
      isLensFirstWithinMonth = false;
    }
    return { isLensFirstWithinDay, isLensFirstWithinMonth };
  });
}
var reportLensView = Injectable("reportLensView", [
  cameraKitSessionFactory.token,
  lensStateFactory.token,
  sessionStateFactory.token,
  metricsEventTargetFactory.token,
  metricsClientFactory.token,
  configurationToken
], (session, lensState, sessionState, metricsEventTarget, metrics, configuration) => __awaiter(void 0, void 0, void 0, function* () {
  var _a;
  const { cluster: performanceCluster, webglRendererInfo } = (_a = yield configuration.lensPerformance) !== null && _a !== void 0 ? _a : {
    cluster: 0,
    webglRendererInfo: "unknown"
  };
  const lensViewPersistence = new ExpiringPersistence(() => 60 * 24 * 60 * 60, new IndexedDBPersistence({ databaseName: "recentLensViews" }));
  merge(lensState.events.pipe(forActions("downloadComplete"), map(([a2]) => a2.data)), lensState.events.pipe(inStates("lensApplied"), switchMap(([, s2]) => sessionState.events.pipe(forActions("resume"), takeUntil(lensState.events.pipe(forActions("removeLens"))), map(() => s2.data))))).pipe(map((lens) => [getTimeMs(), lens.id, lens.groupId]), mergeMap(([applyLensStartTime, lensId, lensGroupId]) => {
    const alreadyOn = isState(lensState.getState(), "lensApplied");
    const applyDelay = alreadyOn ? of(0) : lensState.events.pipe(forActions("resourcesLoaded"), filter(([a2]) => a2.data.id === lensId), take(1), map(() => (getTimeMs() - applyLensStartTime) / 1e3));
    const viewMetrics = (alreadyOn ? of([getTimeMs(), session.metrics.beginMeasurement()]) : lensState.events.pipe(forActions("turnedOn"), filter(([a2]) => a2.data.id === lensId), map(() => [getTimeMs(), session.metrics.beginMeasurement()]))).pipe(take(1), mergeMap(([lensTurnedOnTime, metricsMeasurement]) => lensState.events.pipe(forActions("turnedOff"), filter(([a2]) => a2.data.id === lensId), raceWith(sessionState.events.pipe(forActions("suspend"))), map(() => {
      metricsMeasurement.end();
      return Object.assign({ viewTimeSec: (getTimeMs() - lensTurnedOnTime) / 1e3 }, metricsMeasurement.measure());
    }))));
    return applyDelay.pipe(combineLatestWith(viewMetrics, from(isFirstTimeWithinPeriods(lensId, lensViewPersistence))), takeUntil(lensState.events.pipe(forActions("turnedOn"), filter(([a2]) => a2.data.id !== lensId))), take(1), map(([applyDelaySec, viewMetrics2, isFirstTimeResults]) => Object.assign(Object.assign({
      applyDelaySec,
      lensId,
      lensGroupId
    }, viewMetrics2), isFirstTimeResults)));
  })).subscribe({
    next: ({ applyDelaySec, lensId, lensGroupId, viewTimeSec, avgFps, lensFrameProcessingTimeMsAvg, lensFrameProcessingTimeMsStd, lensFrameProcessingTimeMsMedian, lensFrameProcessingN, isLensFirstWithinDay, isLensFirstWithinMonth }) => __awaiter(void 0, void 0, void 0, function* () {
      if (viewTimeSec < viewTimeThresholdSec)
        return;
      const lensView = {
        name: "lensView",
        applyDelaySec,
        avgFps,
        lensId,
        lensGroupId,
        lensFrameProcessingTimeMsAvg,
        lensFrameProcessingTimeMsStd,
        recordingTimeSec: 0,
        viewTimeSec,
        isLensFirstWithinDay,
        isLensFirstWithinMonth,
        performanceCluster: `${performanceCluster}`,
        webglRendererInfo
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensView", lensView));
      metrics.setOperationalMetrics(Histogram.level("lens_view", viewTimeSec * 1e3));
      if (lensFrameProcessingN >= 30) {
        metrics.setOperationalMetrics(Histogram.level("lens_view_frame-processing-time", lensFrameProcessingTimeMsMedian, {
          performance_cluster: performanceCluster.toString()
        }));
      }
    })
  });
}));

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportLensWait.js
var viewTimeThresholdSec2 = 0.1;
var reportLensWait = Injectable("reportLensWait", [lensStateFactory.token, metricsEventTargetFactory.token], (lensState, metricsEventTarget) => {
  lensState.events.pipe(forActions("applyLens"), mergeMap(([a2]) => {
    const lensId = a2.data.lens.id;
    const lensGroupId = a2.data.lens.groupId;
    const applyLensStartTime = getTimeMs();
    return lensState.events.pipe(forActions("firstFrameProcessed", "applyLens"), take(1), map(() => [
      (getTimeMs() - applyLensStartTime) / 1e3,
      lensId,
      lensGroupId
    ]));
  })).subscribe({
    next: ([viewTimeSec, lensId, lensGroupId]) => {
      if (viewTimeSec < viewTimeThresholdSec2)
        return;
      const lensWait = {
        name: "lensWait",
        lensId,
        viewTimeSec,
        lensGroupId
      };
      metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensWait", lensWait));
    }
  });
});

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportUserSession.js
var reportUserSession = Injectable("reportUserSession", [metricsEventTargetFactory.token], (metricsEventTarget) => __awaiter(void 0, void 0, void 0, function* () {
  var _a, _b;
  const userSessionKey = "userSessionInfo";
  const db = new IndexedDBPersistence({ databaseName: "SessionHistory" });
  const date = /* @__PURE__ */ new Date();
  const formattedDate = dayFormatter.format(date);
  const formattedDateParts = dayFormatter.formatToParts(date);
  const { day, month, year } = formattedDateParts.reduce((acc, { type, value }) => Object.assign(Object.assign({}, acc), { [type]: parseInt(value) }), {});
  const userSessionInfo = yield db.retrieve(userSessionKey);
  const mostRecentSessionStartDate = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.mostRecentSessionStartDate;
  const formattedMostRecentSessionStartDate = mostRecentSessionStartDate ? dayFormatter.format(mostRecentSessionStartDate) : null;
  const dailySessionBucketMap = /* @__PURE__ */ new Map([
    [1, DailySessionBucket.ONE_SESSION],
    [2, DailySessionBucket.TWO_SESSION],
    [3, DailySessionBucket.THREE_SESSION],
    [4, DailySessionBucket.FOUR_SESSION],
    [5, DailySessionBucket.FIVE_SESSION],
    [6, DailySessionBucket.SIX_SESSION],
    [7, DailySessionBucket.SEVEN_SESSION],
    [8, DailySessionBucket.EIGHT_SESSION],
    [9, DailySessionBucket.NINE_SESSION]
  ]);
  let dailySessionBucket = (_a = userSessionInfo === null || userSessionInfo === void 0 ? void 0 : userSessionInfo.dailySessionBucket) !== null && _a !== void 0 ? _a : DailySessionBucket.NO_SESSION_BUCKET;
  let isFirstWithinMonth = false;
  if (formattedMostRecentSessionStartDate === formattedDate) {
    dailySessionBucket = (_b = dailySessionBucketMap.get(dailySessionBucket + 1)) !== null && _b !== void 0 ? _b : DailySessionBucket.TEN_OR_MORE_SESSION;
    yield db.store(userSessionKey, {
      mostRecentSessionStartDate: date,
      dailySessionBucket
    });
  } else {
    isFirstWithinMonth = !mostRecentSessionStartDate || monthFormatter.format(mostRecentSessionStartDate) !== monthFormatter.format(date);
    yield db.store(userSessionKey, {
      mostRecentSessionStartDate: date,
      dailySessionBucket: dailySessionBucket = DailySessionBucket.ONE_SESSION
    });
  }
  const session = {
    name: "session",
    dailySessionBucket,
    isFirstWithinMonth,
    month: `${month}`,
    day: `${day}`,
    year: `${year}`
  };
  metricsEventTarget.dispatchEvent(new TypedCustomEvent("session", session));
}));

// node_modules/@snap/camera-kit/dist/metrics/reporters/reportPlatformCapabilities.js
var reportPlatformCapabilities = Injectable("reportPlatformCapabilities", [metricsClientFactory.token], (metrics) => __awaiter(void 0, void 0, void 0, function* () {
  const { webgl, wasm, webxr } = yield getPlatformCapabilities();
  metrics.setOperationalMetrics(Count.count(joinMetricNames(["platform", "webgl"]), webgl.supported ? 1 : 0));
  metrics.setOperationalMetrics(Count.count(joinMetricNames(["platform", "wasm"]), wasm.supported ? 1 : 0));
  metrics.setOperationalMetrics(Count.count(joinMetricNames(["platform", "webxr"]), webxr.supported ? 1 : 0));
}));

// node_modules/@snap/camera-kit/dist/metrics/reporters/reporters.js
var reportGloballyScopedMetrics = new PartialContainer({}).provides(reportHttpMetrics).provides(reportBenchmarks).provides(reportLensAndAssetDownload).provides(reportLegalState).provides(reportPlatformCapabilities);
var reportSessionScopedMetrics = new PartialContainer({}).provides(reportUserSession).provides(reportLensView).provides(reportLensWait).provides(reportSessionException).provides(reportLensValidationFailed);

// node_modules/browser-fs-access/dist/index.modern.js
var e = (() => {
  if ("undefined" == typeof self) return false;
  if ("top" in self && self !== top) try {
    top.window.document._ = 0;
  } catch (e2) {
    return false;
  }
  return "showOpenFilePicker" in self;
})();
var t = e ? Promise.resolve().then(function() {
  return l;
}) : Promise.resolve().then(function() {
  return v;
});
async function n(...e2) {
  return (await t).default(...e2);
}
var r = e ? Promise.resolve().then(function() {
  return y;
}) : Promise.resolve().then(function() {
  return b;
});
var a = e ? Promise.resolve().then(function() {
  return m;
}) : Promise.resolve().then(function() {
  return k;
});
var s = async (e2) => {
  const t2 = await e2.getFile();
  return t2.handle = e2, t2;
};
var c = async (e2 = [{}]) => {
  Array.isArray(e2) || (e2 = [e2]);
  const t2 = [];
  e2.forEach((e3, n3) => {
    t2[n3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? e3.mimeTypes.map((r3) => {
      t2[n3].accept[r3] = e3.extensions || [];
    }) : t2[n3].accept["*/*"] = e3.extensions || [];
  });
  const n2 = await window.showOpenFilePicker({ id: e2[0].id, startIn: e2[0].startIn, types: t2, multiple: e2[0].multiple || false, excludeAcceptAllOption: e2[0].excludeAcceptAllOption || false }), r2 = await Promise.all(n2.map(s));
  return e2[0].multiple ? r2 : r2[0];
};
var l = { __proto__: null, default: c };
function u(e2) {
  function t2(e3) {
    if (Object(e3) !== e3) return Promise.reject(new TypeError(e3 + " is not an object."));
    var t3 = e3.done;
    return Promise.resolve(e3.value).then(function(e4) {
      return { value: e4, done: t3 };
    });
  }
  return u = function(e3) {
    this.s = e3, this.n = e3.next;
  }, u.prototype = { s: null, n: null, next: function() {
    return t2(this.n.apply(this.s, arguments));
  }, return: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.resolve({ value: e3, done: true }) : t2(n2.apply(this.s, arguments));
  }, throw: function(e3) {
    var n2 = this.s.return;
    return void 0 === n2 ? Promise.reject(e3) : t2(n2.apply(this.s, arguments));
  } }, new u(e2);
}
var p = async (e2, t2, n2 = e2.name, r2) => {
  const i = [], a2 = [];
  var o, s2 = false, c2 = false;
  try {
    for (var l2, d2 = function(e3) {
      var t3, n3, r3, i2 = 2;
      for ("undefined" != typeof Symbol && (n3 = Symbol.asyncIterator, r3 = Symbol.iterator); i2--; ) {
        if (n3 && null != (t3 = e3[n3])) return t3.call(e3);
        if (r3 && null != (t3 = e3[r3])) return new u(t3.call(e3));
        n3 = "@@asyncIterator", r3 = "@@iterator";
      }
      throw new TypeError("Object is not async iterable");
    }(e2.values()); s2 = !(l2 = await d2.next()).done; s2 = false) {
      const o2 = l2.value, s3 = `${n2}/${o2.name}`;
      "file" === o2.kind ? a2.push(o2.getFile().then((t3) => (t3.directoryHandle = e2, t3.handle = o2, Object.defineProperty(t3, "webkitRelativePath", { configurable: true, enumerable: true, get: () => s3 })))) : "directory" !== o2.kind || !t2 || r2 && r2(o2) || i.push(p(o2, t2, s3, r2));
    }
  } catch (e3) {
    c2 = true, o = e3;
  } finally {
    try {
      s2 && null != d2.return && await d2.return();
    } finally {
      if (c2) throw o;
    }
  }
  return [...(await Promise.all(i)).flat(), ...await Promise.all(a2)];
};
var d = async (e2 = {}) => {
  e2.recursive = e2.recursive || false, e2.mode = e2.mode || "read";
  const t2 = await window.showDirectoryPicker({ id: e2.id, startIn: e2.startIn, mode: e2.mode });
  return (await (await t2.values()).next()).done ? [t2] : p(t2, e2.recursive, void 0, e2.skipDirectory);
};
var y = { __proto__: null, default: d };
var f = async (e2, t2 = [{}], n2 = null, r2 = false, i = null) => {
  Array.isArray(t2) || (t2 = [t2]), t2[0].fileName = t2[0].fileName || "Untitled";
  const a2 = [];
  let o = null;
  if (e2 instanceof Blob && e2.type ? o = e2.type : e2.headers && e2.headers.get("content-type") && (o = e2.headers.get("content-type")), t2.forEach((e3, t3) => {
    a2[t3] = { description: e3.description || "Files", accept: {} }, e3.mimeTypes ? (0 === t3 && o && e3.mimeTypes.push(o), e3.mimeTypes.map((n3) => {
      a2[t3].accept[n3] = e3.extensions || [];
    })) : o ? a2[t3].accept[o] = e3.extensions || [] : a2[t3].accept["*/*"] = e3.extensions || [];
  }), n2) try {
    await n2.getFile();
  } catch (e3) {
    if (n2 = null, r2) throw e3;
  }
  const s2 = n2 || await window.showSaveFilePicker({ suggestedName: t2[0].fileName, id: t2[0].id, startIn: t2[0].startIn, types: a2, excludeAcceptAllOption: t2[0].excludeAcceptAllOption || false });
  !n2 && i && i(s2);
  const c2 = await s2.createWritable();
  if ("stream" in e2) {
    const t3 = e2.stream();
    return await t3.pipeTo(c2), s2;
  }
  return "body" in e2 ? (await e2.body.pipeTo(c2), s2) : (await c2.write(await e2), await c2.close(), s2);
};
var m = { __proto__: null, default: f };
var w = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file";
  const i = [...e2.map((e3) => e3.mimeTypes || []), ...e2.map((e3) => e3.extensions || [])].join();
  r2.multiple = e2[0].multiple || false, r2.accept = i || "", r2.style.display = "none", document.body.append(r2);
  const a2 = (e3) => {
    "function" == typeof o && o(), t2(e3);
  }, o = e2[0].legacySetup && e2[0].legacySetup(a2, () => o(n2), r2), s2 = () => {
    window.removeEventListener("focus", s2), r2.remove();
  };
  r2.addEventListener("click", () => {
    window.addEventListener("focus", s2);
  }), r2.addEventListener("change", () => {
    window.removeEventListener("focus", s2), r2.remove(), a2(r2.multiple ? Array.from(r2.files) : r2.files[0]);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
}));
var v = { __proto__: null, default: w };
var h = async (e2 = [{}]) => (Array.isArray(e2) || (e2 = [e2]), e2[0].recursive = e2[0].recursive || false, new Promise((t2, n2) => {
  const r2 = document.createElement("input");
  r2.type = "file", r2.webkitdirectory = true;
  const i = (e3) => {
    "function" == typeof a2 && a2(), t2(e3);
  }, a2 = e2[0].legacySetup && e2[0].legacySetup(i, () => a2(n2), r2);
  r2.addEventListener("change", () => {
    let t3 = Array.from(r2.files);
    e2[0].recursive ? e2[0].recursive && e2[0].skipDirectory && (t3 = t3.filter((t4) => t4.webkitRelativePath.split("/").every((t5) => !e2[0].skipDirectory({ name: t5, kind: "directory" })))) : t3 = t3.filter((e3) => 2 === e3.webkitRelativePath.split("/").length), i(t3);
  }), "showPicker" in HTMLInputElement.prototype ? r2.showPicker() : r2.click();
}));
var b = { __proto__: null, default: h };
var P = async (e2, t2 = {}) => {
  Array.isArray(t2) && (t2 = t2[0]);
  const n2 = document.createElement("a");
  let r2 = e2;
  "body" in e2 && (r2 = await async function(e3, t3) {
    const n3 = e3.getReader(), r3 = new ReadableStream({ start: (e4) => async function t4() {
      return n3.read().then(({ done: n4, value: r4 }) => {
        if (!n4) return e4.enqueue(r4), t4();
        e4.close();
      });
    }() }), i2 = new Response(r3), a3 = await i2.blob();
    return n3.releaseLock(), new Blob([a3], { type: t3 });
  }(e2.body, e2.headers.get("content-type"))), n2.download = t2.fileName || "Untitled", n2.href = URL.createObjectURL(await r2);
  const i = () => {
    "function" == typeof a2 && a2();
  }, a2 = t2.legacySetup && t2.legacySetup(i, () => a2(), n2);
  return n2.addEventListener("click", () => {
    setTimeout(() => URL.revokeObjectURL(n2.href), 3e4), i();
  }), n2.click(), null;
};
var k = { __proto__: null, default: P };

// node_modules/@snap/camera-kit/dist/lens-client-interface/exif.js
var JPEG_ID = 65496;
var APP1_MARKER = 65505;
var EXIF_ID = 1165519206;
var LITTLE_ENDIAN = 18761;
var ORIENTATION_TAG_OFFSET = 274;
var Orientation;
(function(Orientation2) {
  Orientation2[Orientation2["TopLeft"] = 1] = "TopLeft";
  Orientation2[Orientation2["TopRight"] = 2] = "TopRight";
  Orientation2[Orientation2["BottomRight"] = 3] = "BottomRight";
  Orientation2[Orientation2["BottomLeft"] = 4] = "BottomLeft";
  Orientation2[Orientation2["LeftTop"] = 5] = "LeftTop";
  Orientation2[Orientation2["RightTop"] = 6] = "RightTop";
  Orientation2[Orientation2["RightBottom"] = 7] = "RightBottom";
  Orientation2[Orientation2["LeftBottom"] = 8] = "LeftBottom";
})(Orientation || (Orientation = {}));
function extractJpegOrientationTag(data) {
  const view = new DataView(data);
  if (view.getUint16(0, false) !== JPEG_ID)
    return void 0;
  const length = view.byteLength;
  let offset = 2;
  while (offset < length) {
    if (view.getUint16(offset + 2, false) <= 8)
      return void 0;
    let marker = view.getUint16(offset, false);
    offset += 2;
    if (marker === APP1_MARKER) {
      if (view.getUint32(offset += 2, false) !== EXIF_ID) {
        return void 0;
      }
      let little = view.getUint16(offset += 6, false) === LITTLE_ENDIAN;
      offset += view.getUint32(offset + 4, little);
      let tags = view.getUint16(offset, little);
      offset += 2;
      for (let i = 0; i < tags; i++) {
        if (view.getUint16(offset + i * 12, little) === ORIENTATION_TAG_OFFSET) {
          return view.getUint16(offset + i * 12 + 8, little);
        }
      }
    } else if ((marker & 65280) !== 65280) {
      break;
    } else {
      offset += view.getUint16(offset, false);
    }
  }
  return void 0;
}

// node_modules/@snap/camera-kit/dist/lens-client-interface/imagePicker.js
var logger20 = getLogger("lensClientInterfaceImagePicker");
var mimeTypes = {
  image: [
    "image/avif",
    "image/bmp",
    "image/gif",
    "image/jpeg",
    "image/png",
    "image/svg+xml",
    "image/tiff",
    "image/webp"
  ],
  video: [
    "video/3gpp",
    "video/3gpp2",
    "video/mp2t",
    "video/mp4",
    "video/mpeg",
    "video/ogg",
    "video/quicktime",
    "video/webm",
    "video/x-msvideo"
  ]
};
function* enumerateSupportedVideoTypes(types) {
  const testVideoElement = typeof document !== "undefined" ? document.createElement("video") : void 0;
  for (const type of types) {
    if ((testVideoElement === null || testVideoElement === void 0 ? void 0 : testVideoElement.canPlayType(type)) || false) {
      yield type;
    }
  }
}
function readFileAsArrayBuffer(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.addEventListener("load", (event) => {
      resolve(event.target.result);
    });
    reader.addEventListener("error", (event) => {
      reject(event.target.error);
    });
    reader.readAsArrayBuffer(file);
  });
}
function getMimeType({ ImageEnabled, VideoEnabled }) {
  const types = [];
  if (ImageEnabled === "1")
    types.push(...mimeTypes.image);
  if (VideoEnabled === "1")
    types.push(...enumerateSupportedVideoTypes(mimeTypes.video));
  if (types.length === 0) {
    throw new Error("Unknown media type requested.");
  }
  return types;
}
function getOrientation(data, lensCore) {
  var _a;
  const orientationMap = {
    [1]: lensCore.ExternalMediaOrientation.CW0,
    [2]: lensCore.ExternalMediaOrientation.CW0,
    [3]: lensCore.ExternalMediaOrientation.CW180,
    [4]: lensCore.ExternalMediaOrientation.CW180,
    [5]: lensCore.ExternalMediaOrientation.CW90,
    [6]: lensCore.ExternalMediaOrientation.CW90,
    [7]: lensCore.ExternalMediaOrientation.CW270,
    [8]: lensCore.ExternalMediaOrientation.CW270
  };
  try {
    return orientationMap[(_a = extractJpegOrientationTag(data)) !== null && _a !== void 0 ? _a : 1];
  } catch (error) {
    logger20.info("Error occurred while reading EXIF orientation tag.", error);
    return lensCore.ExternalMediaOrientation.CW0;
  }
}
function pickClientImage(clientInterfaceData, lensCore, filePicker) {
  return __awaiter(this, void 0, void 0, function* () {
    const mimeTypes2 = getMimeType(clientInterfaceData);
    logger20.debug(`Opening file dialog for MIME types: ${mimeTypes2}`);
    const file = yield filePicker({ mimeTypes: mimeTypes2 }, n);
    if (Array.isArray(file)) {
      throw new Error("Multiple files are not supported.");
    }
    logger20.debug(`Selected file MIME type: ${file.type}`);
    const data = yield readFileAsArrayBuffer(file);
    if (file.type.startsWith("image/")) {
      lensCore.provideExternalImage({
        data,
        orientation: getOrientation(data, lensCore),
        faceRects: [
          {
            origin: {
              x: 0,
              y: 0
            },
            size: {
              width: 1,
              height: 1
            }
          }
        ]
      });
    } else {
      lensCore.provideExternalVideo({
        data,
        orientation: lensCore.ExternalMediaOrientation.CW0
      });
    }
  });
}

// node_modules/@snap/camera-kit/dist/lens-client-interface/filePicker.js
var filePickerFactory = Injectable("filePicker", () => (options, openDefaultPicker) => openDefaultPicker(options));

// node_modules/@snap/camera-kit/dist/lens-client-interface/lensClientInterface.js
var logger21 = getLogger("lensClientInterface");
var registerLensClientInterfaceHandler = Injectable("registerLensClientInterfaceHandler", [lensCoreFactory.token, filePickerFactory.token], (lensCore, filePicker) => {
  if (!lensCore.setClientInterfaceRequestHandler) {
    logger21.warn("Current LensCore version doesn't support lens client interface requests");
    return;
  }
  lensCore.setClientInterfaceRequestHandler(({ data, interfaceControl, interfaceAction }) => __awaiter(void 0, void 0, void 0, function* () {
    if (interfaceControl === lensCore.InterfaceControl.ImagePicker && interfaceAction === lensCore.InterfaceAction.Show) {
      yield pickClientImage(data, lensCore, filePicker).catch((error) => {
        logger21.error(lensImagePickerError("Error occurred while attempting to select an image file for the lens request.", error));
      });
    }
  }));
});

// node_modules/@snap/camera-kit/dist/remote-configuration/preloadConfiguration.js
var logger22 = getLogger("setPreloadedConfiguration");
var setPreloadedConfiguration = Injectable("setPreloadedConfiguration", [lensCoreFactory.token, remoteConfigurationFactory.token], (lensCore, remoteConfiguration) => {
  remoteConfiguration.getNamespace(Namespace.LENS_CORE_CONFIG).pipe(take(1)).subscribe({
    next: (configs) => {
      const inputs = configs.map(({ configId, value }) => ({ configId, value }));
      lensCore.setPreloadedConfiguration(inputs);
    },
    error: logger22.error
  });
});

// node_modules/@snap/camera-kit/dist/geo/geoDataProvider.js
function isGeoData(value) {
  return isRecord(value) && isWeatherData(value.weather);
}
function isWeatherData(value) {
  return isRecord(value) && isString(value.locationName) && isNumber(value.celsius) && isNumber(value.fahrenheit) && !isUndefined(value.hourlyForecasts) && isArrayOfType(isHourlyWeatherForecast, value.hourlyForecasts);
}
function isHourlyWeatherForecast(value) {
  return isRecord(value) && isNumber(value.celsius) && isNumber(value.fahrenheit) && isString(value.displayTime) && isString(value.weatherCondition) && isString(value.localizedWeatherCondition);
}
var geoDataProviderFactory = Injectable("geoDataProvider", () => {
  return () => void 0;
});

// node_modules/@snap/camera-kit/dist/geo/registerGeoDataProvider.js
var logger23 = getLogger("registerGeoDataProvider");
var registerGeoDataProvider = Injectable("registerGeoDataProvider", [lensCoreFactory.token, geoDataProviderFactory.token], (lensCore, getGeoData) => {
  if (!lensCore.setGeoDataProvider) {
    logger23.warn("setGeoDataProvider is not defined.");
    return;
  }
  lensCore.setGeoDataProvider(() => {
    const geoData = getGeoData();
    if (geoData) {
      if (!isGeoData(geoData)) {
        throw new Error("Expected GeoData object.");
      }
      lensCore.provideGeoData({ geoData });
    }
  });
});

// node_modules/@snap/camera-kit/dist/CameraKit.js
var logger24 = getLogger("CameraKit");
var publicMetricsEventNames = ["lensView", "lensWait"];
var CameraKit = (() => {
  var _a;
  let _instanceExtraInitializers = [];
  let _createSession_decorators;
  let _destroy_decorators;
  return _a = class CameraKit {
    constructor(lensRepository, lensCore, pageVisibility, container, remoteConfig, allMetrics) {
      this.lensRepository = (__runInitializers(this, _instanceExtraInitializers), lensRepository);
      this.lensCore = lensCore;
      this.pageVisibility = pageVisibility;
      this.container = container;
      this.remoteConfig = remoteConfig;
      this.metrics = new TypedEventTarget();
      this.sessions = [];
      this.lenses = { repository: this.lensRepository };
      publicMetricsEventNames.forEach((eventName) => {
        allMetrics.addEventListener(eventName, (e2) => this.metrics.dispatchEvent(e2));
      });
    }
    createSession({ liveRenderTarget, renderWhileTabHidden } = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const exceptionHandler = (error) => {
          if (error.name === "LensCoreAbortError") {
            logger24.error(lensAbortError("Unrecoverable error occurred during lens execution. The CameraKitSession will be destroyed.", error));
          } else {
            logger24.error(lensExecutionError("Error occurred during lens execution. The lens cannot be rendered and will be removed from the CameraKitSession.", error));
          }
        };
        const config2 = this.container.get(configurationToken);
        yield this.lensCore.initialize({
          canvas: liveRenderTarget,
          shouldUseWorker: !renderWhileTabHidden && config2.shouldUseWorker,
          exceptionHandler
        });
        if (this.lensCore.setGpuIndex) {
          try {
            yield this.lensCore.setGpuIndex({
              gpuIndex: yield firstValueFrom(this.remoteConfig.getGpuIndexConfig())
            });
          } catch (cause) {
            logger24.error(new Error("Cannot set GPU index.", { cause }));
          }
        }
        if (config2.fonts.length > 0) {
          this.lensCore.setSystemFonts({
            fonts: config2.fonts
          });
        }
        yield this.lensCore.setRenderLoopMode({
          mode: renderWhileTabHidden ? this.lensCore.RenderLoopMode.SetTimeout : this.lensCore.RenderLoopMode.RequestAnimationFrame
        });
        const sessionContainer = this.container.copy().provides(sessionStateFactory).provides(lensStateFactory).provides(lensKeyboardFactory).provides(cameraKitSessionFactory).run(registerLensAssetsProvider).run(registerLensClientInterfaceHandler).run(registerGeoDataProvider).run(setPreloadedConfiguration).run(reportSessionScopedMetrics).run(registerUriHandlers);
        const session = sessionContainer.get(cameraKitSessionFactory.token);
        this.sessions.push(session);
        return session;
      });
    }
    destroy() {
      return __awaiter(this, void 0, void 0, function* () {
        resetLogger();
        this.pageVisibility.destroy();
        yield Promise.all(this.sessions.map((session) => session.destroy()));
        this.sessions = [];
      });
    }
  }, (() => {
    _createSession_decorators = [errorLoggingDecorator(logger24)];
    _destroy_decorators = [errorLoggingDecorator(logger24)];
    __esDecorate(_a, null, _createSession_decorators, { kind: "method", name: "createSession", static: false, private: false, access: { has: (obj) => "createSession" in obj, get: (obj) => obj.createSession } }, null, _instanceExtraInitializers);
    __esDecorate(_a, null, _destroy_decorators, { kind: "method", name: "destroy", static: false, private: false, access: { has: (obj) => "destroy" in obj, get: (obj) => obj.destroy } }, null, _instanceExtraInitializers);
  })(), _a;
})();
var cameraKitFactory = Injectable("CameraKit", [
  lensRepositoryFactory.token,
  metricsEventTargetFactory.token,
  lensCoreFactory.token,
  pageVisibilityFactory.token,
  remoteConfigurationFactory.token,
  CONTAINER
], (lensRepository, metrics, lensCore, pageVisibility, remoteConfiguration, container) => new CameraKit(lensRepository, lensCore, pageVisibility, container, remoteConfiguration, metrics));

// node_modules/@snap/camera-kit/dist/platform/assertPlatformSupported.js
function assertPlatformSupported() {
  return __awaiter(this, void 0, void 0, function* () {
    const { wasm, webgl } = yield getPlatformCapabilities();
    if (!wasm.supported)
      throw wasm.error;
    if (!webgl.supported)
      throw webgl.error;
  });
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate2(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate2;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v2;
  var arr = new Uint8Array(16);
  arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v2 >>> 16 & 255;
  arr[2] = v2 >>> 8 & 255;
  arr[3] = v2 & 255;
  arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v2 & 255;
  arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v2 & 255;
  arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v2 & 255;
  arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v2 / 4294967296 & 255;
  arr[12] = v2 >>> 24 & 255;
  arr[13] = v2 >>> 16 & 255;
  arr[14] = v2 >>> 8 & 255;
  arr[15] = v2 & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a2 = 1732584193;
  var b2 = -271733879;
  var c2 = -1732584194;
  var d2 = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a2;
    var oldb = b2;
    var oldc = c2;
    var oldd = d2;
    a2 = md5ff(a2, b2, c2, d2, x[i], 7, -680876936);
    d2 = md5ff(d2, a2, b2, c2, x[i + 1], 12, -389564586);
    c2 = md5ff(c2, d2, a2, b2, x[i + 2], 17, 606105819);
    b2 = md5ff(b2, c2, d2, a2, x[i + 3], 22, -1044525330);
    a2 = md5ff(a2, b2, c2, d2, x[i + 4], 7, -176418897);
    d2 = md5ff(d2, a2, b2, c2, x[i + 5], 12, 1200080426);
    c2 = md5ff(c2, d2, a2, b2, x[i + 6], 17, -1473231341);
    b2 = md5ff(b2, c2, d2, a2, x[i + 7], 22, -45705983);
    a2 = md5ff(a2, b2, c2, d2, x[i + 8], 7, 1770035416);
    d2 = md5ff(d2, a2, b2, c2, x[i + 9], 12, -1958414417);
    c2 = md5ff(c2, d2, a2, b2, x[i + 10], 17, -42063);
    b2 = md5ff(b2, c2, d2, a2, x[i + 11], 22, -1990404162);
    a2 = md5ff(a2, b2, c2, d2, x[i + 12], 7, 1804603682);
    d2 = md5ff(d2, a2, b2, c2, x[i + 13], 12, -40341101);
    c2 = md5ff(c2, d2, a2, b2, x[i + 14], 17, -1502002290);
    b2 = md5ff(b2, c2, d2, a2, x[i + 15], 22, 1236535329);
    a2 = md5gg(a2, b2, c2, d2, x[i + 1], 5, -165796510);
    d2 = md5gg(d2, a2, b2, c2, x[i + 6], 9, -1069501632);
    c2 = md5gg(c2, d2, a2, b2, x[i + 11], 14, 643717713);
    b2 = md5gg(b2, c2, d2, a2, x[i], 20, -373897302);
    a2 = md5gg(a2, b2, c2, d2, x[i + 5], 5, -701558691);
    d2 = md5gg(d2, a2, b2, c2, x[i + 10], 9, 38016083);
    c2 = md5gg(c2, d2, a2, b2, x[i + 15], 14, -660478335);
    b2 = md5gg(b2, c2, d2, a2, x[i + 4], 20, -405537848);
    a2 = md5gg(a2, b2, c2, d2, x[i + 9], 5, 568446438);
    d2 = md5gg(d2, a2, b2, c2, x[i + 14], 9, -1019803690);
    c2 = md5gg(c2, d2, a2, b2, x[i + 3], 14, -187363961);
    b2 = md5gg(b2, c2, d2, a2, x[i + 8], 20, 1163531501);
    a2 = md5gg(a2, b2, c2, d2, x[i + 13], 5, -1444681467);
    d2 = md5gg(d2, a2, b2, c2, x[i + 2], 9, -51403784);
    c2 = md5gg(c2, d2, a2, b2, x[i + 7], 14, 1735328473);
    b2 = md5gg(b2, c2, d2, a2, x[i + 12], 20, -1926607734);
    a2 = md5hh(a2, b2, c2, d2, x[i + 5], 4, -378558);
    d2 = md5hh(d2, a2, b2, c2, x[i + 8], 11, -2022574463);
    c2 = md5hh(c2, d2, a2, b2, x[i + 11], 16, 1839030562);
    b2 = md5hh(b2, c2, d2, a2, x[i + 14], 23, -35309556);
    a2 = md5hh(a2, b2, c2, d2, x[i + 1], 4, -1530992060);
    d2 = md5hh(d2, a2, b2, c2, x[i + 4], 11, 1272893353);
    c2 = md5hh(c2, d2, a2, b2, x[i + 7], 16, -155497632);
    b2 = md5hh(b2, c2, d2, a2, x[i + 10], 23, -1094730640);
    a2 = md5hh(a2, b2, c2, d2, x[i + 13], 4, 681279174);
    d2 = md5hh(d2, a2, b2, c2, x[i], 11, -358537222);
    c2 = md5hh(c2, d2, a2, b2, x[i + 3], 16, -722521979);
    b2 = md5hh(b2, c2, d2, a2, x[i + 6], 23, 76029189);
    a2 = md5hh(a2, b2, c2, d2, x[i + 9], 4, -640364487);
    d2 = md5hh(d2, a2, b2, c2, x[i + 12], 11, -421815835);
    c2 = md5hh(c2, d2, a2, b2, x[i + 15], 16, 530742520);
    b2 = md5hh(b2, c2, d2, a2, x[i + 2], 23, -995338651);
    a2 = md5ii(a2, b2, c2, d2, x[i], 6, -198630844);
    d2 = md5ii(d2, a2, b2, c2, x[i + 7], 10, 1126891415);
    c2 = md5ii(c2, d2, a2, b2, x[i + 14], 15, -1416354905);
    b2 = md5ii(b2, c2, d2, a2, x[i + 5], 21, -57434055);
    a2 = md5ii(a2, b2, c2, d2, x[i + 12], 6, 1700485571);
    d2 = md5ii(d2, a2, b2, c2, x[i + 3], 10, -1894986606);
    c2 = md5ii(c2, d2, a2, b2, x[i + 10], 15, -1051523);
    b2 = md5ii(b2, c2, d2, a2, x[i + 1], 21, -2054922799);
    a2 = md5ii(a2, b2, c2, d2, x[i + 8], 6, 1873313359);
    d2 = md5ii(d2, a2, b2, c2, x[i + 15], 10, -30611744);
    c2 = md5ii(c2, d2, a2, b2, x[i + 6], 15, -1560198380);
    b2 = md5ii(b2, c2, d2, a2, x[i + 13], 21, 1309151649);
    a2 = md5ii(a2, b2, c2, d2, x[i + 4], 6, -145523070);
    d2 = md5ii(d2, a2, b2, c2, x[i + 11], 10, -1120210379);
    c2 = md5ii(c2, d2, a2, b2, x[i + 2], 15, 718787259);
    b2 = md5ii(b2, c2, d2, a2, x[i + 9], 21, -343485551);
    a2 = safeAdd(a2, olda);
    b2 = safeAdd(b2, oldb);
    c2 = safeAdd(c2, oldc);
    d2 = safeAdd(d2, oldd);
  }
  return [a2, b2, c2, d2];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y2) {
  var lsw = (x & 65535) + (y2 & 65535);
  var msw = (x >> 16) + (y2 >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a2, b2, x, s2, t2) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t2)), s2), b2);
}
function md5ff(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & c2 | ~b2 & d2, a2, b2, x, s2, t2);
}
function md5gg(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 & d2 | c2 & ~d2, a2, b2, x, s2, t2);
}
function md5hh(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(b2 ^ c2 ^ d2, a2, b2, x, s2, t2);
}
function md5ii(a2, b2, c2, d2, x, s2, t2) {
  return md5cmn(c2 ^ (b2 | ~d2), a2, b2, x, s2, t2);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f2(s2, x, y2, z) {
  switch (s2) {
    case 0:
      return x & y2 ^ ~x & z;
    case 1:
      return x ^ y2 ^ z;
    case 2:
      return x & y2 ^ x & z ^ y2 & z;
    case 3:
      return x ^ y2 ^ z;
  }
}
function ROTL(x, n2) {
  return x << n2 | x >>> 32 - n2;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l2 = bytes.length / 4 + 2;
  var N = Math.ceil(l2 / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t2 = 0; t2 < 16; ++t2) {
      W[t2] = M[_i2][t2];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a2 = H[0];
    var b2 = H[1];
    var c2 = H[2];
    var d2 = H[3];
    var e2 = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s2 = Math.floor(_t2 / 20);
      var T = ROTL(a2, 5) + f2(s2, b2, c2, d2) + e2 + K[s2] + W[_t2] >>> 0;
      e2 = d2;
      d2 = c2;
      c2 = ROTL(b2, 30) >>> 0;
      b2 = a2;
      a2 = T;
    }
    H[0] = H[0] + a2 >>> 0;
    H[1] = H[1] + b2 >>> 0;
    H[2] = H[2] + c2 >>> 0;
    H[3] = H[3] + d2 >>> 0;
    H[4] = H[4] + e2 >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@snap/camera-kit/dist/metrics/businessEventsReporter.js
var logger25 = getLogger("BusinessEventsReporter");
var connectivityTypeMapping = {
  cellular: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_MOBILE,
  bluetooth: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_BLUETOOTH,
  wifi: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_WIFI,
  unknown: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN,
  none: CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNREACHABLE
};
var vendorUuidKey = "vendorUuid";
var vendorUuidExpiry = convertDaysToSeconds(60);
var getOrGenerateVendorUuid = (persistence) => __awaiter(void 0, void 0, void 0, function* () {
  try {
    const storedUuid = yield persistence.retrieve(vendorUuidKey);
    if (storedUuid) {
      return storedUuid;
    }
    const newUuid = v4_default();
    yield persistence.store(vendorUuidKey, newUuid);
    return newUuid;
  } catch (error) {
    throw new Error("Failed to generate vendor UUID");
  }
});
function listenAndReport(metricsEventTarget, metricsClient, eventHandlers, appVendorAndPartnerUuid) {
  const sessionId = v4_default();
  logger25.log(`Session ID: ${sessionId}`);
  let sequenceId = 1;
  const makeBlizzardEvent = (event, appVendorUuid, partnerUuid) => {
    var _a;
    const { sdkShortVersion, sdkLongVersion, lensCore, locale, origin, deviceModel, connectionType } = getPlatformInfo();
    const deviceConnectivity = (_a = connectivityTypeMapping[connectionType]) !== null && _a !== void 0 ? _a : CameraKitConnectivityType2.CAMERA_KIT_CONNECTIVITY_TYPE_UNKNOWN;
    return Object.assign(Object.assign({}, event), { cameraKitEventBase: CameraKitEventBase.fromPartial({
      kitEventBase: KitEventBase.fromPartial({
        locale,
        kitVariant: KitType.CAMERA_KIT_WEB,
        kitVariantVersion: sdkShortVersion,
        kitClientTimestampMillis: `${Date.now()}`
      }),
      deviceCluster: "0",
      cameraKitVersion: sdkLongVersion,
      lensCoreVersion: lensCore.version,
      deviceModel,
      cameraKitVariant: CameraKitVariant.CAMERA_KIT_VARIANT_PARTNER,
      cameraKitFlavor: CameraKitFlavor2.CAMERA_KIT_FLAVOR_DEBUG,
      appId: origin,
      deviceConnectivity,
      sessionId,
      appVendorUuid,
      partnerUuid
    }) });
  };
  const sendServerEvent = (eventName, eventData) => {
    const { osName: osType, osVersion } = getPlatformInfo();
    return metricsClient.setBusinessEvents(ServerEvent.fromPartial({
      eventName,
      osType,
      osVersion,
      maxSequenceIdOnInstance: "0",
      sequenceId: `${sequenceId++}`,
      eventData
    }));
  };
  const metricsEvents = entries2(eventHandlers).map(([eventType, createEventData]) => fromEvent(metricsEventTarget, eventType).pipe(map((event) => ({ event, createEventData }))));
  merge(...metricsEvents).pipe(combineLatestWith(appVendorAndPartnerUuid)).subscribe(([{ event, createEventData }, { appVendorUuid, partnerUuid }]) => {
    const [eventName, eventData] = createEventData(makeBlizzardEvent(event.detail, appVendorUuid, partnerUuid));
    sendServerEvent(eventName, eventData);
  });
}
function getAppVendorAndPartnerUuid(configuration, remoteConfiguration) {
  const vendorAnalyticsPersistence = new ExpiringPersistence(() => vendorUuidExpiry, new IndexedDBPersistence({ databaseName: "VendorAnalytics" }));
  return remoteConfiguration.getInitializationConfig().pipe(take(1), switchMap(({ appVendorUuidOptIn }) => {
    const partnerUuid = configuration.analyticsId;
    if (appVendorUuidOptIn) {
      return from(getOrGenerateVendorUuid(vendorAnalyticsPersistence)).pipe(map((appVendorUuid) => ({ appVendorUuid, partnerUuid })));
    }
    return of({ appVendorUuid: void 0, partnerUuid });
  }), catchError((error) => {
    logger25.warn(`Failed to retrieve or generate vendor UUID.`, error);
    return of({ appVendorUuid: void 0, partnerUuid: configuration.analyticsId });
  }));
}
var businessEventsReporterFactory = Injectable("businessEventsReporter", [
  metricsEventTargetFactory.token,
  metricsClientFactory.token,
  configurationToken,
  remoteConfigurationFactory.token
], (metricsEventTarget, metricsClient, configuration, remoteConfiguration) => {
  const appVendorAndPartnerUuid = getAppVendorAndPartnerUuid(configuration, remoteConfiguration);
  listenAndReport(metricsEventTarget, metricsClient, {
    assetDownload: (event) => [
      "CAMERA_KIT_ASSET_DOWNLOAD",
      { cameraKitAssetDownload: CameraKitAssetDownload.fromPartial(event) }
    ],
    assetValidationFailed: (event) => [
      "CAMERA_KIT_ASSET_VALIDATION_FAILED",
      {
        cameraKitAssetValidationFailed: CameraKitAssetValidationFailed.fromPartial(event)
      }
    ],
    benchmarkComplete: (event) => [
      "CAMERA_KIT_WEB_BENCHMARK_COMPLETE",
      {
        cameraKitWebBenchmarkComplete: CameraKitWebBenchmarkComplete.fromPartial(event)
      }
    ],
    exception: (event) => [
      "CAMERA_KIT_EXCEPTION",
      { cameraKitException: CameraKitException.fromPartial(event) }
    ],
    legalPrompt: (event) => [
      "CAMERA_KIT_LEGAL_PROMPT",
      { cameraKitLegalPrompt: CameraKitLegalPrompt.fromPartial(event) }
    ],
    lensDownload: (event) => [
      "CAMERA_KIT_LENS_DOWNLOAD",
      { cameraKitLensDownload: CameraKitLensDownload.fromPartial(event) }
    ],
    lensView: (event) => [
      "CAMERA_KIT_WEB_LENS_SWIPE",
      { cameraKitWebLensSwipe: CameraKitWebLensSwipe.fromPartial(event) }
    ],
    lensWait: (event) => [
      "CAMERA_KIT_LENS_SPIN",
      { cameraKitLensSpin: CameraKitLensSpin.fromPartial(event) }
    ],
    lensContentValidationFailed: (event) => [
      "CAMERA_KIT_LENS_CONTENT_VALIDATION_FAILED",
      {
        cameraKitLensContentValidationFailed: CameraKitLensContentValidationFailed.fromPartial(event)
      }
    ],
    session: (event) => [
      "CAMERA_KIT_SESSION",
      { cameraKitSession: CameraKitSession.fromPartial(event) }
    ]
  }, appVendorAndPartnerUuid);
});

// node_modules/@snap/camera-kit/dist/logger/registerLogEntriesSubscriber.js
var registerLogEntriesSubscriber = Injectable("registerLogEntriesSubscriber", [configurationToken, logEntriesFactory.token], (configuration, logEntries) => {
  logEntries.pipe(filter((entry) => logLevelMap[entry.level] >= logLevelMap[configuration.logLevel])).subscribe((logEntry) => {
    switch (configuration.logger) {
      case "console":
        const messages = getPlatformInfo().browser.brand === "Chrome" ? logEntry.messages.map((message) => {
          if (!(message instanceof Error))
            return message;
          message.stack = stringifyError(message);
          return message;
        }) : logEntry.messages;
        console[logEntry.level](`[CameraKit.${logEntry.module}]`, ...messages);
        break;
    }
  });
});

// node_modules/@snap/camera-kit/dist/clients/lensesClient.js
var lensesClientFactory = Injectable("lensesClient", [grpcHandlerFactory.token], (grpcHandler) => createTsProtoClient(LensesDefinition, grpcHandler));

// node_modules/@snap/camera-kit/dist/lens/cameraKitLensSource.js
var logger26 = getLogger("CameraKitLensSource");
var hasAnyValue2 = (c2) => {
  var _a, _b;
  return ((_b = (_a = c2.value) === null || _a === void 0 ? void 0 : _a.anyValue) === null || _b === void 0 ? void 0 : _b.value) instanceof Uint8Array;
};
var defaultWatermarkLens = {
  id: "60515300902",
  name: "Watermark",
  content: {
    lnsSha256: "3EDEAEBCD51A547FF4D1F5708FBD6F4D628AD736BEE07AB3844B14E6C69EC510",
    lnsUrlBolt: "https://bolt-gcdn.sc-cdn.net/3/L6uAe5Fhyg0ZFf3RLsCVZ?bo=EhgaABoAMgF9OgEEQgYIkbHPpgZIAlASYAE%3D&uc=18"
  }
};
var cameraKitLensSourceFactory = Injectable(lensSourcesFactory.token, [lensSourcesFactory.token, lensesClientFactory.token, remoteConfigurationFactory.token], (lensSources, lensesClient, remoteConfig) => [
  {
    isGroupOwner(groupId) {
      return groupId === watermarksLensGroup;
    },
    loadLens() {
      return __awaiter(this, void 0, void 0, function* () {
        const lensMessage = yield firstValueFrom(remoteConfig.get("CAMERA_KIT_WATERMARK_LENS").pipe(map((configResults) => {
          var _a;
          const lensMessage2 = (_a = configResults.find(hasAnyValue2)) === null || _a === void 0 ? void 0 : _a.value.anyValue.value;
          if (!lensMessage2)
            throw new Error("Failed to read watermark Lens from COF response.");
          return lensMessage2;
        }), catchError((error) => {
          logger26.error(error);
          return of(Lens.encode(Lens.fromPartial(defaultWatermarkLens)).finish());
        })));
        return new BinaryWriter().uint32(10).bytes(lensMessage).finish();
      });
    },
    loadLensGroup() {
      return __awaiter(this, void 0, void 0, function* () {
        throw new Error("Not implemented.");
      });
    }
  },
  ...lensSources,
  {
    isGroupOwner() {
      return true;
    },
    loadLens(lensId, groupId) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield lensesClient.getGroupLens({ lensId, groupId });
        if (!result.ok) {
          const error = result.unwrapErr();
          throw new Error(`Cannot load lens lens ${lensId} from group ${groupId}. An error occured in the gRPC client:
	[${error.status}] ${error.statusMessage}`);
        }
        const response = result.unwrap();
        if (!((_a = response.message) === null || _a === void 0 ? void 0 : _a.lens)) {
          throw new Error(`Cannot load lens ${lensId} from group ${groupId}. The response did not contain a lens.
	${JSON.stringify(result)} for requestId ${response.headers.get("x-request-id")}`);
        }
        return Lens.encode(response.message.lens, new BinaryWriter().uint32(10).fork()).join().finish();
      });
    },
    loadLensGroup(groupId) {
      var _a;
      return __awaiter(this, void 0, void 0, function* () {
        const result = yield lensesClient.getGroup({ id: groupId });
        if (!result.ok) {
          const error = result.unwrapErr();
          throw new Error(`Cannot load lens group ${groupId}. An error occurred in the gRPC client:
	[${error.status}] ${error.statusMessage}`);
        }
        const response = result.unwrap();
        if (!((_a = response.message) === null || _a === void 0 ? void 0 : _a.lenses)) {
          throw new Error(`Cannot load lens group ${groupId}. The response contained no lenses 
	${JSON.stringify(response)} for requestId ${response.headers.get("x-request-id")}`);
        }
        const writer = new BinaryWriter();
        response.message.lenses.forEach((lens) => Lens.encode(lens, writer.uint32(10).fork()).join());
        return writer.finish();
      });
    }
  }
]);

// node_modules/@snap/camera-kit/dist/bootstrapCameraKit.js
var logger27 = getLogger("bootstrapCameraKit");
var nonWrappableErrors = [
  "ConfigurationError",
  "PlatformNotSupportedError"
];
function shouldWrapError(error) {
  if (error instanceof Error) {
    return !nonWrappableErrors.some((name) => error.name === name);
  }
  return true;
}
function bootstrapCameraKit(configuration, provide) {
  return __awaiter(this, void 0, void 0, function* () {
    console.info(`Camera Kit SDK: ${environment_default.PACKAGE_VERSION} (${lensCoreWasmVersions_default.version}/${lensCoreWasmVersions_default.buildNumber})`);
    try {
      const bootstrapLatency = new Timer("bootstrap_time");
      assert(isSafeString(configuration.apiToken), configurationError("Invalid or unsafe apiToken provided."));
      const configurationFactory = createCameraKitConfigurationFactory(configuration);
      const defaultPublicContainer = Container.provides(configurationFactory).provides(userDataAccessResolverFactory).provides(filePickerFactory).provides(defaultFetchHandlerFactory).provides(remoteMediaAssetLoaderFactory).provides(lensSourcesFactory).provides(remoteApiServicesFactory).provides(uriHandlersFactory).provides(geoDataProviderFactory).provides(externalMetricsSubjectFactory);
      const publicContainer = provide ? provide(defaultPublicContainer) : defaultPublicContainer;
      const telemetryContainer = Container.provides(publicContainer).provides(pageVisibilityFactory).provides(cameraKitServiceFetchHandlerFactory).provides(requestStateEventTargetFactory).provides(grpcHandlerFactory).provides(metricsClientFactory).provides(logEntriesFactory).run(registerLogEntriesSubscriber).provides(metricsEventTargetFactory).provides(reportGlobalException).provides(cofHandlerFactory).provides(remoteConfigurationFactory).provides(legalPromptFactory).provides(legalStateFactory).run(reportGloballyScopedMetrics).run(businessEventsReporterFactory);
      telemetryContainer.get(reportGlobalException.token);
      yield assertPlatformSupported();
      const lensCore = yield telemetryContainer.provides(lensCoreFactory).get(lensCoreFactory.token);
      const container = telemetryContainer.provides(Injectable(lensCoreFactory.token, () => lensCore)).provides(lensesClientFactory).provides(remoteApiSpecsClientFactory).provides(cameraKitLensSourceFactory).provides(lensPersistenceStoreFactory).provides(deviceDependentAssetLoaderFactory).provides(staticAssetLoaderFactory).provides(lensAssetRepositoryFactory).provides(lensRepositoryFactory).provides(cameraKitFactory).run(fetchWatermarkLens);
      const cameraKit = container.get(cameraKitFactory.token);
      bootstrapLatency.measure();
      container.get(metricsClientFactory.token).setOperationalMetrics(bootstrapLatency);
      return cameraKit;
    } catch (error) {
      if (shouldWrapError(error)) {
        error = bootstrapError("Error occurred during Camera Kit bootstrapping.", error);
      }
      logger27.error(error);
      throw error;
    }
  });
}
function createExtension() {
  return new PartialContainer({});
}

// node_modules/@snap/camera-kit/dist/extensions/extensionRequestContext.js
var getExtensionRequestContext = memoize2(function getExtensionRequestContext2() {
  return ExtensionRequestContext.encode({
    userAgent: getCameraKitUserAgent(),
    locale: getPlatformInfo().fullLocale
  }).finish();
});
var extensionRequestContext = getExtensionRequestContext();

// node_modules/@snap/camera-kit/dist/media-sources/FunctionSource.js
var getYUVImageData = (canvas, lensCore) => __awaiter(void 0, void 0, void 0, function* () {
  const { width: width2, height: height2 } = canvas;
  const outputBuffer = new ArrayBuffer(width2 * height2 * 3 / 2);
  yield lensCore.imageToYuvBuffer({ image: canvas, width: width2, height: height2, outputBuffer });
  const pixels = new Uint8ClampedArray(outputBuffer);
  return new ImageData(pixels, width2, height2);
});
var getRGBImageData = (output, imageReader2D) => {
  if (imageReader2D === null)
    return new ImageData(0, 0);
  imageReader2D.drawImage(output, 0, 0);
  return imageReader2D.getImageData(0, 0, output.width, output.height);
};
var getImageBitmap = (imageData, format) => __awaiter(void 0, void 0, void 0, function* () {
  switch (format) {
    case "nv12":
    case "yuv":
      if (!window.VideoFrame)
        return Promise.reject(new Error(`Cannot process frame. ImageData in ${format} is not supported by this browser.`));
      const frame = new VideoFrame(imageData.data.buffer, {
        format: "NV12",
        codedWidth: imageData.width,
        codedHeight: imageData.height,
        timestamp: 0
      });
      return createImageBitmap(frame);
    case "rgb":
      return createImageBitmap(imageData);
  }
});
var createFunctionSource = (sourceFunction, options = {}) => {
  let width2 = 0;
  let height2 = 0;
  let shouldProcessFrame = true;
  const imageReaderCanvas = document.createElement("canvas");
  const imageReader2D = imageReaderCanvas.getContext("2d");
  const subscriber = {
    onAttach: (source, lensCore, reportError) => {
      const outputs = lensCore.getOutputCanvases();
      const output = {
        live: outputs[lensCore.CanvasType.Preview.value],
        capture: outputs[lensCore.CanvasType.Capture.value]
      };
      const processFrame = (source2, lensCore2, reportError2) => requestAnimationFrame(() => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        if (!shouldProcessFrame)
          return;
        try {
          yield sourceFunction(({ format, imageData, timestampMillis }) => {
            const frameOutput = new Promise((resolve, reject) => __awaiter(void 0, void 0, void 0, function* () {
              const inputFrame = yield getImageBitmap(imageData, format !== null && format !== void 0 ? format : "rgb");
              if (inputFrame.width !== width2 || inputFrame.height !== height2) {
                width2 = imageReaderCanvas.width = inputFrame.width;
                height2 = imageReaderCanvas.height = inputFrame.height;
                source2.setRenderSize(width2, height2);
              }
              lensCore2.processFrame({ inputFrame, timestampMillis }).then(() => __awaiter(void 0, void 0, void 0, function* () {
                inputFrame.close();
                switch (format !== null && format !== void 0 ? format : "rgb") {
                  case "nv12":
                  case "yuv":
                    const [live, capture] = yield Promise.all([
                      getYUVImageData(output.live, lensCore2),
                      getYUVImageData(output.capture, lensCore2)
                    ]).catch((error) => {
                      reject(error);
                      return [void 0, void 0];
                    });
                    if (!live || !capture)
                      return;
                    return resolve({ live, capture });
                  case "rgb":
                    return resolve({
                      live: getRGBImageData(output.live, imageReader2D),
                      capture: getRGBImageData(output.capture, imageReader2D)
                    });
                }
              })).catch((error) => {
                inputFrame.close();
                reject(error);
              });
            }));
            frameOutput.finally(() => processFrame(source2, lensCore2, reportError2));
            return frameOutput;
          });
        } catch (error) {
          reportError2(new Error(`Failure to process frame, which was not handled by the provided MediaSourceFunction ${(_a = sourceFunction.name) !== null && _a !== void 0 ? _a : "anonymous"}.`, { cause: error }));
        }
      }));
      processFrame(source, lensCore, reportError);
    },
    onDetach: () => {
      shouldProcessFrame = false;
    }
  };
  return new CameraKitSource({ useManualFrameProcessing: true }, subscriber, options);
};

// node_modules/@snap/camera-kit/dist/media-sources/ImageSource.js
function createImageSource(image, options = {}) {
  return new CameraKitSource({
    media: image
  }, {}, options);
}
export {
  Any,
  CameraKit,
  CameraKitSession2 as CameraKitSession,
  CameraKitSource,
  ConcatInjectable,
  Container,
  Count,
  Histogram,
  Injectable,
  InjectableCompat,
  LensPerformanceMeasurement,
  LensPerformanceMetrics,
  LensRepository,
  Lens_CameraFacing,
  Metric,
  PartialContainer,
  Timer,
  Transform2D,
  TypedCustomEvent,
  TypedEventTarget,
  argumentValidationError,
  benchmarkError,
  bootstrapCameraKit,
  bootstrapError,
  cacheKeyNotFoundError,
  cameraKitSourceError,
  configurationError,
  configurationToken,
  createExtension,
  createFunctionSource,
  createImageSource,
  createMediaStreamSource,
  createVideoSource,
  defaultFetchHandlerFactory,
  estimateLensPerformance,
  extensionRequestContext,
  externalMetricsSubjectFactory,
  filePickerFactory,
  geoDataProviderFactory,
  getExtensionRequestContext,
  legalError,
  lensAbortError,
  lensAssetError,
  lensContentValidationError,
  lensError,
  lensExecutionError,
  lensImagePickerError,
  lensSourcesFactory,
  namedError,
  persistentStoreError,
  platformNotSupportedError,
  remoteApiServicesFactory,
  remoteMediaAssetLoaderFactory,
  toPublicLens,
  uriHandlersFactory,
  userDataAccessResolverFactory,
  webGLError
};
//# sourceMappingURL=@snap_camera-kit.js.map
