import { __awaiter, __esDecorate, __runInitializers } from "tslib";
import { copyDefinedProperties } from "../common/copyDefinedProperties";
import { isRecord, isUndefined, isValidNumber, isValidNumberOrUndefined } from "../common/typeguards";
import { validate } from "../common/validate";
import { isTransform2D } from "../transforms/Transform2D";
export const defaultDeviceInfo = {
    cameraType: "user",
    fpsLimit: Number.POSITIVE_INFINITY,
};
const createNotAttachedError = (message) => new Error(`${message}. This CameraKitSource is not attached to a CameraKitSession.`);
const cameraTypeValueSet = new Set(Object.keys({
    user: 0,
    environment: 0,
}));
export function isCameraKitSource(value) {
    return value instanceof CameraKitSource;
}
export function isPartialCameraKitDeviceOptionsOrUndefined(value) {
    return isUndefined(value) || isPartialCameraKitDeviceOptions(value);
}
function isPartialCameraKitDeviceOptions(value) {
    return isRecord(value) && isCameraTypeOrUndefined(value.cameraType) && isValidNumberOrUndefined(value.fpsLimit);
}
function isCameraType(value) {
    return cameraTypeValueSet.has(value);
}
function isCameraTypeOrUndefined(value) {
    return isUndefined(value) || isCameraType(value);
}
let CameraKitSource = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _setRenderSize_decorators;
    let _setTransform_decorators;
    return _a = class CameraKitSource {
            constructor(sourceInfo, subscriber = {}, deviceInfo = {}) {
                this.sourceInfo = (__runInitializers(this, _instanceExtraInitializers), sourceInfo);
                this.subscriber = subscriber;
                this.deviceInfo = Object.assign(Object.assign({}, defaultDeviceInfo), copyDefinedProperties(deviceInfo));
            }
            attach(lensCore, reportError) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.lensCore) {
                        throw new Error("This CameraKitSource has already been attached to this CameraKitSession " +
                            "and cannot be reattached, even after detachment.");
                    }
                    this.lensCore = lensCore;
                    yield lensCore.useMediaElement({
                        autoplayNewMedia: false,
                        autoplayPreviewCanvas: false,
                        media: this.sourceInfo.media,
                        pauseExistingMedia: false,
                        replayTrackingData: this.sourceInfo.replayTrackingData,
                        requestWebcam: false,
                        startOnFrontCamera: ["user", "front"].includes(this.deviceInfo.cameraType),
                        useManualFrameProcessing: this.sourceInfo.useManualFrameProcessing,
                    });
                    const fps = this.deviceInfo.fpsLimit < Number.POSITIVE_INFINITY ? this.deviceInfo.fpsLimit : 0;
                    yield lensCore.setFPSLimit({ fps });
                    yield lensCore.setRenderSize({ mode: "matchInputResolution" });
                    if (this.subscriber.onAttach)
                        yield this.subscriber.onAttach(this, lensCore, reportError);
                });
            }
            copy(deviceInfo = {}) {
                return new CameraKitSource(this.sourceInfo, this.subscriber, Object.assign(Object.assign({}, this.deviceInfo), deviceInfo));
            }
            detach(reportError) {
                if (!this.lensCore)
                    return Promise.reject(createNotAttachedError("Cannot detach"));
                if (this.subscriber.onDetach)
                    return this.subscriber.onDetach(reportError);
            }
            setRenderSize(width, height) {
                if (!this.lensCore)
                    return Promise.reject(createNotAttachedError("Cannot setRenderSize"));
                const target = { width, height };
                return this.lensCore.setRenderSize({ mode: "explicit", target });
            }
            setTransform(transform) {
                if (!this.lensCore)
                    return Promise.reject(createNotAttachedError("Cannot setTransform"));
                const matrix = new Float32Array(transform.matrix);
                return this.lensCore.setInputTransform({ matrix });
            }
        },
        (() => {
            _setRenderSize_decorators = [validate(isValidNumber, isValidNumber)];
            _setTransform_decorators = [validate(isTransform2D)];
            __esDecorate(_a, null, _setRenderSize_decorators, { kind: "method", name: "setRenderSize", static: false, private: false, access: { has: obj => "setRenderSize" in obj, get: obj => obj.setRenderSize } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _setTransform_decorators, { kind: "method", name: "setTransform", static: false, private: false, access: { has: obj => "setTransform" in obj, get: obj => obj.setTransform } }, null, _instanceExtraInitializers);
        })(),
        _a;
})();
export { CameraKitSource };
//# sourceMappingURL=CameraKitSource.js.map