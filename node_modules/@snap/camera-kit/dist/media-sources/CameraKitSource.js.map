{"version":3,"file":"CameraKitSource.js","sourceRoot":"","sources":["../../src/media-sources/CameraKitSource.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/member-ordering */\n\nimport { copyDefinedProperties } from \"../common/copyDefinedProperties\";\nimport { isRecord, isUndefined, isValidNumber, isValidNumberOrUndefined } from \"../common/typeguards\";\nimport { validate } from \"../common/validate\";\nimport type { LensCore } from \"../lens-core-module/lensCore\";\nimport type { Transform2D } from \"../transforms/Transform2D\";\nimport { isTransform2D } from \"../transforms/Transform2D\";\n\nexport const defaultDeviceInfo: CameraKitDeviceOptions = {\n    cameraType: \"user\",\n    fpsLimit: Number.POSITIVE_INFINITY,\n};\n\nconst createNotAttachedError = (message: string) =>\n    new Error(`${message}. This CameraKitSource is not attached to a CameraKitSession.`);\n\n/**\n * When creating a {@link CameraKitSource}, passing a CameraKitSourceSubscriber allows logic to implemented which will\n * run whenever that source is attached/detached from a CameraKitSession.\n *\n * @category Rendering\n */\nexport interface CameraKitSourceSubscriber {\n    readonly onAttach?: (\n        source: CameraKitSource,\n        lensCore: LensCore,\n        reportError: (error: Error) => void\n    ) => void | Promise<void>;\n    readonly onDetach?: (reportError: (error: Error) => void) => void | Promise<void>;\n}\n\n// Helper set to ensure that changes to cameraType will ensure changes to the guard.\ntype CameraType = CameraKitDeviceOptions[\"cameraType\"];\nconst cameraTypeValueSet = new Set(\n    Object.keys({\n        user: 0,\n        environment: 0,\n    } satisfies Record<CameraType, 0>) as CameraType[]\n);\n\nexport function isCameraKitSource(value: unknown): value is CameraKitSource {\n    return value instanceof CameraKitSource;\n}\n\nexport function isPartialCameraKitDeviceOptionsOrUndefined(\n    value: unknown\n): value is Partial<CameraKitDeviceOptions> | undefined {\n    return isUndefined(value) || isPartialCameraKitDeviceOptions(value);\n}\n\nfunction isPartialCameraKitDeviceOptions(value: unknown): value is Partial<CameraKitDeviceOptions> {\n    return isRecord(value) && isCameraTypeOrUndefined(value.cameraType) && isValidNumberOrUndefined(value.fpsLimit);\n}\n\nfunction isCameraType(value: unknown): value is CameraType {\n    return cameraTypeValueSet.has(value as CameraType);\n}\n\nfunction isCameraTypeOrUndefined(value: unknown): value is CameraType | undefined {\n    return isUndefined(value) || isCameraType(value);\n}\n\n/**\n * Device options.\n *\n * @category Rendering\n */\nexport interface CameraKitDeviceOptions {\n    /**\n     * Specifies the camera type for which certain features are enabled or disabled.\n     * For example, surface tracking features are only active when the camera is set to \"environment\" mode.\n     * The default value is \"user\", which accommodates the majority of Lenses.\n     * \"user\" refers to the front-facing camera, while \"environment\" refers to the rear-facing camera.\n     */\n    cameraType: \"user\" | \"environment\";\n\n    /**\n     * Limits the frames per second (FPS) to optimize performance by reducing compute resources\n     * when high FPS is not critical. By default, no limit is set, allowing usage of the video's native FPS.\n     * Useful for controlling resource usage on varying device capabilities.\n     */\n    fpsLimit: number;\n}\n\n/** @category Rendering */\nexport interface CameraKitSourceInfo {\n    /**\n     * HTML element or MediaStream as an input source.\n     * If useManualFrameProcessing is true, then this parameter is optional.\n     */\n    media?: HTMLCanvasElement | HTMLImageElement | HTMLVideoElement | MediaStream;\n\n    /**\n     * Whether to provide frames manually.\n     */\n    useManualFrameProcessing?: boolean;\n\n    /**\n     * If specified, the passed-in tracking data buffer will be used as tracking data for the current\n     * media element instead of live tracking data.\n     */\n    replayTrackingData?: {\n        buffer: Uint8Array | ArrayBuffer;\n    };\n}\n\n/**\n * This general-purpose class represents a source of media for a {@link CameraKitSession}.\n *\n * When an instance is passed to {@link CameraKitSession.setSource | CameraKitSession.setSource}, it will be \"attached\"\n * to the session. Later it may be \"detached\" from the session.\n *\n * Passing a {@link CameraKitSourceSubscriber} to the constructor allows callers to specify behavior\n * that will occur when the source is attached and detached. This can be used to e.g. update the render size.\n *\n * **Important:** Once a source has been attached to a {@link CameraKitSession}, it cannot be reattached,\n * even if it has been detached. You must supply a new instance of {@link CameraKitSource} to {@link\n * CameraKitSession.setSource}.\n * If you want to reuse the existing source, you can use its {@link CameraKitSource.copy} method to create a new\n * instance.\n *\n * @category Rendering\n */\nclass CameraKitSource {\n    private lensCore?: LensCore;\n    private readonly deviceInfo: CameraKitDeviceOptions;\n\n    constructor(\n        private readonly sourceInfo: CameraKitSourceInfo,\n        private readonly subscriber: CameraKitSourceSubscriber = {},\n        deviceInfo: Partial<CameraKitDeviceOptions> = {}\n    ) {\n        this.deviceInfo = { ...defaultDeviceInfo, ...copyDefinedProperties(deviceInfo) };\n    }\n\n    /**\n     * Called by {@link CameraKitSession} when this source is set as that session's source.\n     *\n     * @param lensCore\n     * @param reportError Calling this function will report an error back to the session.\n     * @returns Rejects if any calls to LensCore or CameraKitSource.subscriber.onAttach fail.\n     * @internal\n     */\n    async attach(lensCore: LensCore, reportError: (error: Error) => void): Promise<void> {\n        if (this.lensCore) {\n            throw new Error(\n                \"This CameraKitSource has already been attached to this CameraKitSession \" +\n                    \"and cannot be reattached, even after detachment.\"\n            );\n        }\n\n        this.lensCore = lensCore;\n\n        await lensCore.useMediaElement({\n            autoplayNewMedia: false,\n            autoplayPreviewCanvas: false,\n            media: this.sourceInfo.media,\n            pauseExistingMedia: false,\n            replayTrackingData: this.sourceInfo.replayTrackingData,\n            requestWebcam: false,\n            startOnFrontCamera: [\"user\", \"front\"].includes(this.deviceInfo.cameraType),\n            useManualFrameProcessing: this.sourceInfo.useManualFrameProcessing,\n        });\n\n        // LensCore uses 0 to remove the limit.\n        const fps = this.deviceInfo.fpsLimit < Number.POSITIVE_INFINITY ? this.deviceInfo.fpsLimit : 0;\n        await lensCore.setFPSLimit({ fps });\n        await lensCore.setRenderSize({ mode: \"matchInputResolution\" });\n\n        if (this.subscriber.onAttach) await this.subscriber.onAttach(this, lensCore, reportError);\n    }\n\n    /**\n     * Make a copy of the source, sharing the same {@link CameraKitSourceSubscriber}.\n     *\n     * @param deviceInfo Optionally provide new device info for the copy (e.g. to change the camera type).\n     * @returns The new {@link CameraKitSource}\n     */\n    copy(deviceInfo: Partial<CameraKitDeviceOptions> = {}): CameraKitSource {\n        return new CameraKitSource(this.sourceInfo, this.subscriber, { ...this.deviceInfo, ...deviceInfo });\n    }\n\n    /**\n     * Called by {@link CameraKitSession} when it must remove this source.\n     *\n     * @param reportError Calling this function will report an error back to the session.\n     * @returns\n     * @internal\n     */\n    detach(reportError: (error: Error) => void): void | Promise<void> {\n        if (!this.lensCore) return Promise.reject(createNotAttachedError(\"Cannot detach\"));\n        if (this.subscriber.onDetach) return this.subscriber.onDetach(reportError);\n    }\n\n    /**\n     * Set the resolution used to render this source.\n     *\n     * If greater performance is required, a smaller render size may boost frame-rate. It does come at a cost, including\n     * loss of accuracy in various tracking and computer-vision algorithms (since they'll be operating on fewer pixels).\n     *\n     * By default (i.e. if this method is never called), then the render size will match the size of the input media.\n     * Best performance can be achieved by varying the size of the input media and allowing CameraKit to render at a\n     * resolution that matches the input media -- this method should only be used if the input media resolution cannot\n     * be changed to the desired size.\n     *\n     * Itâ€™s important to distinguish render size from display size. The size at which the output canvases are displayed\n     * on a web page is determined by the CSS of the page. It is distinct from the size at which CameraKit renders\n     * Lenses. Performance is dominated by render size, while any display scaling (using CSS) can most often be thought\n     * of as free.\n     *\n     * The size of the Live and Capture {@link RenderTarget} is always the same.\n     *\n     * @todo Currently it's only valid to call `setRenderSize` after `CameraKitSession.play` has been called. This\n     * constraint should be removed, so callers don't have to understand the underlying LensCore state machine.\n     *\n     * @param width pixels\n     * @param height pixels\n     * @returns Promise resolves when the render size has been successfully updated.\n     */\n    @validate(isValidNumber, isValidNumber)\n    setRenderSize(width: number, height: number): Promise<void> {\n        if (!this.lensCore) return Promise.reject(createNotAttachedError(\"Cannot setRenderSize\"));\n        const target = { width, height };\n        return this.lensCore.setRenderSize({ mode: \"explicit\", target });\n    }\n\n    /**\n     * Apply a 2D transformation to the source (e.g. translation, rotation, scale).\n     *\n     * @param transform Specifies the 3x3 matrix describing the transformation.\n     */\n    @validate(isTransform2D)\n    setTransform(transform: Transform2D): Promise<void> {\n        if (!this.lensCore) return Promise.reject(createNotAttachedError(\"Cannot setTransform\"));\n        const matrix = new Float32Array(transform.matrix);\n        return this.lensCore.setInputTransform({ matrix });\n    }\n}\n\n// NOTE: jest doesn't like default exports of classes with decorated methods.\nexport { CameraKitSource };\n"]}