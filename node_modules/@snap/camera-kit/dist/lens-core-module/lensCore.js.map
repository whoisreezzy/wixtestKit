{"version":3,"file":"lensCore.js","sourceRoot":"","sources":["../../src/lens-core-module/lensCore.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Observable } from \"rxjs\";\nimport { Subject } from \"rxjs\";\nimport type {\n    DefaultErrorHandler,\n    DefaultEventHandler,\n    LensCoreModule,\n    PlayCanvasInput,\n    LensCoreError as NativeLensCoreError,\n} from \"./generated-types\";\nimport type { LensCoreError } from \"./lensCoreError\";\nimport { wrapLensCoreError } from \"./lensCoreError\";\n\n// Note: While this looks similar to Omit, Omit breaks discriminated unions:\n// https://github.com/microsoft/TypeScript/issues/31501\n// This is relevant in the case of setRenderMode().\ntype SafeOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;\n\n/**\n * LensCore methods that require additional handling.\n */\ntype LensCoreCustomMethods = {\n    // initialize() param has exceptionHandler, which requires error mapping.\n    initialize(input: PromisifiedParam<MapParamErrorCallback<\"initialize\", \"exceptionHandler\">>): Promise<void>;\n\n    // provideRemoteAssetsResponse() param has onFailure, which requires error mapping.\n    provideRemoteAssetsResponse(input: MapParamErrorCallback<\"provideRemoteAssetsResponse\", \"onFailure\">): void;\n\n    // playCanvas() should resolve its Promise when the `onReady` callback is invoked, instead of the `onSuccess`.\n    playCanvas(input: Omit<PlayCanvasInput, \"onReady\" | \"onSuccess\" | \"onFailure\">): Promise<void>;\n};\n\n// Ensure method names defined in CustomLensCoreMethods are the ones that exist in LensCoreModule.\ntype LensCoreCustomMethodNames = keyof LensCoreCustomMethods extends keyof LensCoreModule\n    ? keyof LensCoreCustomMethods\n    : never;\n\ntype PropertyKinds = \"enum\" | \"sync method\" | \"promisifiable method\" | \"custom method\";\n\n// Create a mapping between property keys and the kind of property it is (enum, sync method, or async method)\ntype LensCorePropertyKinds = {\n    [K in keyof LensCoreModule]: LensCoreModule[K] extends (...args: any[]) => any\n        ? K extends LensCoreCustomMethodNames\n            ? \"custom method\"\n            : Parameters<LensCoreModule[K]>[0] extends {\n                  onSuccess?: DefaultEventHandler;\n                  onFailure?: DefaultErrorHandler;\n              }\n            ? \"promisifiable method\"\n            : \"sync method\"\n        : \"enum\";\n};\n\n// Helper to select LensCoreModule properties of a particular kind.\ntype PropertiesOfKind<T extends PropertyKinds> = Exclude<\n    {\n        [K in keyof LensCorePropertyKinds]: LensCorePropertyKinds[K] extends T ? K : never;\n    }[keyof LensCorePropertyKinds],\n    undefined\n>;\ntype FirstParameter<T> = T extends (first: infer P, ...rest: any[]) => any ? P : never;\ntype LensCoreEnums = Pick<LensCoreModule, PropertiesOfKind<\"enum\">>;\ntype LensCoreSyncMethods = Pick<LensCoreModule, PropertiesOfKind<\"sync method\">>;\ntype LensCorePromisifiedMethods = {\n    [K in PropertiesOfKind<\"promisifiable method\">]: K extends keyof LensCoreModule\n        ? keyof SafeOmit<Parameters<LensCoreModule[K]>[0], \"onSuccess\" | \"onFailure\"> extends never\n            ? () => Promise<FirstParameter<Parameters<LensCoreModule[K]>[0][\"onSuccess\"]>>\n            : (\n                  input: SafeOmit<Parameters<LensCoreModule[K]>[0], \"onSuccess\" | \"onFailure\">\n              ) => Promise<FirstParameter<Parameters<LensCoreModule[K]>[0][\"onSuccess\"]>>\n        : never;\n};\ntype PromisifiedParam<T extends { onSuccess?: DefaultEventHandler; onFailure?: DefaultErrorHandler }> = {\n    [P in keyof T as P extends \"onSuccess\" | \"onFailure\" ? never : P]: T[P];\n};\ntype MapParamErrorCallback<\n    T extends PropertiesOfKind<\"custom method\">,\n    U extends keyof LensCoreMethodFirstParam<T>\n> = MapErrorCallback<LensCoreMethodFirstParam<T>, U>;\ntype LensCoreMethodFirstParam<T extends PropertiesOfKind<\"custom method\">> = Parameters<LensCoreModule[T]>[0];\ntype MapErrorCallback<T, U extends keyof T> = { [P in keyof T]: P extends U ? (err: LensCoreError) => void : T[P] };\n\n// By using PropertiesOfKind, we can ensure a compile-time error if LensCoreModule adds a new async method,\n// but we forget to update this list.\nconst promisifiableMethods: { [K in PropertiesOfKind<\"promisifiable method\">]: null } = {\n    addLens: null,\n    clearAllLenses: null,\n    imageToYuvBuffer: null,\n    pauseCanvas: null,\n    processAudioSampleBuffer: null,\n    processFrame: null,\n    removeLens: null,\n    replaceLenses: null,\n    setAudioParameters: null,\n    setDeviceClass: null,\n    setGpuIndex: null,\n    setFPSLimit: null,\n    setInputTransform: null,\n    setOnFrameProcessedCallback: null,\n    setRenderLoopMode: null,\n    setRenderSize: null,\n    teardown: null,\n    useMediaElement: null,\n    yuvBufferToBitmap: null,\n};\n\n/** @internal */\nexport type LensCore = LensCoreEnums &\n    LensCoreSyncMethods &\n    LensCorePromisifiedMethods &\n    LensCoreCustomMethods &\n    LensCoreErrorField;\n\n/**\n * @internal\n */\nexport interface LensCoreErrorField {\n    errors: Observable<LensCoreError>;\n}\n\n/**\n * Returns a native LensCore error mapper, which maps LensCore native errors to Camera Kit errors.\n *\n * @param isForFrameErrors Indicates whether the errors occurred during frame processing.\n * @param errors An observable subject where this error is emitted.\n */\nfunction createErrorWrapper(isForFrameErrors: boolean, errors: Subject<LensCoreError>) {\n    return (fn: (e: LensCoreError) => void) => {\n        return (nativeError: NativeLensCoreError): void => {\n            const error = wrapLensCoreError(nativeError, isForFrameErrors);\n            fn(error);\n            errors.next(error);\n        };\n    };\n}\n\nfunction withTryCatch<T extends (...args: any) => any>(fn: T, errors: Subject<LensCoreError>) {\n    return function (this: LensCoreModule, ...args: Parameters<T>) {\n        try {\n            return fn.apply(this, args);\n        } catch (e) {\n            const error = wrapLensCoreError(e, false);\n            errors.next(error);\n            throw error;\n        }\n    };\n}\n\nconst errorsFieldName: keyof LensCoreErrorField = \"errors\";\n\n/**\n * Create wrapper around LensCore module which adds Promise interfaces to the methods.\n *\n * NOTE: We try to keep as close to the native LensCore module as possible.\n * Ideally when LensCore makes its interface Promises, we won't need this Proxy.\n *\n * @internal\n */\nexport const createLensCore = (lensCoreModule: LensCoreModule): LensCore => {\n    const errors = new Subject<LensCoreError>();\n    const errorsObservable = errors.asObservable();\n    const getRegularErrorWrapper = createErrorWrapper(false, errors);\n    const getFrameErrorWrapper = createErrorWrapper(true, errors);\n\n    const customMethods: LensCoreCustomMethods = {\n        initialize(input) {\n            return new Promise((onSuccess, onFailure) =>\n                lensCoreModule.initialize({\n                    ...input,\n                    exceptionHandler: getFrameErrorWrapper(input.exceptionHandler ?? (() => {})),\n                    onSuccess,\n                    onFailure: getRegularErrorWrapper(onFailure),\n                })\n            );\n        },\n\n        provideRemoteAssetsResponse(input) {\n            return lensCoreModule.provideRemoteAssetsResponse({\n                ...input,\n                onFailure: getRegularErrorWrapper(input.onFailure ?? (() => {})),\n            });\n        },\n\n        playCanvas(input) {\n            return new Promise((onReady, onFailure) => {\n                lensCoreModule.playCanvas({\n                    ...input,\n                    onReady,\n                    onFailure: getRegularErrorWrapper(onFailure),\n                });\n            });\n        },\n    };\n\n    return new Proxy(lensCoreModule, {\n        get: (target, property, receiver) => {\n            if (property === errorsFieldName) {\n                return errorsObservable;\n            }\n\n            // Handle special methods with custom implementations\n            if (property in customMethods) {\n                // Safety: \"in\" operator above ensures that property is keyof LensCoreCustomMethods\n                return withTryCatch(customMethods[property as keyof LensCoreCustomMethods], errors);\n            }\n\n            const targetProperty = Reflect.get(target, property, receiver);\n            if (!targetProperty) return targetProperty;\n\n            // All other async methods return Promises\n            if (property in promisifiableMethods) {\n                return withTryCatch(function (\n                    input: Parameters<LensCorePromisifiedMethods[keyof LensCorePromisifiedMethods]>[0]\n                ) {\n                    return new Promise((onSuccess, onFailure) =>\n                        targetProperty({\n                            ...input,\n                            onSuccess,\n                            onFailure: getRegularErrorWrapper(onFailure),\n                        })\n                    );\n                },\n                errors);\n            }\n\n            // All other kinds of properties (enums, sync methods) are unmodified.\n            if (typeof targetProperty === \"function\") {\n                if (\"values\" in targetProperty) {\n                    // this is enum\n                    return targetProperty;\n                } else {\n                    // this is a sync method\n                    return withTryCatch(targetProperty, errors);\n                }\n            }\n            return targetProperty;\n        },\n        // Safety: We ensured safety by defining types for both custom and promisifiable methods.\n    }) as LensCore;\n};\n"]}