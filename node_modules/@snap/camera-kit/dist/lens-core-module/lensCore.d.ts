import type { Observable } from "rxjs";
import type { DefaultErrorHandler, DefaultEventHandler, LensCoreModule, PlayCanvasInput } from "./generated-types";
import type { LensCoreError } from "./lensCoreError";
type SafeOmit<T, K extends keyof any> = T extends any ? Omit<T, K> : never;
/**
 * LensCore methods that require additional handling.
 */
type LensCoreCustomMethods = {
    initialize(input: PromisifiedParam<MapParamErrorCallback<"initialize", "exceptionHandler">>): Promise<void>;
    provideRemoteAssetsResponse(input: MapParamErrorCallback<"provideRemoteAssetsResponse", "onFailure">): void;
    playCanvas(input: Omit<PlayCanvasInput, "onReady" | "onSuccess" | "onFailure">): Promise<void>;
};
type LensCoreCustomMethodNames = keyof LensCoreCustomMethods extends keyof LensCoreModule ? keyof LensCoreCustomMethods : never;
type PropertyKinds = "enum" | "sync method" | "promisifiable method" | "custom method";
type LensCorePropertyKinds = {
    [K in keyof LensCoreModule]: LensCoreModule[K] extends (...args: any[]) => any ? K extends LensCoreCustomMethodNames ? "custom method" : Parameters<LensCoreModule[K]>[0] extends {
        onSuccess?: DefaultEventHandler;
        onFailure?: DefaultErrorHandler;
    } ? "promisifiable method" : "sync method" : "enum";
};
type PropertiesOfKind<T extends PropertyKinds> = Exclude<{
    [K in keyof LensCorePropertyKinds]: LensCorePropertyKinds[K] extends T ? K : never;
}[keyof LensCorePropertyKinds], undefined>;
type FirstParameter<T> = T extends (first: infer P, ...rest: any[]) => any ? P : never;
type LensCoreEnums = Pick<LensCoreModule, PropertiesOfKind<"enum">>;
type LensCoreSyncMethods = Pick<LensCoreModule, PropertiesOfKind<"sync method">>;
type LensCorePromisifiedMethods = {
    [K in PropertiesOfKind<"promisifiable method">]: K extends keyof LensCoreModule ? keyof SafeOmit<Parameters<LensCoreModule[K]>[0], "onSuccess" | "onFailure"> extends never ? () => Promise<FirstParameter<Parameters<LensCoreModule[K]>[0]["onSuccess"]>> : (input: SafeOmit<Parameters<LensCoreModule[K]>[0], "onSuccess" | "onFailure">) => Promise<FirstParameter<Parameters<LensCoreModule[K]>[0]["onSuccess"]>> : never;
};
type PromisifiedParam<T extends {
    onSuccess?: DefaultEventHandler;
    onFailure?: DefaultErrorHandler;
}> = {
    [P in keyof T as P extends "onSuccess" | "onFailure" ? never : P]: T[P];
};
type MapParamErrorCallback<T extends PropertiesOfKind<"custom method">, U extends keyof LensCoreMethodFirstParam<T>> = MapErrorCallback<LensCoreMethodFirstParam<T>, U>;
type LensCoreMethodFirstParam<T extends PropertiesOfKind<"custom method">> = Parameters<LensCoreModule[T]>[0];
type MapErrorCallback<T, U extends keyof T> = {
    [P in keyof T]: P extends U ? (err: LensCoreError) => void : T[P];
};
/** @internal */
export type LensCore = LensCoreEnums & LensCoreSyncMethods & LensCorePromisifiedMethods & LensCoreCustomMethods & LensCoreErrorField;
/**
 * @internal
 */
export interface LensCoreErrorField {
    errors: Observable<LensCoreError>;
}
/**
 * Create wrapper around LensCore module which adds Promise interfaces to the methods.
 *
 * NOTE: We try to keep as close to the native LensCore module as possible.
 * Ideally when LensCore makes its interface Promises, we won't need this Proxy.
 *
 * @internal
 */
export declare const createLensCore: (lensCoreModule: LensCoreModule) => LensCore;
export {};
//# sourceMappingURL=lensCore.d.ts.map