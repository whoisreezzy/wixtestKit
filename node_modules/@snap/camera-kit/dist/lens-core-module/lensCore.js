import { Subject } from "rxjs";
import { wrapLensCoreError } from "./lensCoreError";
const promisifiableMethods = {
    addLens: null,
    clearAllLenses: null,
    imageToYuvBuffer: null,
    pauseCanvas: null,
    processAudioSampleBuffer: null,
    processFrame: null,
    removeLens: null,
    replaceLenses: null,
    setAudioParameters: null,
    setDeviceClass: null,
    setGpuIndex: null,
    setFPSLimit: null,
    setInputTransform: null,
    setOnFrameProcessedCallback: null,
    setRenderLoopMode: null,
    setRenderSize: null,
    teardown: null,
    useMediaElement: null,
    yuvBufferToBitmap: null,
};
function createErrorWrapper(isForFrameErrors, errors) {
    return (fn) => {
        return (nativeError) => {
            const error = wrapLensCoreError(nativeError, isForFrameErrors);
            fn(error);
            errors.next(error);
        };
    };
}
function withTryCatch(fn, errors) {
    return function (...args) {
        try {
            return fn.apply(this, args);
        }
        catch (e) {
            const error = wrapLensCoreError(e, false);
            errors.next(error);
            throw error;
        }
    };
}
const errorsFieldName = "errors";
export const createLensCore = (lensCoreModule) => {
    const errors = new Subject();
    const errorsObservable = errors.asObservable();
    const getRegularErrorWrapper = createErrorWrapper(false, errors);
    const getFrameErrorWrapper = createErrorWrapper(true, errors);
    const customMethods = {
        initialize(input) {
            return new Promise((onSuccess, onFailure) => {
                var _a;
                return lensCoreModule.initialize(Object.assign(Object.assign({}, input), { exceptionHandler: getFrameErrorWrapper((_a = input.exceptionHandler) !== null && _a !== void 0 ? _a : (() => { })), onSuccess, onFailure: getRegularErrorWrapper(onFailure) }));
            });
        },
        provideRemoteAssetsResponse(input) {
            var _a;
            return lensCoreModule.provideRemoteAssetsResponse(Object.assign(Object.assign({}, input), { onFailure: getRegularErrorWrapper((_a = input.onFailure) !== null && _a !== void 0 ? _a : (() => { })) }));
        },
        playCanvas(input) {
            return new Promise((onReady, onFailure) => {
                lensCoreModule.playCanvas(Object.assign(Object.assign({}, input), { onReady, onFailure: getRegularErrorWrapper(onFailure) }));
            });
        },
    };
    return new Proxy(lensCoreModule, {
        get: (target, property, receiver) => {
            if (property === errorsFieldName) {
                return errorsObservable;
            }
            if (property in customMethods) {
                return withTryCatch(customMethods[property], errors);
            }
            const targetProperty = Reflect.get(target, property, receiver);
            if (!targetProperty)
                return targetProperty;
            if (property in promisifiableMethods) {
                return withTryCatch(function (input) {
                    return new Promise((onSuccess, onFailure) => targetProperty(Object.assign(Object.assign({}, input), { onSuccess, onFailure: getRegularErrorWrapper(onFailure) })));
                }, errors);
            }
            if (typeof targetProperty === "function") {
                if ("values" in targetProperty) {
                    return targetProperty;
                }
                else {
                    return withTryCatch(targetProperty, errors);
                }
            }
            return targetProperty;
        },
    });
};
//# sourceMappingURL=lensCore.js.map