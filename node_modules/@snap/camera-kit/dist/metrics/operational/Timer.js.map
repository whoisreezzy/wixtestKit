{"version":3,"file":"Timer.js","sourceRoot":"","sources":["../../../src/metrics/operational/Timer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { MetricsClient } from \"../../clients/metricsClient\";\nimport { getTimeMs } from \"../../common/time\";\nimport type { OperationalMetric } from \"../../generated-proto/pb_schema/camera_kit/v3/operational_metrics\";\nimport type { JoinMetricNames, MetricDimensions } from \"./Metric\";\nimport { Metric, joinMetricNames, serializeMetricDimensions } from \"./Metric\";\n\ninterface Measure {\n    name: string;\n    duration: number;\n    dimensions: MetricDimensions;\n}\n\n/** @internal */\nexport type LatencyMetric = OperationalMetric & {\n    metric: Extract<OperationalMetric[\"metric\"], { $case: \"latencyMillis\" }>;\n};\n\n/** @internal */\nexport class Timer<Name extends string> extends Metric {\n    private readonly marks: Set<Timer<string>>;\n    private readonly measures: Set<Measure>;\n    private readonly startTime = getTimeMs();\n    private stopped = false;\n\n    constructor(readonly name: Name, dimensions: MetricDimensions = {}) {\n        super(name, dimensions);\n\n        this.marks = new Set();\n        this.measures = new Set();\n    }\n\n    /**\n     * Return all measures created by this Timer and any child timers.\n     */\n    getMeasures(): ReadonlyArray<Measure> {\n        return Array.from(this.measures.values()).concat(\n            ...Array.from(this.marks.values()).map((mark) => mark.getMeasures())\n        );\n    }\n\n    /**\n     * Create a child Timer, using this Timer's name as a prefix when naming the new Timer. Any measures made with the\n     * child Timer will be included when calling `getMeasures()` on this Timer, or when calling `toOperationalMetric`\n     * on this Timer.\n     *\n     * @example\n     * ```ts\n     * const parent = new Timer('parent')\n     * const child = parent.mark('child') // child metric name is parent_child.\n     *\n     * child.measure()\n     * const measures = parent.getMeasures() // has one element.\n     * ```\n     *\n     * @param name\n     * @param dimensions If omitted, the child timer will NOT inherit dimensions from the parent -- if the child timer\n     * should re-use the parent's dimensions, this must be done explicitly by passing the parent's dimensions as an\n     * argument here.\n     * @returns A child Timer.\n     */\n    mark<MarkName extends string>(\n        name: MarkName,\n        dimensions: MetricDimensions = {}\n    ): Timer<JoinMetricNames<Name, MarkName>> {\n        const mark = new Timer(joinMetricNames([this.name, name]) as JoinMetricNames<Name, MarkName>, dimensions);\n        if (this.stopped) mark.stop();\n        this.marks.add(mark);\n        return mark;\n    }\n\n    /**\n     * Measure the time (in milliseconds) since this Timer was created.\n     *\n     * If a name is provided, the measure's name will be prefixed with the name of this Timer. Otherwise the name of\n     * the measure will be the name of this Timer.\n     *\n     * @example\n     * ```ts\n     * const timer = new Timer('a')\n     * timer.measure('b')\n     * const measures = timer.getMeasures()\n     * // measure[0].name === 'a_b'\n     * ```\n     *\n     * @param name\n     * @returns\n     */\n    measure(): Measure | undefined;\n    measure(dimensions: MetricDimensions): Measure | undefined;\n    measure(name: string): Measure | undefined;\n    measure(name: string, dimensions: MetricDimensions): Measure | undefined;\n    measure(nameOrDimensions?: string | MetricDimensions, maybeDimensions?: MetricDimensions): Measure | undefined {\n        if (this.stopped) return undefined;\n        const name = typeof nameOrDimensions === \"string\" ? nameOrDimensions : \"\";\n        const dimensions = typeof nameOrDimensions === \"string\" ? maybeDimensions : nameOrDimensions;\n\n        const fullName = joinMetricNames([this.name, name]);\n        const measure: Measure = {\n            name: fullName,\n            duration: getTimeMs() - this.startTime,\n            dimensions: dimensions ?? this.dimensions,\n        };\n        this.measures.add(measure);\n        return measure;\n    }\n\n    /**\n     * Remove all measures from this Timer and any child timers previously created by calls to `mark()`.\n     */\n    clear(): void {\n        this.measures.clear();\n        this.marks.forEach((mark) => mark.clear());\n    }\n\n    /**\n     * Prevent any future measures from being created by this Timer or any child timers.\n     */\n    stop(): void {\n        this.stopped = true;\n        this.marks.forEach((mark) => mark.stop());\n    }\n\n    /**\n     * Report this metric using {@link MetricsClient}.\n     *\n     * After reporting, the Timer can longer be used. Its internal state is cleared and cannot be updated. Calling this\n     * method a second time will no-op.\n     *\n     * @param reporter All measurements will be reported using the given reporter.\n     */\n    async stopAndReport(client: MetricsClient): Promise<void> {\n        client.setOperationalMetrics(this);\n        this.stop();\n        this.clear();\n    }\n\n    /**\n     * Convert all measures from this Timer and from any child timers into an array of {@link OperationalMetric}\n     * objects, which can be sent to the backend.\n     *\n     * @returns\n     */\n    toOperationalMetric(): LatencyMetric[] {\n        const timestamp = new Date();\n        return this.getMeasures().map((measure) => ({\n            name: `${measure.name}${serializeMetricDimensions(measure.dimensions)}`,\n            timestamp,\n            metric: {\n                $case: \"latencyMillis\",\n                latencyMillis: `${Math.ceil(measure.duration)}`,\n            },\n        }));\n    }\n}\n"]}