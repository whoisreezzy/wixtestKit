import { __awaiter } from "tslib";
import { getTimeMs } from "../../common/time";
import { Metric, joinMetricNames, serializeMetricDimensions } from "./Metric";
export class Timer extends Metric {
    constructor(name, dimensions = {}) {
        super(name, dimensions);
        this.name = name;
        this.startTime = getTimeMs();
        this.stopped = false;
        this.marks = new Set();
        this.measures = new Set();
    }
    getMeasures() {
        return Array.from(this.measures.values()).concat(...Array.from(this.marks.values()).map((mark) => mark.getMeasures()));
    }
    mark(name, dimensions = {}) {
        const mark = new Timer(joinMetricNames([this.name, name]), dimensions);
        if (this.stopped)
            mark.stop();
        this.marks.add(mark);
        return mark;
    }
    measure(nameOrDimensions, maybeDimensions) {
        if (this.stopped)
            return undefined;
        const name = typeof nameOrDimensions === "string" ? nameOrDimensions : "";
        const dimensions = typeof nameOrDimensions === "string" ? maybeDimensions : nameOrDimensions;
        const fullName = joinMetricNames([this.name, name]);
        const measure = {
            name: fullName,
            duration: getTimeMs() - this.startTime,
            dimensions: dimensions !== null && dimensions !== void 0 ? dimensions : this.dimensions,
        };
        this.measures.add(measure);
        return measure;
    }
    clear() {
        this.measures.clear();
        this.marks.forEach((mark) => mark.clear());
    }
    stop() {
        this.stopped = true;
        this.marks.forEach((mark) => mark.stop());
    }
    stopAndReport(client) {
        return __awaiter(this, void 0, void 0, function* () {
            client.setOperationalMetrics(this);
            this.stop();
            this.clear();
        });
    }
    toOperationalMetric() {
        const timestamp = new Date();
        return this.getMeasures().map((measure) => ({
            name: `${measure.name}${serializeMetricDimensions(measure.dimensions)}`,
            timestamp,
            metric: {
                $case: "latencyMillis",
                latencyMillis: `${Math.ceil(measure.duration)}`,
            },
        }));
    }
}
//# sourceMappingURL=Timer.js.map