{"version":3,"file":"Count.js","sourceRoot":"","sources":["../../../src/metrics/operational/Count.ts"],"names":[],"mappings":"AAEA,OAAO,EAAE,MAAM,EAAE,yBAAyB,EAAE,MAAM,UAAU,CAAC;AAQ7D,MAAM,UAAU,aAAa,CAAC,KAAwB;;IAClD,OAAO,CAAA,MAAA,KAAK,CAAC,MAAM,0CAAE,KAAK,MAAK,OAAO,CAAC;AAC3C,CAAC;AAGD,MAAM,OAAO,KAAM,SAAQ,MAAM;IAC7B,MAAM,CAAC,KAAK,CAAC,IAAY,EAAE,CAAS,EAAE,aAA+B,EAAE;QACnE,MAAM,KAAK,GAAG,IAAI,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QAC1C,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QACnB,OAAO,KAAK,CAAC;IACjB,CAAC;IAID,YAAqB,IAAY,EAAE,aAA+B,EAAE;QAChE,KAAK,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;QADP,SAAI,GAAJ,IAAI,CAAQ;QAFzB,UAAK,GAAG,CAAC,CAAC;IAIlB,CAAC;IAED,SAAS,CAAC,KAAa;QACnB,IAAI,CAAC,KAAK,IAAI,KAAK,CAAC;QACpB,OAAO,IAAI,CAAC,KAAK,CAAC;IACtB,CAAC;IAED,mBAAmB;QACf,OAAO;YACH;gBACI,IAAI,EAAE,GAAG,IAAI,CAAC,IAAI,GAAG,yBAAyB,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE;gBACjE,SAAS,EAAE,IAAI,IAAI,EAAE;gBACrB,MAAM,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,EAAE;aAChE;SACJ,CAAC;IACN,CAAC;CACJ","sourcesContent":["import type { OperationalMetric } from \"../../generated-proto/pb_schema/camera_kit/v3/operational_metrics\";\nimport type { MetricDimensions } from \"./Metric\";\nimport { Metric, serializeMetricDimensions } from \"./Metric\";\n\n/** @internal */\nexport type CountMetric = OperationalMetric & {\n    metric: Extract<OperationalMetric[\"metric\"], { $case: \"count\" }>;\n};\n\n/** @internal */\nexport function isCountMetric(value: OperationalMetric): value is CountMetric {\n    return value.metric?.$case === \"count\";\n}\n\n/** @internal */\nexport class Count extends Metric {\n    static count(name: string, n: number, dimensions: MetricDimensions = {}): Count {\n        const count = new Count(name, dimensions);\n        count.increment(n);\n        return count;\n    }\n\n    private count = 0;\n\n    constructor(readonly name: string, dimensions: MetricDimensions = {}) {\n        super(name, dimensions);\n    }\n\n    increment(count: number): number {\n        this.count += count;\n        return this.count;\n    }\n\n    toOperationalMetric(): CountMetric[] {\n        return [\n            {\n                name: `${this.name}${serializeMetricDimensions(this.dimensions)}`,\n                timestamp: new Date(),\n                metric: { $case: \"count\", count: `${Math.ceil(this.count)}` },\n            },\n        ];\n    }\n}\n"]}