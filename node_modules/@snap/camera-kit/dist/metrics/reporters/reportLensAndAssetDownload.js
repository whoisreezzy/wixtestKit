import { Injectable } from "@snap/ts-inject";
import { metricsClientFactory } from "../../clients/metricsClient";
import { assertUnreachable } from "../../common/assertions";
import { stringifyError } from "../../common/errorHelpers";
import { scan } from "../../events/scan";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { requestStateEventTargetFactory } from "../../handlers/requestStateEmittingHandler";
import { metricsEventTargetFactory } from "../metricsEventTarget";
import { Count } from "../operational/Count";
const relevantRequestTypes = ["lens_content", "asset"];
export const isLensOrAssetRequest = (value) => {
    const requestType = value["requestType"];
    return typeof requestType === "string" && relevantRequestTypes.includes(requestType);
};
export const reportLensAndAssetDownload = Injectable("reportLensAndAssetDownload", [metricsEventTargetFactory.token, metricsClientFactory.token, requestStateEventTargetFactory.token], (metricsEventTarget, metrics, requestStateEventTarget) => {
    scan({ name: "inProgress", inProgress: new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
        var _a;
        const { inProgress } = state;
        const { dimensions, requestId } = event.detail;
        if (!isLensOrAssetRequest(dimensions))
            return state;
        switch (event.type) {
            case "started":
                const timer = event.detail.timer;
                inProgress.set(requestId, { timer });
                return { name: "inProgress", inProgress };
            case "completed":
                const completedRequest = inProgress.get(requestId);
                if (!completedRequest)
                    return state;
                inProgress.delete(requestId);
                const { duration } = (_a = completedRequest.timer.measure()) !== null && _a !== void 0 ? _a : { duration: 0 };
                const downloadTimeSec = duration / 1000;
                const { sizeByte } = event.detail;
                switch (dimensions.requestType) {
                    case "lens_content":
                        return {
                            name: "completed",
                            inProgress,
                            event: new TypedCustomEvent("lensDownload", {
                                name: "lensDownload",
                                lensId: dimensions.lensId,
                                automaticDownload: false,
                                sizeByte: `${Math.ceil(sizeByte)}`,
                                downloadTimeSec,
                            }),
                        };
                    case "asset":
                        return {
                            name: "completed",
                            inProgress,
                            event: new TypedCustomEvent("assetDownload", {
                                name: "assetDownload",
                                assetId: dimensions.assetId,
                                automaticDownload: false,
                                sizeByte: `${Math.ceil(sizeByte)}`,
                                downloadTimeSec,
                            }),
                        };
                    default:
                        assertUnreachable(dimensions);
                }
            case "errored":
                const erroredRequest = inProgress.get(requestId);
                if (!erroredRequest)
                    return state;
                inProgress.delete(requestId);
                const error = event.detail.error;
                return {
                    name: "completed",
                    inProgress,
                    event: new TypedCustomEvent("exception", {
                        name: "exception",
                        lensId: dimensions.lensId,
                        type: dimensions.requestType === "lens_content" ? "lens" : "asset",
                        reason: stringifyError(error),
                    }),
                };
            default:
                assertUnreachable(event);
        }
    }).addEventListener("state", ({ detail: state }) => {
        if (state.name !== "completed")
            return;
        metricsEventTarget.dispatchEvent(state.event);
        if (state.event.detail.name === "exception") {
            metrics.setOperationalMetrics(Count.count("handled_exception", 1, { type: state.event.detail.type }));
        }
    });
});
//# sourceMappingURL=reportLensAndAssetDownload.js.map