import { __awaiter } from "tslib";
import { combineLatestWith, filter, from, map, merge, mergeMap, of, raceWith, switchMap, take, takeUntil } from "rxjs";
import { forActions, inStates, isState } from "@snap/state-management";
import { Injectable } from "@snap/ts-inject";
import { TypedCustomEvent } from "../../events/TypedCustomEvent";
import { metricsEventTargetFactory } from "../metricsEventTarget";
import { cameraKitSessionFactory } from "../../session/CameraKitSession";
import { getTimeMs } from "../../common/time";
import { configurationToken } from "../../configuration";
import { lensStateFactory } from "../../session/lensState";
import { sessionStateFactory } from "../../session/sessionState";
import { Histogram } from "../operational/Histogram";
import { IndexedDBPersistence } from "../../persistence/IndexedDBPersistence";
import { ExpiringPersistence } from "../../persistence/ExpiringPersistence";
import { dayFormatter, monthFormatter } from "../../common/date";
import { metricsClientFactory } from "../../clients/metricsClient";
const viewTimeThresholdSec = 0.1;
function isFirstTimeWithinPeriods(lensId, persistence) {
    return __awaiter(this, void 0, void 0, function* () {
        let isLensFirstWithinDay = false;
        let isLensFirstWithinMonth = false;
        try {
            const lensLastViewDate = yield persistence.retrieve(lensId);
            const currentDate = new Date();
            if (!lensLastViewDate) {
                isLensFirstWithinDay = true;
                isLensFirstWithinMonth = true;
            }
            else {
                isLensFirstWithinDay = dayFormatter.format(lensLastViewDate) !== dayFormatter.format(currentDate);
                isLensFirstWithinMonth = monthFormatter.format(lensLastViewDate) !== monthFormatter.format(currentDate);
            }
            yield persistence.store(lensId, currentDate);
        }
        catch (error) {
            console.error(`Error handling persistence for lensId ${lensId}: ${error}`);
            isLensFirstWithinDay = false;
            isLensFirstWithinMonth = false;
        }
        return { isLensFirstWithinDay, isLensFirstWithinMonth };
    });
}
export const reportLensView = Injectable("reportLensView", [
    cameraKitSessionFactory.token,
    lensStateFactory.token,
    sessionStateFactory.token,
    metricsEventTargetFactory.token,
    metricsClientFactory.token,
    configurationToken,
], (session, lensState, sessionState, metricsEventTarget, metrics, configuration) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { cluster: performanceCluster, webglRendererInfo } = (_a = (yield configuration.lensPerformance)) !== null && _a !== void 0 ? _a : {
        cluster: 0,
        webglRendererInfo: "unknown",
    };
    const lensViewPersistence = new ExpiringPersistence(() => 60 * 24 * 60 * 60, new IndexedDBPersistence({ databaseName: "recentLensViews" }));
    merge(lensState.events.pipe(forActions("downloadComplete"), map(([a]) => a.data)), lensState.events.pipe(inStates("lensApplied"), switchMap(([, s]) => sessionState.events.pipe(forActions("resume"), takeUntil(lensState.events.pipe(forActions("removeLens"))), map(() => s.data)))))
        .pipe(map((lens) => [getTimeMs(), lens.id, lens.groupId]), mergeMap(([applyLensStartTime, lensId, lensGroupId]) => {
        const alreadyOn = isState(lensState.getState(), "lensApplied");
        const applyDelay = alreadyOn
            ? of(0)
            : lensState.events.pipe(forActions("resourcesLoaded"), filter(([a]) => a.data.id === lensId), take(1), map(() => (getTimeMs() - applyLensStartTime) / 1000));
        const viewMetrics = (alreadyOn
            ? of([getTimeMs(), session.metrics.beginMeasurement()])
            : lensState.events.pipe(forActions("turnedOn"), filter(([a]) => a.data.id === lensId), map(() => [getTimeMs(), session.metrics.beginMeasurement()]))).pipe(take(1), mergeMap(([lensTurnedOnTime, metricsMeasurement]) => lensState.events.pipe(forActions("turnedOff"), filter(([a]) => a.data.id === lensId), raceWith(sessionState.events.pipe(forActions("suspend"))), map(() => {
            metricsMeasurement.end();
            return Object.assign({ viewTimeSec: (getTimeMs() - lensTurnedOnTime) / 1000 }, metricsMeasurement.measure());
        }))));
        return applyDelay.pipe(combineLatestWith(viewMetrics, from(isFirstTimeWithinPeriods(lensId, lensViewPersistence))), takeUntil(lensState.events.pipe(forActions("turnedOn"), filter(([a]) => a.data.id !== lensId))), take(1), map(([applyDelaySec, viewMetrics, isFirstTimeResults]) => (Object.assign(Object.assign({ applyDelaySec,
            lensId,
            lensGroupId }, viewMetrics), isFirstTimeResults))));
    }))
        .subscribe({
        next: ({ applyDelaySec, lensId, lensGroupId, viewTimeSec, avgFps, lensFrameProcessingTimeMsAvg, lensFrameProcessingTimeMsStd, lensFrameProcessingTimeMsMedian, lensFrameProcessingN, isLensFirstWithinDay, isLensFirstWithinMonth, }) => __awaiter(void 0, void 0, void 0, function* () {
            if (viewTimeSec < viewTimeThresholdSec)
                return;
            const lensView = {
                name: "lensView",
                applyDelaySec,
                avgFps,
                lensId,
                lensGroupId,
                lensFrameProcessingTimeMsAvg,
                lensFrameProcessingTimeMsStd,
                recordingTimeSec: 0,
                viewTimeSec,
                isLensFirstWithinDay,
                isLensFirstWithinMonth,
                performanceCluster: `${performanceCluster}`,
                webglRendererInfo,
            };
            metricsEventTarget.dispatchEvent(new TypedCustomEvent("lensView", lensView));
            metrics.setOperationalMetrics(Histogram.level("lens_view", viewTimeSec * 1000));
            if (lensFrameProcessingN >= 30) {
                metrics.setOperationalMetrics(Histogram.level("lens_view_frame-processing-time", lensFrameProcessingTimeMsMedian, {
                    performance_cluster: performanceCluster.toString(),
                }));
            }
        }),
    });
}));
//# sourceMappingURL=reportLensView.js.map