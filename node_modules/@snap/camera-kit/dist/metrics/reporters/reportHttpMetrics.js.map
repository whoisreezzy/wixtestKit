{"version":3,"file":"reportHttpMetrics.js","sourceRoot":"","sources":["../../../src/metrics/reporters/reportHttpMetrics.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from \"@snap/ts-inject\";\nimport { assertUnreachable } from \"../../common/assertions\";\nimport { scan } from \"../../events/scan\";\nimport type { CofDimensions } from \"../../remote-configuration/cofHandler\";\nimport { COF_REQUEST_TYPE } from \"../../remote-configuration/cofHandler\";\nimport type {\n    Dimensions,\n    RequestStateEventTarget,\n    RequestStateEvents,\n} from \"../../handlers/requestStateEmittingHandler\";\nimport { requestStateEventTargetFactory } from \"../../handlers/requestStateEmittingHandler\";\nimport { getPlatformInfo } from \"../../platform/platformInfo\";\nimport type { MetricsClient } from \"../../clients/metricsClient\";\nimport { metricsClientFactory } from \"../../clients/metricsClient\";\nimport { Count } from \"../operational/Count\";\nimport { Histogram } from \"../operational/Histogram\";\nimport type { Timer } from \"../operational/Timer\";\nimport {\n    LENS_CORE_JS_REQUEST_TYPE,\n    LENS_CORE_WASM_REQUEST_TYPE,\n    type LensCoreDownloadDimensions,\n} from \"../../lens-core-module/loader/lensCoreFactory\";\nimport { GRPC_CALL_REQUEST_TYPE, type GrpcRequestDimensions } from \"../../clients/grpcHandler\";\nimport type { AssetDownloadDimensions, LensDownloadDimensions } from \"./reportLensAndAssetDownload\";\n\ntype InProgressMap = Map<number, { timer: Timer<\"download_latency\"> }>;\ninterface InProgress {\n    name: \"inProgress\";\n    inProgress: InProgressMap;\n}\ninterface Completed {\n    name: \"completed\";\n    inProgress: InProgressMap;\n    dimensions: Record<string, string>;\n    timer: Timer<\"download_latency\">;\n    downloadSizeKb: number;\n}\ntype RequestState = InProgress | Completed;\n\ntype ReportableMetricDimensions =\n    | LensDownloadDimensions\n    | AssetDownloadDimensions\n    | CofDimensions\n    | LensCoreDownloadDimensions\n    | GrpcRequestDimensions;\n\nconst reportableMetricRequestTypes: ReportableMetricDimensions[\"requestType\"][] = [\n    \"asset\",\n    \"lens_content\",\n    LENS_CORE_JS_REQUEST_TYPE,\n    LENS_CORE_WASM_REQUEST_TYPE,\n    COF_REQUEST_TYPE,\n    GRPC_CALL_REQUEST_TYPE,\n];\n\nconst getAdditionalDimensions = (dimensions: ReportableMetricDimensions): [string, string][] => {\n    switch (dimensions.requestType) {\n        case COF_REQUEST_TYPE:\n            return [[\"delta\", dimensions.delta]];\n        case GRPC_CALL_REQUEST_TYPE:\n            return [[\"method\", dimensions.methodName]];\n        case LENS_CORE_JS_REQUEST_TYPE:\n        case LENS_CORE_WASM_REQUEST_TYPE:\n            return [[\"custom\", dimensions.customBuild]];\n        default:\n            return [];\n    }\n};\n\nconst getContentType = (dimensions: ReportableMetricDimensions): string => {\n    if (dimensions.requestType === \"asset\") {\n        return dimensions.assetType;\n    }\n    return dimensions.requestType;\n};\n\nconst getSizeKb = (event: RequestStateEvents): number => {\n    switch (event.type) {\n        case \"started\":\n        case \"errored\":\n            return 0;\n        case \"completed\":\n            return event.detail.sizeByte / 1024;\n        default:\n            assertUnreachable(event);\n    }\n};\n\nconst getStatus = (event: RequestStateEvents): string => {\n    switch (event.type) {\n        case \"started\":\n        case \"errored\":\n            // We'll use status 0 to indicate that an exception occurred during the request. This is somewhat in keeping\n            // with browsers that set the response status to 0 if the request was not able to be made (e.g. CORs\n            // preflight failed, or the user canceled the request).\n            return \"0\";\n        case \"completed\":\n            return event.detail.status.toString();\n        default:\n            assertUnreachable(event);\n    }\n};\n\nexport const isRelevantRequest = (value: Dimensions): value is ReportableMetricDimensions => {\n    const reportableMetricDimensions = value as ReportableMetricDimensions;\n    return reportableMetricRequestTypes.includes(reportableMetricDimensions.requestType);\n};\n\nexport const reportHttpMetrics = Injectable(\n    \"reportHttpMetrics\",\n    [metricsClientFactory.token, requestStateEventTargetFactory.token] as const,\n    (metrics: MetricsClient, requestStateEventTarget: RequestStateEventTarget) => {\n        scan<RequestState>({ name: \"inProgress\", inProgress: new Map() })(\n            requestStateEventTarget,\n            [\"started\", \"completed\", \"errored\"],\n            (state, event) => {\n                const { inProgress } = state;\n                const { dimensions, requestId } = event.detail;\n\n                if (!isRelevantRequest(dimensions)) return state;\n\n                switch (event.type) {\n                    case \"started\":\n                        const timer = event.detail.timer;\n                        inProgress.set(requestId, { timer });\n                        return { name: \"inProgress\", inProgress };\n                    case \"completed\":\n                    case \"errored\":\n                        const completedRequest = inProgress.get(requestId);\n                        if (!completedRequest) return state;\n                        inProgress.delete(requestId);\n\n                        const downloadSizeKb = getSizeKb(event);\n                        const status = getStatus(event);\n                        const operationalDimensions: Record<string, string> = {\n                            content_type: getContentType(dimensions),\n                            network_type: getPlatformInfo().connectionType ?? \"unknown\",\n                            status,\n                        };\n\n                        for (const [key, value] of getAdditionalDimensions(dimensions)) {\n                            operationalDimensions[key] = value;\n                        }\n\n                        completedRequest.timer.measure(operationalDimensions);\n\n                        return {\n                            name: \"completed\",\n                            inProgress: state.inProgress,\n                            dimensions: operationalDimensions,\n                            downloadSizeKb,\n                            timer: completedRequest.timer,\n                        };\n                    default:\n                        assertUnreachable(event);\n                }\n            }\n        ).addEventListener(\"state\", ({ detail: state }) => {\n            if (state.name !== \"completed\") return;\n\n            const { dimensions, timer, downloadSizeKb } = state;\n\n            metrics.setOperationalMetrics(Count.count(\"download_finished\", 1, dimensions));\n            metrics.setOperationalMetrics(Histogram.level(\"download_size_kb\", downloadSizeKb, dimensions));\n            metrics.setOperationalMetrics(timer);\n        });\n    }\n);\n"]}