import { Injectable } from "@snap/ts-inject";
import { assertUnreachable } from "../../common/assertions";
import { scan } from "../../events/scan";
import { COF_REQUEST_TYPE } from "../../remote-configuration/cofHandler";
import { requestStateEventTargetFactory } from "../../handlers/requestStateEmittingHandler";
import { getPlatformInfo } from "../../platform/platformInfo";
import { metricsClientFactory } from "../../clients/metricsClient";
import { Count } from "../operational/Count";
import { Histogram } from "../operational/Histogram";
import { LENS_CORE_JS_REQUEST_TYPE, LENS_CORE_WASM_REQUEST_TYPE, } from "../../lens-core-module/loader/lensCoreFactory";
import { GRPC_CALL_REQUEST_TYPE } from "../../clients/grpcHandler";
const reportableMetricRequestTypes = [
    "asset",
    "lens_content",
    LENS_CORE_JS_REQUEST_TYPE,
    LENS_CORE_WASM_REQUEST_TYPE,
    COF_REQUEST_TYPE,
    GRPC_CALL_REQUEST_TYPE,
];
const getAdditionalDimensions = (dimensions) => {
    switch (dimensions.requestType) {
        case COF_REQUEST_TYPE:
            return [["delta", dimensions.delta]];
        case GRPC_CALL_REQUEST_TYPE:
            return [["method", dimensions.methodName]];
        case LENS_CORE_JS_REQUEST_TYPE:
        case LENS_CORE_WASM_REQUEST_TYPE:
            return [["custom", dimensions.customBuild]];
        default:
            return [];
    }
};
const getContentType = (dimensions) => {
    if (dimensions.requestType === "asset") {
        return dimensions.assetType;
    }
    return dimensions.requestType;
};
const getSizeKb = (event) => {
    switch (event.type) {
        case "started":
        case "errored":
            return 0;
        case "completed":
            return event.detail.sizeByte / 1024;
        default:
            assertUnreachable(event);
    }
};
const getStatus = (event) => {
    switch (event.type) {
        case "started":
        case "errored":
            return "0";
        case "completed":
            return event.detail.status.toString();
        default:
            assertUnreachable(event);
    }
};
export const isRelevantRequest = (value) => {
    const reportableMetricDimensions = value;
    return reportableMetricRequestTypes.includes(reportableMetricDimensions.requestType);
};
export const reportHttpMetrics = Injectable("reportHttpMetrics", [metricsClientFactory.token, requestStateEventTargetFactory.token], (metrics, requestStateEventTarget) => {
    scan({ name: "inProgress", inProgress: new Map() })(requestStateEventTarget, ["started", "completed", "errored"], (state, event) => {
        var _a;
        const { inProgress } = state;
        const { dimensions, requestId } = event.detail;
        if (!isRelevantRequest(dimensions))
            return state;
        switch (event.type) {
            case "started":
                const timer = event.detail.timer;
                inProgress.set(requestId, { timer });
                return { name: "inProgress", inProgress };
            case "completed":
            case "errored":
                const completedRequest = inProgress.get(requestId);
                if (!completedRequest)
                    return state;
                inProgress.delete(requestId);
                const downloadSizeKb = getSizeKb(event);
                const status = getStatus(event);
                const operationalDimensions = {
                    content_type: getContentType(dimensions),
                    network_type: (_a = getPlatformInfo().connectionType) !== null && _a !== void 0 ? _a : "unknown",
                    status,
                };
                for (const [key, value] of getAdditionalDimensions(dimensions)) {
                    operationalDimensions[key] = value;
                }
                completedRequest.timer.measure(operationalDimensions);
                return {
                    name: "completed",
                    inProgress: state.inProgress,
                    dimensions: operationalDimensions,
                    downloadSizeKb,
                    timer: completedRequest.timer,
                };
            default:
                assertUnreachable(event);
        }
    }).addEventListener("state", ({ detail: state }) => {
        if (state.name !== "completed")
            return;
        const { dimensions, timer, downloadSizeKb } = state;
        metrics.setOperationalMetrics(Count.count("download_finished", 1, dimensions));
        metrics.setOperationalMetrics(Histogram.level("download_size_kb", downloadSizeKb, dimensions));
        metrics.setOperationalMetrics(timer);
    });
});
//# sourceMappingURL=reportHttpMetrics.js.map