import { __awaiter, __esDecorate, __runInitializers } from "tslib";
import { CONTAINER, Injectable } from "@snap/ts-inject";
import { firstValueFrom } from "rxjs";
import { lensRepositoryFactory } from "./lens/LensRepository";
import { cameraKitSessionFactory } from "./session/CameraKitSession";
import { registerLensAssetsProvider } from "./lens/assets/LensAssetsProvider";
import { lensCoreFactory } from "./lens-core-module/loader/lensCoreFactory";
import { configurationToken } from "./configuration";
import { registerUriHandlers } from "./uri-handlers/uriHandlersRegister";
import { metricsEventTargetFactory } from "./metrics/metricsEventTarget";
import { reportSessionScopedMetrics } from "./metrics/reporters/reporters";
import { lensStateFactory } from "./session/lensState";
import { lensKeyboardFactory } from "./session/LensKeyboard";
import { registerLensClientInterfaceHandler } from "./lens-client-interface/lensClientInterface";
import { sessionStateFactory } from "./session/sessionState";
import { lensExecutionError, lensAbortError } from "./namedErrors";
import { getLogger, resetLogger } from "./logger/logger";
import { errorLoggingDecorator } from "./logger/errorLoggingDecorator";
import { TypedEventTarget } from "./events/TypedEventTarget";
import { pageVisibilityFactory } from "./common/pageVisibility";
import { setPreloadedConfiguration } from "./remote-configuration/preloadConfiguration";
import { remoteConfigurationFactory } from "./remote-configuration/remoteConfiguration";
import { registerGeoDataProvider } from "./geo/registerGeoDataProvider";
const logger = getLogger("CameraKit");
const publicMetricsEventNames = ["lensView", "lensWait"];
export let CameraKit = (() => {
    var _a;
    let _instanceExtraInitializers = [];
    let _createSession_decorators;
    let _destroy_decorators;
    return _a = class CameraKit {
            constructor(lensRepository, lensCore, pageVisibility, container, remoteConfig, allMetrics) {
                this.lensRepository = (__runInitializers(this, _instanceExtraInitializers), lensRepository);
                this.lensCore = lensCore;
                this.pageVisibility = pageVisibility;
                this.container = container;
                this.remoteConfig = remoteConfig;
                this.metrics = new TypedEventTarget();
                this.sessions = [];
                this.lenses = { repository: this.lensRepository };
                publicMetricsEventNames.forEach((eventName) => {
                    allMetrics.addEventListener(eventName, (e) => this.metrics.dispatchEvent(e));
                });
            }
            createSession({ liveRenderTarget, renderWhileTabHidden, } = {}) {
                return __awaiter(this, void 0, void 0, function* () {
                    const exceptionHandler = (error) => {
                        if (error.name === "LensCoreAbortError") {
                            logger.error(lensAbortError("Unrecoverable error occurred during lens execution. " +
                                "The CameraKitSession will be destroyed.", error));
                        }
                        else {
                            logger.error(lensExecutionError("Error occurred during lens execution. " +
                                "The lens cannot be rendered and will be removed from the CameraKitSession.", error));
                        }
                    };
                    const config = this.container.get(configurationToken);
                    yield this.lensCore.initialize({
                        canvas: liveRenderTarget,
                        shouldUseWorker: !renderWhileTabHidden && config.shouldUseWorker,
                        exceptionHandler,
                    });
                    if (this.lensCore.setGpuIndex) {
                        try {
                            yield this.lensCore.setGpuIndex({
                                gpuIndex: yield firstValueFrom(this.remoteConfig.getGpuIndexConfig()),
                            });
                        }
                        catch (cause) {
                            logger.error(new Error("Cannot set GPU index.", { cause }));
                        }
                    }
                    if (config.fonts.length > 0) {
                        this.lensCore.setSystemFonts({
                            fonts: config.fonts,
                        });
                    }
                    yield this.lensCore.setRenderLoopMode({
                        mode: renderWhileTabHidden
                            ? this.lensCore.RenderLoopMode.SetTimeout
                            : this.lensCore.RenderLoopMode.RequestAnimationFrame,
                    });
                    const sessionContainer = this.container
                        .copy()
                        .provides(sessionStateFactory)
                        .provides(lensStateFactory)
                        .provides(lensKeyboardFactory)
                        .provides(cameraKitSessionFactory)
                        .run(registerLensAssetsProvider)
                        .run(registerLensClientInterfaceHandler)
                        .run(registerGeoDataProvider)
                        .run(setPreloadedConfiguration)
                        .run(reportSessionScopedMetrics)
                        .run(registerUriHandlers);
                    const session = sessionContainer.get(cameraKitSessionFactory.token);
                    this.sessions.push(session);
                    return session;
                });
            }
            destroy() {
                return __awaiter(this, void 0, void 0, function* () {
                    resetLogger();
                    this.pageVisibility.destroy();
                    yield Promise.all(this.sessions.map((session) => session.destroy()));
                    this.sessions = [];
                });
            }
        },
        (() => {
            _createSession_decorators = [errorLoggingDecorator(logger)];
            _destroy_decorators = [errorLoggingDecorator(logger)];
            __esDecorate(_a, null, _createSession_decorators, { kind: "method", name: "createSession", static: false, private: false, access: { has: obj => "createSession" in obj, get: obj => obj.createSession } }, null, _instanceExtraInitializers);
            __esDecorate(_a, null, _destroy_decorators, { kind: "method", name: "destroy", static: false, private: false, access: { has: obj => "destroy" in obj, get: obj => obj.destroy } }, null, _instanceExtraInitializers);
        })(),
        _a;
})();
export const cameraKitFactory = Injectable("CameraKit", [
    lensRepositoryFactory.token,
    metricsEventTargetFactory.token,
    lensCoreFactory.token,
    pageVisibilityFactory.token,
    remoteConfigurationFactory.token,
    CONTAINER,
], (lensRepository, metrics, lensCore, pageVisibility, remoteConfiguration, container) => new CameraKit(lensRepository, lensCore, pageVisibility, container, remoteConfiguration, metrics));
//# sourceMappingURL=CameraKit.js.map