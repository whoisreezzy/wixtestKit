import { __awaiter } from "tslib";
import { Injectable } from "@snap/ts-inject";
import { lensAssetError } from "../../namedErrors";
import { getLogger } from "../../logger/logger";
import { toPublicLens } from "../Lens";
import { lensRepositoryFactory } from "../LensRepository";
import { lensStateFactory } from "../../session/lensState";
import { lensCoreFactory } from "../../lens-core-module/loader/lensCoreFactory";
import { lensAssetRepositoryFactory } from "./LensAssetRepository";
const logger = getLogger("LensAssetProvider");
const maxConsecutiveErrors = 3;
export const registerLensAssetsProvider = Injectable("registerLensAssetsProvider", [
    lensCoreFactory.token,
    lensRepositoryFactory.token,
    lensAssetRepositoryFactory.token,
    lensStateFactory.token,
], (lensCore, lensRepository, lensAssetRepository, lensState) => {
    const consecutiveErrorsPerAsset = new Map();
    lensCore.setRemoteAssetsProvider((assetDescriptor) => __awaiter(void 0, void 0, void 0, function* () {
        var _a, _b, _c, _d, _e;
        const { assetId, assetType, effectId } = assetDescriptor;
        try {
            if (((_a = consecutiveErrorsPerAsset.get(assetId)) !== null && _a !== void 0 ? _a : 0) > maxConsecutiveErrors) {
                throw new Error(`Maximum consecutive asset load errors reached for asset ${assetId}`);
            }
            const lensId = effectId !== null && effectId !== void 0 ? effectId : (_b = lensState.getState().data) === null || _b === void 0 ? void 0 : _b.id;
            const lens = lensId ? lensRepository.getLensMetadata(lensId) : undefined;
            yield lensAssetRepository.loadAsset({
                assetDescriptor,
                lens: lens && toPublicLens(lens),
                assetManifest: (_d = (_c = lens === null || lens === void 0 ? void 0 : lens.content) === null || _c === void 0 ? void 0 : _c.assetManifest) !== null && _d !== void 0 ? _d : [],
                lowPriority: false,
            });
            consecutiveErrorsPerAsset.set(assetId, 0);
        }
        catch (error) {
            lensCore.provideRemoteAssetsResponse({
                assetId,
                assetType,
            });
            const consecutiveErrors = ((_e = consecutiveErrorsPerAsset.get(assetId)) !== null && _e !== void 0 ? _e : 0) + 1;
            consecutiveErrorsPerAsset.set(assetId, consecutiveErrors);
            if (consecutiveErrors <= maxConsecutiveErrors) {
                logger.error(lensAssetError(`Error occurred while handling lens asset ${assetId} request.`, error));
            }
            else {
                logger.warn(`Maximum consecutive asset load errors reached for asset ${assetId}`);
            }
        }
    }));
});
//# sourceMappingURL=LensAssetsProvider.js.map