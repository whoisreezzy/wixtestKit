{"version":3,"file":"cameraKitLensSource.js","sourceRoot":"","sources":["../../src/lens/cameraKitLensSource.ts"],"names":[],"mappings":"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","sourcesContent":["import { catchError, firstValueFrom, map, of } from \"rxjs\";\nimport { BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport { Injectable } from \"@snap/ts-inject\";\nimport { Lens } from \"../generated-proto/pb_schema/camera_kit/v3/lens\";\nimport type { LensesClient } from \"../clients/lensesClient\";\nimport { lensesClientFactory } from \"../clients/lensesClient\";\nimport type { RemoteConfiguration } from \"../remote-configuration/remoteConfiguration\";\nimport { remoteConfigurationFactory } from \"../remote-configuration/remoteConfiguration\";\nimport type { ConfigResult } from \"../generated-proto/pb_schema/cdp/cof/config_result\";\nimport { getLogger } from \"../logger/logger\";\nimport type { LensSource } from \"./LensSource\";\nimport { lensSourcesFactory } from \"./LensSource\";\nimport { watermarksLensGroup } from \"./fetchWatermarkLens\";\n\nconst logger = getLogger(\"CameraKitLensSource\");\n\nconst hasAnyValue = (c: ConfigResult): c is ConfigResult & { value: { anyValue: { value: Uint8Array } } } => {\n    return c.value?.anyValue?.value instanceof Uint8Array;\n};\n\nconst defaultWatermarkLens = {\n    id: \"60515300902\",\n    name: \"Watermark\",\n    content: {\n        lnsSha256: \"3EDEAEBCD51A547FF4D1F5708FBD6F4D628AD736BEE07AB3844B14E6C69EC510\",\n        lnsUrlBolt:\n            \"https://bolt-gcdn.sc-cdn.net/3/L6uAe5Fhyg0ZFf3RLsCVZ?bo=EhgaABoAMgF9OgEEQgYIkbHPpgZIAlASYAE%3D&uc=18\",\n    },\n};\n/**\n * This LensSource loads lenses from the CameraKit backend service. It is meant to be used as the last LensSource in the\n * LensSource[] array used by LensRepository to load lenses.\n *\n * We ensure this is the case by providing cameraKitLensSourceFactory *after* the DI container has been modified by the\n * application during bootstrap -- this way we're guaranteed to place this LensSource after all other LensSources.\n *\n * @internal\n */\nexport const cameraKitLensSourceFactory = Injectable(\n    lensSourcesFactory.token,\n    [lensSourcesFactory.token, lensesClientFactory.token, remoteConfigurationFactory.token] as const,\n    (lensSources: LensSource[], lensesClient: LensesClient, remoteConfig: RemoteConfiguration): LensSource[] => [\n        // Watermark source goes always first not allowing apps to override it\n        {\n            isGroupOwner(groupId: string) {\n                return groupId === watermarksLensGroup;\n            },\n            async loadLens() {\n                const lensMessage = await firstValueFrom(\n                    remoteConfig.get(\"CAMERA_KIT_WATERMARK_LENS\").pipe(\n                        map((configResults) => {\n                            const lensMessage = configResults.find(hasAnyValue)?.value.anyValue.value;\n                            if (!lensMessage) throw new Error(\"Failed to read watermark Lens from COF response.\");\n                            return lensMessage;\n                        }),\n                        catchError((error) => {\n                            logger.error(error);\n                            return of(Lens.encode(Lens.fromPartial(defaultWatermarkLens)).finish());\n                        })\n                    )\n                );\n\n                return new BinaryWriter().uint32(10).bytes(lensMessage).finish();\n            },\n            async loadLensGroup() {\n                throw new Error(\"Not implemented.\");\n            },\n        },\n        // custom lens sources provided by apps\n        ...lensSources,\n        {\n            // This LensSource will claim ownership of all lens groups -- it should be used as the last element in a\n            // list of LensSources, as a catch-all to load any lens groups not claimed by other LensSources.\n            isGroupOwner(): boolean {\n                return true;\n            },\n\n            async loadLens(lensId: string, groupId: string): Promise<ArrayBuffer> {\n                const result = await lensesClient.getGroupLens({ lensId, groupId });\n                if (!result.ok) {\n                    const error = result.unwrapErr();\n                    throw new Error(\n                        `Cannot load lens lens ${lensId} from group ${groupId}. An error occured in the ` +\n                            `gRPC client:\\n\\t[${error.status}] ${error.statusMessage}`\n                    );\n                }\n                const response = result.unwrap();\n                if (!response.message?.lens) {\n                    throw new Error(\n                        `Cannot load lens ${lensId} from group ${groupId}. The response did not contain ` +\n                            `a lens.\\n\\t${JSON.stringify(result)} for requestId ${response.headers.get(\"x-request-id\")}`\n                    );\n                }\n                return Lens.encode(response.message.lens, new BinaryWriter().uint32(10).fork()).join().finish();\n            },\n\n            async loadLensGroup(groupId: string): Promise<ArrayBuffer> {\n                const result = await lensesClient.getGroup({ id: groupId });\n                if (!result.ok) {\n                    const error = result.unwrapErr();\n                    throw new Error(\n                        `Cannot load lens group ${groupId}. An error occurred in the gRPC client:\\n` +\n                            `\\t[${error.status}] ${error.statusMessage}`\n                    );\n                }\n                const response = result.unwrap();\n                if (!response.message?.lenses) {\n                    throw new Error(\n                        `Cannot load lens group ${groupId}. The response contained no lenses ` +\n                            `\\n\\t${JSON.stringify(response)} for requestId ${response.headers.get(\"x-request-id\")}`\n                    );\n                }\n                const writer = new BinaryWriter();\n                response.message.lenses.forEach((lens) => Lens.encode(lens, writer.uint32(10).fork()).join());\n                return writer.finish();\n            },\n        },\n    ]\n);\n"]}