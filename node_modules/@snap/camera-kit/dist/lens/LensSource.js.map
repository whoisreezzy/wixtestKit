{"version":3,"file":"LensSource.js","sourceRoot":"","sources":["../../src/lens/LensSource.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAC7C,OAAO,EAAE,QAAQ,EAAE,MAAM,mDAAmD,CAAC;AAkC7E,MAAM,CAAC,MAAM,kBAAkB,GAAG,UAAU,CAAC,aAAa,EAAE,GAAiB,EAAE,CAAC,EAAE,CAAC,CAAC;AAQpF,MAAM,UAAgB,qBAAqB,CAAC,OAAqB,EAAE,OAAe,EAAE,MAAe;;QAC/F,MAAM,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,CAAC;QACtE,IAAI,CAAC,MAAM,EAAE;YACT,MAAM,IAAI,KAAK,CACX,oBAAoB,MAAM,CAAC,CAAC,CAAC,GAAG,MAAM,QAAQ,CAAC,CAAC,CAAC,EAAE,SAAS,OAAO,IAAI;gBACnE,qDAAqD,CAC5D,CAAC;SACL;QACD,MAAM,QAAQ,GACV,MAAM,KAAK,SAAS,CAAC,CAAC,CAAC,MAAM,MAAM,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;QAExG,OAAO,QAAQ,YAAY,WAAW,IAAI,WAAW,CAAC,MAAM,CAAC,QAAQ,CAAC;YAClE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,QAAQ,YAAY,UAAU,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM;YAC9F,CAAC,CAAC,EAAE,CAAC;IACb,CAAC;CAAA","sourcesContent":["import { Injectable } from \"@snap/ts-inject\";\nimport { Envelope } from \"../generated-proto/pb_schema/camera_kit/v3/export\";\nimport type { Lens } from \"../generated-proto/pb_schema/camera_kit/v3/lens\";\n\n/**\n * Provides Lens metadata for one or more Lens groups.\n *\n * When a Lens or Lens group is requested via the {@link LensRepository}, CameraKit will find the LensSource which\n * claims ownership of that group. The appropriate LensSource method will be called and must return an ArrayBuffer\n * containing the encoded Lens metadata -- this can be obtained from a CameraKit backend API.\n */\nexport interface LensSource {\n    isGroupOwner(groupId: string): boolean;\n    loadLens(lensId: string, groupId: string): Promise<ArrayBuffer>;\n    loadLensGroup(groupId: string): Promise<ArrayBuffer>;\n}\n\n/**\n * By default, no custom {@link LensSource} is provided to CameraKit. But to enable certain advanced use-cases,\n * applications may provide their own {@link LensSource}.\n *\n * Perhaps the most convenient way to do this is with {@link ConcatInjectable}, as shown here:\n *\n * @example\n * ```ts\n * import { bootstrapCameraKit, lensSourcesFactory, LensSource } from '@snap/camera-kit'\n *\n * const cameraKit = bootstrapCameraKit(config, (container) => {\n *   return container.provides(ConcatInjectable(\n *     lensSourcesFactory.token,\n *     (): LensSource => { return ... }\n *   ))\n * })\n * ```\n */\nexport const lensSourcesFactory = Injectable(\"lensSources\", (): LensSource[] => []);\n\n/**\n * Given a list of LensSources (like the one provided by CameraKit's DI container under the `'lensSources'` token), and\n * a groupId/lensId, return a list of lenses loaded by the first LensSource claiming ownership of the given groupId.\n *\n * @internal\n */\nexport async function loadLensesFromSources(sources: LensSource[], groupId: string, lensId?: string): Promise<Lens[]> {\n    const source = sources.find((source) => source.isGroupOwner(groupId));\n    if (!source) {\n        throw new Error(\n            `Cannot load lens ${lensId ? `${lensId} from ` : \"\"}group ${groupId}. ` +\n                `No LensSource claimed ownership of that lens group.`\n        );\n    }\n    const envelope =\n        lensId === undefined ? await source.loadLensGroup(groupId) : await source.loadLens(lensId, groupId);\n\n    return envelope instanceof ArrayBuffer || ArrayBuffer.isView(envelope)\n        ? Envelope.decode(envelope instanceof Uint8Array ? envelope : new Uint8Array(envelope)).lenses\n        : [];\n}\n"]}