{"version":3,"file":"LensRepository.js","sourceRoot":"","sources":["../../src/lens/LensRepository.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from \"@snap/ts-inject\";\nimport { validate } from \"../common/validate\";\nimport { isArrayOfType, isSafeString, isSafeStringArray, isString, isUndefined } from \"../common/typeguards\";\nimport type { FetchHandler } from \"../handlers/defaultFetchHandler\";\nimport { defaultFetchHandlerFactory } from \"../handlers/defaultFetchHandler\";\nimport type { RequestStateEventTarget } from \"../handlers/requestStateEmittingHandler\";\nimport {\n    createRequestStateEmittingHandler,\n    requestStateEventTargetFactory,\n} from \"../handlers/requestStateEmittingHandler\";\nimport type { LensDownloadDimensions } from \"../metrics/reporters/reportLensAndAssetDownload\";\nimport type { Handler } from \"../handlers/HandlerChainBuilder\";\nimport { HandlerChainBuilder } from \"../handlers/HandlerChainBuilder\";\nimport { createArrayBufferParsingHandler } from \"../handlers/arrayBufferParsingHandler\";\nimport { LensAssetManifestItem_RequestTiming } from \"../generated-proto/pb_schema/camera_kit/v3/lens\";\nimport { getLogger } from \"../logger/logger\";\nimport { errorLoggingDecorator } from \"../logger/errorLoggingDecorator\";\nimport { ensureError } from \"../common/errorHelpers\";\nimport { withRequestPriority } from \"../handlers/utils\";\nimport type { EnumToPublicStringLiteralMap, ExcludeKeys } from \"../common/types\";\nimport type { Lens, LensProtoWithGroupId } from \"./Lens\";\nimport { isLensArray, toPublicLens } from \"./Lens\";\nimport type { LensAssetRepository } from \"./assets/LensAssetRepository\";\nimport { lensAssetRepositoryFactory } from \"./assets/LensAssetRepository\";\nimport type { LensSource } from \"./LensSource\";\nimport { loadLensesFromSources, lensSourcesFactory } from \"./LensSource\";\n\nconst logger = getLogger(\"LensRepository\");\n\ntype LensFetchHandler = Handler<\n    [RequestInfo, LensDownloadDimensions],\n    [ArrayBuffer, Response],\n    RequestInit | undefined\n>;\n\nconst assetTimingMap: ExcludeKeys<\n    EnumToPublicStringLiteralMap<typeof LensAssetManifestItem_RequestTiming>,\n    \"preloadUnset\" | \"unrecognized\"\n> = {\n    required: LensAssetManifestItem_RequestTiming.REQUIRED,\n    onDemand: LensAssetManifestItem_RequestTiming.ON_DEMAND,\n    // NOTE: This rule helps keep the public-facing AssetTiming type consistent with the proto.\n    // We prefer using a separate type for TypeDoc purposes.\n} satisfies Record<AssetTiming, LensAssetManifestItem_RequestTiming>;\n\nfunction isAssetTiming(value: unknown): value is AssetTiming {\n    return isString(value) && assetTimingMap.hasOwnProperty(value);\n}\n\nfunction isAssetTimingArrayOrUndefined(value: unknown): value is undefined | AssetTiming[] {\n    return isUndefined(value) || isArrayOfType(isAssetTiming, value);\n}\n\n/**\n * Lens assets are included in a manifest, and each will indicate when that asset will be used by the lens.\n *\n * Assets can have the following timing values:\n * - `required`: the lens will definitely request this asset immediately when the lens is applied.\n * - `onDemand`: the lens may request this asset at some time while the lens is applied.\n *\n * Depending on the use-case, an application may want to cache both required and onDemand assets for\n * a particular lens, or may decide to only cache required assets (or cache no assets).\n *\n * @category Lenses\n */\nexport type AssetTiming = \"required\" | \"onDemand\";\n\nexport interface LensBinary {\n    lensBuffer: ArrayBuffer;\n    lensChecksum: string;\n}\n\n/**\n * The LensRepository is used to query for lenses from specific lens groups, or for a lens with a specific ID.\n *\n * Lens groups are configured in the CameraKit Portal -- that's where you'll find lens group IDs and lens IDs.\n *\n * Lenses must be loaded by the LensRepository before they can be applied to a {@link CameraKitSession}.\n *\n * @example\n * ```ts\n * const cameraKit = await bootstrapCameraKit(options)\n * const session = await cameraKit.createSession()\n * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)\n * session.applyLens(lens)\n * ```\n *\n * @category Lenses\n */\nclass LensRepository {\n    private readonly metadataCache = new Map<string, LensProtoWithGroupId>();\n    private readonly binariesCache = new Map<string, ArrayBuffer>();\n\n    /** @internal */\n    constructor(\n        private readonly lensFetchHandler: LensFetchHandler,\n        private readonly lensSources: LensSource[],\n        private readonly lensAssetRepository: LensAssetRepository\n    ) {}\n\n    /**\n     * Retrieve a single Lens.\n     *\n     * @param lensId Desired Lens's unique ID. Can be found in the CameraKit Portal.\n     * @param groupId The ID of a group containing the desired Lens. Can be found in the CameraKit Portal.\n     * @returns Resolves with the desired Lens, or rejects if an error occurred (including a missing Lens).\n     */\n    @validate(isSafeString, isSafeString)\n    @errorLoggingDecorator(logger)\n    async loadLens(lensId: string, groupId: string): Promise<Lens> {\n        const lens = (await loadLensesFromSources(this.lensSources, groupId, lensId))[0];\n        if (!lens) {\n            throw new Error(`Cannot load lens. No lens with id ${lensId} was found in lens group ${groupId}.`);\n        }\n        const lensWithGroup: LensProtoWithGroupId = { ...lens, groupId };\n        this.metadataCache.set(lens.id, lensWithGroup);\n        return toPublicLens(lensWithGroup);\n    }\n\n    /**\n     * Retrieve the Lenses contained in a list of Lens Groups.\n     *\n     * This may result in multiple requests to retrieve Lens data (e.g. one per desired group). If any constituent\n     * requests fail, those errors will be reported in the response – but the returned Promise will not be rejected. Any\n     * Lenses which could be successfully retrieved will be available in the response.\n     *\n     * @param groupIds A list of Lens Group IDs. Can be found in the CameraKit Portal.\n     * @returns Resolves with a flattened list of all lenses in the desired groups. If any errors occurred during the\n     * query operation, these will be included in a separate list. If errors are present, the list of Lenses may not\n     * contain all the Lenses from the desired groups.\n     */\n    @validate(isSafeStringArray)\n    @errorLoggingDecorator(logger)\n    async loadLensGroups(groupIds: string[]): Promise<{\n        errors: Error[];\n        lenses: Lens[];\n    }> {\n        const responses = await Promise.all(\n            groupIds.map(async (groupId) => {\n                try {\n                    return (await loadLensesFromSources(this.lensSources, groupId)).map((lens) => {\n                        const lensWithGroup = { ...lens, groupId };\n                        this.metadataCache.set(lens.id, lensWithGroup);\n                        return toPublicLens(lensWithGroup);\n                    });\n                } catch (e) {\n                    const error = ensureError(e);\n                    logger.error(new Error(`Failed to load lens group ${groupId}.`, { cause: error }));\n                    return error;\n                }\n            })\n        );\n\n        return responses.reduce(\n            (result, response) => {\n                if (response instanceof Error) result.errors.push(response);\n                else result.lenses.push(...response);\n                return result;\n            },\n            { errors: [], lenses: [] } as { errors: Error[]; lenses: Lens[] }\n        );\n    }\n\n    /**\n     * Loads and caches lens content and dependencies to reduce latency when {@link CameraKitSession.applyLens} is later\n     * called to apply the lens. This is an in-memory cache, it will not be persisted across page loads.\n     *\n     * This may useful if the application A) knows which lenses will be applied and B) has some opportunity to call\n     * this method before a lens is applied. For example, if the user must perform some other actions before lenses\n     * become active, this might be a good opportunity to cache lenses to improve applyLens latency.\n     *\n     * @example\n     * ```ts\n     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)\n     * await cameraKit.lensRepository.cacheLensContent([lens])\n     *\n     * // sometime later -- this call will use the cached lens content, making lens application faster.\n     * await cameraKitSession.applyLens(lens)\n     * ```\n     *\n     * @param lenses Array of lenses to cache in memory.\n     * @param assetTimingsToCache Lenses specify certain required assets that are necessary for the lens to render, and\n     * other assets which may be needed by the lens. By default this method will cache all of those assets, but this\n     * behavior can be modified to only load the required assets, only the \"onDemand\" assets, or neither (by passing\n     * an empty array).\n     */\n    @validate(isLensArray, isAssetTimingArrayOrUndefined)\n    @errorLoggingDecorator(logger)\n    async cacheLensContent(lenses: Lens[], assetTimingsToCache: AssetTiming[] = [\"required\", \"onDemand\"]) {\n        const assetTimingsToLoad = assetTimingsToCache.map((timing) => assetTimingMap[timing]);\n        await Promise.all(\n            lenses.map(async (lens) => {\n                try {\n                    const { lensBuffer } = await this.getLensContent(lens, true);\n                    // Safety: getLensContent() call above ensures metadata to exist\n                    const { content } = this.metadataCache.get(lens.id)!;\n                    this.binariesCache.set(lens.id, lensBuffer);\n                    await this.lensAssetRepository.cacheAssets(content!.assetManifest, lens, assetTimingsToLoad, true);\n                } catch (error) {\n                    logger.warn(`Failed to cache lens ${lens.id}.`, error);\n                }\n            })\n        );\n    }\n\n    /**\n     * Returns loaded Lens metadata if available.\n     */\n    getLensMetadata(lensId: string): LensProtoWithGroupId | undefined {\n        return this.metadataCache.get(lensId);\n    }\n\n    /**\n     * Removes Lens content from the in-memory cache.\n     */\n    removeCachedLenses(lenses: Lens[]) {\n        lenses.forEach((lens) => this.binariesCache.delete(lens.id));\n    }\n\n    /**\n     * Fetches lens content and assets. This may come from the cache, otherwise network requests will be made.\n     *\n     * @internal\n     *\n     * @param lens Lens to fetch content for.\n     * @param lowPriority Flag indicating if the fetch requests should be treated with lower priority,\n     *                    leveraging browser capabilities to defer or deprioritize network traffic.\n     */\n    async getLensContent(lens: Lens, lowPriority: boolean = false): Promise<LensBinary> {\n        const { content } = this.metadataCache.get(lens.id) ?? {};\n        if (!content) {\n            throw new Error(`Cannot find metadata for lens ${lens.id}.`);\n        }\n\n        const cachedLensBuffer = this.binariesCache.get(lens.id);\n        if (cachedLensBuffer) {\n            return {\n                lensBuffer: cachedLensBuffer,\n                lensChecksum: content.lnsSha256,\n            };\n        }\n\n        const [lensBuffer] = await this.lensFetchHandler([\n            // TODO: remove force-cache once https://jira.sc-corp.net/browse/CAMKIT-3671 is addressed\n            new Request(content.lnsUrlBolt, withRequestPriority({ cache: \"force-cache\" }, lowPriority)),\n            {\n                requestType: \"lens_content\",\n                lensId: lens.id,\n            },\n        ]);\n        return { lensBuffer, lensChecksum: content.lnsSha256 };\n    }\n}\n\n// NOTE: jest doesn't like default exports of classes with decorated methods.\nexport { LensRepository };\n\n/**\n * @internal\n */\nexport const lensRepositoryFactory = Injectable(\n    \"LensRepository\",\n    [\n        requestStateEventTargetFactory.token,\n        defaultFetchHandlerFactory.token,\n        lensSourcesFactory.token,\n        lensAssetRepositoryFactory.token,\n    ] as const,\n    (\n        requestStateEventTarget: RequestStateEventTarget,\n        defaultFetchHandler: FetchHandler,\n        lensSources: LensSource[],\n        lensAssetRepository: LensAssetRepository\n    ) => {\n        const lensFetchHandler = new HandlerChainBuilder(defaultFetchHandler)\n            .map(createRequestStateEmittingHandler<LensDownloadDimensions>(requestStateEventTarget))\n            .map(createArrayBufferParsingHandler()).handler;\n\n        return new LensRepository(lensFetchHandler, lensSources, lensAssetRepository);\n    }\n);\n"]}