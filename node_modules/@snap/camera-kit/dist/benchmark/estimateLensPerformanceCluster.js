import { __awaiter } from "tslib";
import { benchmarkError } from "../namedErrors";
import { gflopsClusterCenters, benchmarkGflops } from "./benchmarkGflops";
const findNearest = (n, arr) => arr.reduce((a, b) => (Math.abs(a - n) <= Math.abs(b - n) ? a : b));
const webglContextAttributes = {
    alpha: false,
    antialias: false,
    premultipliedAlpha: false,
    preserveDrawingBuffer: false,
    depth: false,
    stencil: false,
    failIfMajorPerformanceCaveat: false,
    powerPreference: "high-performance",
};
export function estimateLensPerformance() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const canvas = document.createElement("canvas");
        const gl = canvas.getContext("webgl2", webglContextAttributes);
        if (!gl)
            throw benchmarkError("WebGL2 is required to compute performance, but it is not supported.");
        const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
        const webglRendererInfo = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "unknown";
        const gflops = yield benchmarkGflops(gl);
        const nearestGflopsClusterCenter = findNearest(gflops.value, Array.from(gflopsClusterCenters.keys()));
        const gflopsCluster = (_a = gflopsClusterCenters.get(nearestGflopsClusterCenter)) !== null && _a !== void 0 ? _a : 0;
        return {
            cluster: gflopsCluster,
            benchmarks: [gflops],
            webglRendererInfo,
        };
    });
}
//# sourceMappingURL=estimateLensPerformanceCluster.js.map