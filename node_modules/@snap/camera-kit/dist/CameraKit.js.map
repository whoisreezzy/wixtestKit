{"version":3,"file":"CameraKit.js","sourceRoot":"","sources":["../src/CameraKit.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Container } from \"@snap/ts-inject\";\nimport { CONTAINER, Injectable } from \"@snap/ts-inject\";\nimport { firstValueFrom } from \"rxjs\";\nimport type { LensRepository } from \"./lens/LensRepository\";\nimport { lensRepositoryFactory } from \"./lens/LensRepository\";\nimport type { LensCoreError } from \"./lens-core-module/lensCoreError\";\nimport type { LensCore } from \"./lens-core-module/lensCore\";\nimport type { CameraKitSession } from \"./session/CameraKitSession\";\nimport { cameraKitSessionFactory } from \"./session/CameraKitSession\";\nimport { registerLensAssetsProvider } from \"./lens/assets/LensAssetsProvider\";\nimport { lensCoreFactory } from \"./lens-core-module/loader/lensCoreFactory\";\nimport { configurationToken } from \"./configuration\";\nimport type { RootServices } from \"./RootServices\";\nimport { registerUriHandlers } from \"./uri-handlers/uriHandlersRegister\";\nimport type { MetricsEventTarget } from \"./metrics/metricsEventTarget\";\nimport { metricsEventTargetFactory } from \"./metrics/metricsEventTarget\";\nimport { reportSessionScopedMetrics } from \"./metrics/reporters/reporters\";\nimport { lensStateFactory } from \"./session/lensState\";\nimport { lensKeyboardFactory } from \"./session/LensKeyboard\";\nimport { registerLensClientInterfaceHandler } from \"./lens-client-interface/lensClientInterface\";\nimport { sessionStateFactory } from \"./session/sessionState\";\nimport { lensExecutionError, lensAbortError } from \"./namedErrors\";\nimport { getLogger, resetLogger } from \"./logger/logger\";\nimport { errorLoggingDecorator } from \"./logger/errorLoggingDecorator\";\nimport { TypedEventTarget } from \"./events/TypedEventTarget\";\nimport type { TypedCustomEvent } from \"./events/TypedCustomEvent\";\nimport type { LensView } from \"./metrics/reporters/reportLensView\";\nimport type { LensWait } from \"./metrics/reporters/reportLensWait\";\nimport type { PageVisibility } from \"./common/pageVisibility\";\nimport { pageVisibilityFactory } from \"./common/pageVisibility\";\nimport { setPreloadedConfiguration } from \"./remote-configuration/preloadConfiguration\";\nimport type { RemoteConfiguration } from \"./remote-configuration/remoteConfiguration\";\nimport { remoteConfigurationFactory } from \"./remote-configuration/remoteConfiguration\";\nimport { registerGeoDataProvider } from \"./geo/registerGeoDataProvider\";\n\nconst logger = getLogger(\"CameraKit\");\n\n/**\n * Metrics event names that are exposed to apps.\n */\nconst publicMetricsEventNames: Array<LensMetricsEvents[\"detail\"][\"name\"]> = [\"lensView\", \"lensWait\"];\n\n/**\n * Lens metrics events.\n *\n * These events are emitted by {@link CameraKit} to report lens usage, performance, apply latency, etc.\n *\n * @category Lenses\n * @category Metrics\n */\nexport type LensMetricsEvents =\n    | TypedCustomEvent<LensView[\"name\"], LensView>\n    | TypedCustomEvent<LensWait[\"name\"], LensWait>;\n\n/**\n * Options available when creating a {@link CameraKitSession}.\n *\n * @category Rendering\n */\nexport interface CreateSessionOptions {\n    /**\n     * Optionally provide an existing canvas element, on which the Live RenderTarget will be rendered.\n     *\n     * If this is not provided, CameraKit will create a new canvas element which can be added to the DOM.\n     */\n    liveRenderTarget?: HTMLCanvasElement;\n\n    /**\n     * Browsers optimize tabs when they are hidden - for example, by pausing the execution of requestAnimationFrame\n     * callbacks.\n     *\n     * If you need the CameraKitSession to continue rendering even when the tab is in the background, set this to true.\n     * There is a small performance penalty, and it's a good practice to only render in the background if absolutely\n     * necessary.\n     */\n    renderWhileTabHidden?: boolean;\n}\n\n/**\n * The entry point to the CameraKit SDK's API. Most of CameraKit's features are accessed via this class.\n *\n * Applications obtain an instance of CameraKit by calling {@link bootstrapCameraKit}.\n *\n * @example\n * ```ts\n * const cameraKit = await bootstrapCameraKit(config)\n * ```\n *\n * Then this class can be used to:\n * - Create a {@link CameraKitSession} instance, which provides the API for setting up media inputs, applying Lenses,\n * and obtaining rendered `<canvas>` outputs.\n * - Query for lenses using {@link LensRepository}.\n * - Listen for lens usage metrics events using {@link MetricsEventTarget}.\n *\n * @category Rendering\n * @category Lenses\n */\nexport class CameraKit {\n    /** @deprecated Use {@link lensRepository} */\n    readonly lenses: { repository: LensRepository };\n\n    /**\n     * Business metrics (e.g. each time a lens is viewed) are emitted here.\n     */\n    readonly metrics: TypedEventTarget<LensMetricsEvents> = new TypedEventTarget();\n\n    private sessions: CameraKitSession[] = [];\n\n    /** @internal */\n    constructor(\n        /**\n         * Used to query for lenses and lens groups.\n         */\n        readonly lensRepository: LensRepository,\n\n        private readonly lensCore: LensCore,\n        private readonly pageVisibility: PageVisibility,\n        private readonly container: Container<RootServices>,\n        private readonly remoteConfig: RemoteConfiguration,\n        allMetrics: MetricsEventTarget\n    ) {\n        this.lenses = { repository: this.lensRepository };\n        // Proxy only a subset of all metrics events to the public-facing emitter -- applications don't need to\n        // know about most events.\n        publicMetricsEventNames.forEach((eventName) => {\n            allMetrics.addEventListener(eventName, (e) => this.metrics.dispatchEvent(e));\n        });\n    }\n\n    /**\n     * Create a CameraKitSession.\n     *\n     * This initializes the rendering engine and returns a {@link CameraKitSession} instance, which provides access\n     * to Lens rendering.\n     *\n     * @example\n     * ```ts\n     * const cameraKit = await bootstrapCameraKit(config)\n     * const session = await cameraKit.createSession()\n     *\n     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)\n     * session.applyLens(lens)\n     * ```\n     *\n     * @param options\n     */\n    @errorLoggingDecorator(logger)\n    async createSession({\n        liveRenderTarget,\n        renderWhileTabHidden,\n    }: CreateSessionOptions = {}): Promise<CameraKitSession> {\n        // Any error happened during lens rendering can be processed by subscribing to sessionErrors\n        const exceptionHandler = (error: LensCoreError) => {\n            if (error.name === \"LensCoreAbortError\") {\n                logger.error(\n                    lensAbortError(\n                        \"Unrecoverable error occurred during lens execution. \" +\n                            \"The CameraKitSession will be destroyed.\",\n                        error\n                    )\n                );\n            } else {\n                logger.error(\n                    lensExecutionError(\n                        \"Error occurred during lens execution. \" +\n                            \"The lens cannot be rendered and will be removed from the CameraKitSession.\",\n                        error\n                    )\n                );\n            }\n        };\n\n        const config = this.container.get(configurationToken);\n\n        /**\n         * If/when we add support for multiple concurrent sessions, we'll need to create a copy of the LensCore WASM\n         * module. If we move managing web workers into JS, spawning a new worker thread with its own copy of LensCore\n         * probably becomes a lot more straightforward.\n         *\n         * Currently chromium has a bug preventing rendering while tab is hidden when LensCore is in worker mode.\n         * In order to process tab while it is hidden, the current stopgap is to pass in renderWhileTabHidden as true,\n         * which will initiate session in non worker mode, and set the RenderLoopMode to `SetTimeout`.\n         */\n        await this.lensCore.initialize({\n            canvas: liveRenderTarget,\n            shouldUseWorker: !renderWhileTabHidden && config.shouldUseWorker,\n            exceptionHandler,\n        });\n\n        if (this.lensCore.setGpuIndex) {\n            // NOTE: setGpuIndex was added in LensCore@292. This check ensures compatibility with older versions.\n\n            // Camera Kit allows a performance cluster to be provided during bootstrap.\n            // This cluster is passed to the LENS_FEATURE_GPU_INDEX config as LENS_CLUSTER_ORIG_4,\n            // which maps the cluster to a GPU index.\n            try {\n                await this.lensCore.setGpuIndex({\n                    gpuIndex: await firstValueFrom(this.remoteConfig.getGpuIndexConfig()),\n                });\n            } catch (cause) {\n                // LensCore initialization can proceed without the GPU index,\n                // as it is mainly needed for ML lenses.\n                logger.error(new Error(\"Cannot set GPU index.\", { cause }));\n            }\n        }\n\n        if (config.fonts.length > 0) {\n            this.lensCore.setSystemFonts({\n                fonts: config.fonts,\n            });\n        }\n\n        await this.lensCore.setRenderLoopMode({\n            mode: renderWhileTabHidden\n                ? this.lensCore.RenderLoopMode.SetTimeout\n                : this.lensCore.RenderLoopMode.RequestAnimationFrame,\n        });\n\n        // Each session gets its own DI Container – some Services provided by this Container may be shared with the\n        // root CameraKit Container, but others may be scoped to the session by passing their token to `copy()`.\n        const sessionContainer = this.container\n            // Right now this is a no-op. If/when we add support for multiple concurrent sessions, we may end up\n            // scoping LensCore to the session.\n            .copy()\n\n            .provides(sessionStateFactory)\n            .provides(lensStateFactory)\n            .provides(lensKeyboardFactory)\n            .provides(cameraKitSessionFactory)\n\n            .run(registerLensAssetsProvider)\n            .run(registerLensClientInterfaceHandler)\n            .run(registerGeoDataProvider)\n            .run(setPreloadedConfiguration)\n\n            // We'll run a PartialContainer containing reporters for session-scoped metrics. Running this container\n            // allows each metric reporter to initialize itself (e.g. by adding event listeners to detect when certain\n            // actions occur).\n            .run(reportSessionScopedMetrics)\n\n            // UriHandlers may have dependencies on session-scoped services (e.g. LensState, LensKeyboard), so they'll\n            // be registered with LensCore here.\n            .run(registerUriHandlers);\n\n        const session = sessionContainer.get(cameraKitSessionFactory.token);\n        this.sessions.push(session);\n        return session;\n    }\n\n    /**\n     * Destroys all sessions and frees all resources.\n     */\n    @errorLoggingDecorator(logger)\n    async destroy() {\n        resetLogger();\n        this.pageVisibility.destroy();\n        await Promise.all(this.sessions.map((session) => session.destroy()));\n        this.sessions = [];\n    }\n}\n\n/** @internal */\nexport const cameraKitFactory = Injectable(\n    \"CameraKit\",\n    [\n        lensRepositoryFactory.token,\n        metricsEventTargetFactory.token,\n        lensCoreFactory.token,\n        pageVisibilityFactory.token,\n        remoteConfigurationFactory.token,\n        CONTAINER,\n    ] as const,\n    (\n        lensRepository: LensRepository,\n        metrics: MetricsEventTarget,\n        lensCore: LensCore,\n        pageVisibility: PageVisibility,\n        remoteConfiguration: RemoteConfiguration,\n        container: Container<RootServices>\n    ) => new CameraKit(lensRepository, lensCore, pageVisibility, container, remoteConfiguration, metrics)\n);\n"]}