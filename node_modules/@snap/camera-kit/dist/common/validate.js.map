{"version":3,"file":"validate.js","sourceRoot":"","sources":["../../src/common/validate.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,uBAAuB,EAAE,MAAM,gBAAgB,CAAC;AAGzD,MAAM,gBAAgB,GAA2B;IAC7C,CAAC,EAAE,IAAI;IACP,CAAC,EAAE,IAAI;IACP,CAAC,EAAE,IAAI;CACV,CAAC;AAEF,SAAS,eAAe,CAAC,MAAe,EAAE,UAA2B,EAAE,aAAqB,EAAE,GAAY;;IACtG,IAAI,SAAS,CAAC;IACd,IAAI;QACA,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;KACnC;IAAC,WAAM;QACJ,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;KAC3B;IACD,OAAO;QACH,WAAW,EAAE,GAAG,aAAa,GAAG,CAAC,GAAG,MAAA,gBAAgB,CAAC,aAAa,GAAG,CAAC,CAAC,mCAAI,IAAI,EAAE;QACjF,UAAU,EAAE,GAAG,WAAW,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,UAAU,CAAC,IAAI;QAC5D,SAAS;KACZ,CAAC;AACN,CAAC;AAQD,MAAM,UAAU,WAAW,CAAC,KAAc;IACtC,IAAI,KAAK,KAAK,IAAI,EAAE;QAChB,OAAO,MAAM,CAAC;KACjB;IAED,MAAM,QAAQ,GAAG,OAAO,KAAK,CAAC;IAE9B,IAAI,CAAC,CAAC,QAAQ,EAAE,UAAU,CAAC,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;QAC5C,OAAO,QAAQ,CAAC;KACnB;IAGD,MAAM,YAAY,GAAG,KAAM,CAAC;IAK5B,MAAM,GAAG,GAAI,YAAkD,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;IACpF,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;QACzB,OAAO,GAAG,CAAC;KACd;IAGD,IAAI,QAAQ,KAAK,UAAU,IAAI,QAAQ,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;QAC/F,OAAO,OAAO,CAAC;KAClB;IAID,MAAM,SAAS,GAAG,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC;IAChD,IAAI,OAAO,SAAS,KAAK,QAAQ,IAAI,SAAS,KAAK,EAAE,EAAE;QACnD,OAAO,SAAS,CAAC;KACpB;IAID,OAAO,QAAQ,CAAC;AACpB,CAAC;AAOD,MAAM,UAAU,QAAQ,CAAmC,GAAG,MAA6C;IACvG,OAAO,SAAS,SAAS,CACrB,MAA6C,EAC7C,OAAiF;QAEjF,OAAO,UAAgB,GAAG,IAAI;YAC1B,KAAK,MAAM,CAAC,KAAK,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,EAAE,EAAE;gBAC3C,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;oBACrB,MAAM,EAAE,WAAW,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG,eAAe,CAC1D,IAAI,EACJ,OAAO,CAAC,IAAI,EACZ,KAAK,EACL,IAAI,CAAC,KAAK,CAAC,CACd,CAAC;oBACF,MAAM,uBAAuB,CACzB,OAAO,WAAW,gBAAgB,UAAU,iCAAiC,SAAS,GAAG,CAC5F,CAAC;iBACL;aACJ;YACD,OAAO,MAAM,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;QACpC,CAAC,CAAC;IACN,CAAC,CAAC;AACN,CAAC","sourcesContent":["import { argumentValidationError } from \"../namedErrors\";\nimport type { Guard } from \"./typeguards\";\n\nconst ordinalSuffixMap: Record<number, string> = {\n    1: \"st\",\n    2: \"nd\",\n    3: \"rd\",\n};\n\nfunction getArgumentInfo(target: unknown, methodName: string | symbol, argumentIndex: number, arg: unknown) {\n    let argString;\n    try {\n        argString = JSON.stringify(arg);\n    } catch {\n        argString = String(arg);\n    }\n    return {\n        argPosition: `${argumentIndex + 1}${ordinalSuffixMap[argumentIndex + 1] ?? \"th\"}`,\n        methodPath: `${getTypeName(target)}.${String(methodName)}()`,\n        argString,\n    };\n}\n\n/* eslint-disable max-len */\n/**\n * Returns type string of a value. It mostly mimics the behavior of typeof, but for non-primitives\n * (i.e. objects and functions), it returns a more granular type name where possible. Source:\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#custom_method_that_gets_a_more_specific_type\n */\nexport function getTypeName(value: unknown): string {\n    if (value === null) {\n        return \"null\";\n    }\n\n    const baseType = typeof value;\n    // Primitive types\n    if (![\"object\", \"function\"].includes(baseType)) {\n        return baseType;\n    }\n\n    // Safety: at this point null and undefined values are already handled\n    const nonNullValue = value!;\n\n    // Symbol.toStringTag often specifies the \"display name\" of the\n    // object's class. It's used in Object.prototype.toString().\n    // Safety: cast to an object with Symbol.toStringTag key in order to check for its existance.\n    const tag = (nonNullValue as { [Symbol.toStringTag]?: string })[Symbol.toStringTag];\n    if (typeof tag === \"string\") {\n        return tag;\n    }\n\n    // If it's a function whose source code starts with the \"class\" keyword\n    if (baseType === \"function\" && Function.prototype.toString.call(nonNullValue).startsWith(\"class\")) {\n        return \"class\";\n    }\n\n    // The name of the constructor; for example `Array`, `GeneratorFunction`,\n    // `Number`, `String`, `Boolean` or `MyCustomClass`\n    const className = nonNullValue.constructor.name;\n    if (typeof className === \"string\" && className !== \"\") {\n        return className;\n    }\n\n    // At this point there's no robust way to get the type of value,\n    // so we use the base implementation.\n    return baseType;\n}\n\n/**\n * Decorator to validate method arguments.\n * @param guards Parameter guards to validate arguments.\n * @returns\n */\nexport function validate<This, Args extends any[], Return>(...guards: { [K in keyof Args]: Guard<Args[K]> }) {\n    return function validator(\n        target: (this: This, ...args: Args) => Return,\n        context: ClassMethodDecoratorContext<This, (this: This, ...args: Args) => Return>\n    ): (this: This, ...args: Args) => Return {\n        return function (this, ...args) {\n            for (const [index, guard] of guards.entries()) {\n                if (!guard(args[index])) {\n                    const { argPosition, methodPath, argString } = getArgumentInfo(\n                        this,\n                        context.name,\n                        index,\n                        args[index]\n                    );\n                    throw argumentValidationError(\n                        `The ${argPosition} argument to ${methodPath} method has an invalid value: ${argString}.`\n                    );\n                }\n            }\n            return target.apply(this, args);\n        };\n    };\n}\n"]}