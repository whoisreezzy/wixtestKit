interface BaseResult<T, E> {
    readonly ok: boolean;
    unwrap(): T;
    unwrapErr(): E;
    map<T2>(m: (value: T) => T2): Result<T2, E>;
    flatMap<T2 extends OkResult<unknown>>(m: (value: T) => T2): Result<ValueOf<T2>, E>;
    flatMap<E2 extends ErrResult<unknown>>(m: (value: T) => E2): Result<T, E | ValueOf<E2>>;
    flatMap<R extends Result<unknown, unknown>>(m: (value: T) => R): Result<OkValueOf<R>, E | ErrValueOf<R>>;
}
type OkValueOf<R> = R extends OkResult<infer T> ? T : never;
type ErrValueOf<R> = R extends ErrResult<infer E> ? E : never;
type ValueOf<R> = OkValueOf<R> | ErrValueOf<R>;
export declare class OkResult<T> implements BaseResult<T, never> {
    private readonly value;
    readonly ok = true;
    constructor(value: T);
    unwrap(): T;
    unwrapErr(): never;
    map<T2>(m: (value: T) => T2): OkResult<T2>;
    flatMap<T2 extends OkResult<unknown>>(m: (value: T) => T2): T2;
    flatMap<E2 extends ErrResult<unknown>>(m: (value: T) => E2): E2;
    flatMap<R extends Result<unknown, unknown>>(m: (value: T) => R): R;
}
export declare const Ok: <T>(value: T) => OkResult<T>;
export declare class ErrResult<E> implements BaseResult<never, E> {
    private readonly value;
    readonly ok = false;
    constructor(value: E);
    unwrap(): never;
    unwrapErr(): E;
    map(): ErrResult<E>;
    flatMap(): ErrResult<E>;
}
export declare const Err: <E>(value: E) => ErrResult<E>;
export type Result<T, E> = OkResult<T> | ErrResult<E>;
export {};
//# sourceMappingURL=result.d.ts.map