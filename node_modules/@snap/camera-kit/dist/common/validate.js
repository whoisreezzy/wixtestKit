import { argumentValidationError } from "../namedErrors";
const ordinalSuffixMap = {
    1: "st",
    2: "nd",
    3: "rd",
};
function getArgumentInfo(target, methodName, argumentIndex, arg) {
    var _a;
    let argString;
    try {
        argString = JSON.stringify(arg);
    }
    catch (_b) {
        argString = String(arg);
    }
    return {
        argPosition: `${argumentIndex + 1}${(_a = ordinalSuffixMap[argumentIndex + 1]) !== null && _a !== void 0 ? _a : "th"}`,
        methodPath: `${getTypeName(target)}.${String(methodName)}()`,
        argString,
    };
}
export function getTypeName(value) {
    if (value === null) {
        return "null";
    }
    const baseType = typeof value;
    if (!["object", "function"].includes(baseType)) {
        return baseType;
    }
    const nonNullValue = value;
    const tag = nonNullValue[Symbol.toStringTag];
    if (typeof tag === "string") {
        return tag;
    }
    if (baseType === "function" && Function.prototype.toString.call(nonNullValue).startsWith("class")) {
        return "class";
    }
    const className = nonNullValue.constructor.name;
    if (typeof className === "string" && className !== "") {
        return className;
    }
    return baseType;
}
export function validate(...guards) {
    return function validator(target, context) {
        return function (...args) {
            for (const [index, guard] of guards.entries()) {
                if (!guard(args[index])) {
                    const { argPosition, methodPath, argString } = getArgumentInfo(this, context.name, index, args[index]);
                    throw argumentValidationError(`The ${argPosition} argument to ${methodPath} method has an invalid value: ${argString}.`);
                }
            }
            return target.apply(this, args);
        };
    };
}
//# sourceMappingURL=validate.js.map