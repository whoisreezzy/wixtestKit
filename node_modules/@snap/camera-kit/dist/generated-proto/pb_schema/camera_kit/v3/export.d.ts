import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Lens } from "./lens";
export declare const protobufPackage = "com.snap.camerakit.v3";
export interface ExportLensesByIdRequest {
    unlockableIds: string[];
    context: ExportLensesByIdRequest_Context | undefined;
}
export interface ExportLensesByIdRequest_Context {
    userAgent: string;
    locale: string;
    extention: ExportLensesByIdRequest_Context_Extension | undefined;
    extension: ExportLensesByIdRequest_Context_Extension | undefined;
    extensionRequestContext: Uint8Array;
}
export interface ExportLensesByIdRequest_Context_Extension {
    name: ExportLensesByIdRequest_Context_Extension_Name;
    version: string;
}
export declare enum ExportLensesByIdRequest_Context_Extension_Name {
    UNSET = "UNSET",
    SHOP_KIT = "SHOP_KIT",
    LENS_WEB_BUILDER = "LENS_WEB_BUILDER",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function exportLensesByIdRequest_Context_Extension_NameFromJSON(object: any): ExportLensesByIdRequest_Context_Extension_Name;
export declare function exportLensesByIdRequest_Context_Extension_NameToNumber(object: ExportLensesByIdRequest_Context_Extension_Name): number;
export interface ExportLensesByIdResponse {
    lenses: {
        [key: string]: Uint8Array;
    };
    excludedLenses: ExportLensesByIdResponse_ExcludedLens[];
}
export interface ExportLensesByIdResponse_LensesEntry {
    key: string;
    value: Uint8Array;
}
export interface ExportLensesByIdResponse_ExcludedLens {
    lensId: string;
    code: ExportLensesByIdResponse_ExcludedLens_Code;
    reason: string;
}
export declare enum ExportLensesByIdResponse_ExcludedLens_Code {
    UNSET = "UNSET",
    UNKNOWN = "UNKNOWN",
    NOT_FOUND = "NOT_FOUND",
    INCOMPATIBLE_LENS_CORE_VERSION = "INCOMPATIBLE_LENS_CORE_VERSION",
    ARCHIVED_OR_INVISIBLE = "ARCHIVED_OR_INVISIBLE",
    CONTAINS_MUSIC = "CONTAINS_MUSIC",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function exportLensesByIdResponse_ExcludedLens_CodeFromJSON(object: any): ExportLensesByIdResponse_ExcludedLens_Code;
export declare function exportLensesByIdResponse_ExcludedLens_CodeToNumber(object: ExportLensesByIdResponse_ExcludedLens_Code): number;
export interface ExtensionRequestContext {
    userAgent: string;
    locale: string;
}
export interface Envelope {
    lenses: Lens[];
}
export declare const ExportLensesByIdRequest: MessageFns<ExportLensesByIdRequest>;
export declare const ExportLensesByIdRequest_Context: MessageFns<ExportLensesByIdRequest_Context>;
export declare const ExportLensesByIdRequest_Context_Extension: MessageFns<ExportLensesByIdRequest_Context_Extension>;
export declare const ExportLensesByIdResponse: MessageFns<ExportLensesByIdResponse>;
export declare const ExportLensesByIdResponse_LensesEntry: MessageFns<ExportLensesByIdResponse_LensesEntry>;
export declare const ExportLensesByIdResponse_ExcludedLens: MessageFns<ExportLensesByIdResponse_ExcludedLens>;
export declare const ExtensionRequestContext: MessageFns<ExtensionRequestContext>;
export declare const Envelope: MessageFns<Envelope>;
export interface Export {
    ExportLensesById(request: ExportLensesByIdRequest): Promise<ExportLensesByIdResponse>;
}
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
//# sourceMappingURL=export.d.ts.map