{"version":3,"file":"http.js","sourceRoot":"","sources":["../../../../../src/generated-proto/pb_schema/google/api/http.ts"],"names":[],"mappings":"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","sourcesContent":["// Code generated by protoc-gen-ts_proto. DO NOT EDIT.\n// versions:\n//   protoc-gen-ts_proto  v2.2.4\n//   protoc               v5.28.2\n// source: google/api/http.proto\n\n/* eslint-disable */\nimport { BinaryReader, BinaryWriter } from \"@bufbuild/protobuf/wire\";\n\nexport const protobufPackage = \"google.api\";\n\n/**\n * Defines the HTTP configuration for an API service. It contains a list of\n * [HttpRule][google.api.HttpRule], each specifying the mapping of an RPC method\n * to one or more HTTP REST API methods.\n */\nexport interface Http {\n  /**\n   * A list of HTTP configuration rules that apply to individual API methods.\n   *\n   * **NOTE:** All service configuration rules follow \"last one wins\" order.\n   */\n  rules: HttpRule[];\n  /**\n   * When set to true, URL path parmeters will be fully URI-decoded except in\n   * cases of single segment matches in reserved expansion, where \"%2F\" will be\n   * left encoded.\n   *\n   * The default behavior is to not decode RFC 6570 reserved characters in multi\n   * segment matches.\n   */\n  fullyDecodeReservedExpansion: boolean;\n}\n\n/**\n * `HttpRule` defines the mapping of an RPC method to one or more HTTP\n * REST API methods. The mapping specifies how different portions of the RPC\n * request message are mapped to URL path, URL query parameters, and\n * HTTP request body. The mapping is typically specified as an\n * `google.api.http` annotation on the RPC method,\n * see \"google/api/annotations.proto\" for details.\n *\n * The mapping consists of a field specifying the path template and\n * method kind.  The path template can refer to fields in the request\n * message, as in the example below which describes a REST GET\n * operation on a resource collection of messages:\n *\n *     service Messaging {\n *       rpc GetMessage(GetMessageRequest) returns (Message) {\n *         option (google.api.http).get = \"/v1/messages/{message_id}/{sub.subfield}\";\n *       }\n *     }\n *     message GetMessageRequest {\n *       message SubMessage {\n *         string subfield = 1;\n *       }\n *       string message_id = 1; // mapped to the URL\n *       SubMessage sub = 2;    // `sub.subfield` is url-mapped\n *     }\n *     message Message {\n *       string text = 1; // content of the resource\n *     }\n *\n * The same http annotation can alternatively be expressed inside the\n * `GRPC API Configuration` YAML file.\n *\n *     http:\n *       rules:\n *         - selector: <proto_package_name>.Messaging.GetMessage\n *           get: /v1/messages/{message_id}/{sub.subfield}\n *\n * This definition enables an automatic, bidrectional mapping of HTTP\n * JSON to RPC. Example:\n *\n * HTTP | RPC\n * -----|-----\n * `GET /v1/messages/123456/foo`  | `GetMessage(message_id: \"123456\" sub: SubMessage(subfield: \"foo\"))`\n *\n * In general, not only fields but also field paths can be referenced\n * from a path pattern. Fields mapped to the path pattern cannot be\n * repeated and must have a primitive (non-message) type.\n *\n * Any fields in the request message which are not bound by the path\n * pattern automatically become (optional) HTTP query\n * parameters. Assume the following definition of the request message:\n *\n *     service Messaging {\n *       rpc GetMessage(GetMessageRequest) returns (Message) {\n *         option (google.api.http).get = \"/v1/messages/{message_id}\";\n *       }\n *     }\n *     message GetMessageRequest {\n *       message SubMessage {\n *         string subfield = 1;\n *       }\n *       string message_id = 1; // mapped to the URL\n *       int64 revision = 2;    // becomes a parameter\n *       SubMessage sub = 3;    // `sub.subfield` becomes a parameter\n *     }\n *\n * This enables a HTTP JSON to RPC mapping as below:\n *\n * HTTP | RPC\n * -----|-----\n * `GET /v1/messages/123456?revision=2&sub.subfield=foo` | `GetMessage(message_id: \"123456\" revision: 2 sub: SubMessage(subfield: \"foo\"))`\n *\n * Note that fields which are mapped to HTTP parameters must have a\n * primitive type or a repeated primitive type. Message types are not\n * allowed. In the case of a repeated type, the parameter can be\n * repeated in the URL, as in `...?param=A&param=B`.\n *\n * For HTTP method kinds which allow a request body, the `body` field\n * specifies the mapping. Consider a REST update method on the\n * message resource collection:\n *\n *     service Messaging {\n *       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\n *         option (google.api.http) = {\n *           put: \"/v1/messages/{message_id}\"\n *           body: \"message\"\n *         };\n *       }\n *     }\n *     message UpdateMessageRequest {\n *       string message_id = 1; // mapped to the URL\n *       Message message = 2;   // mapped to the body\n *     }\n *\n * The following HTTP JSON to RPC mapping is enabled, where the\n * representation of the JSON in the request body is determined by\n * protos JSON encoding:\n *\n * HTTP | RPC\n * -----|-----\n * `PUT /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id: \"123456\" message { text: \"Hi!\" })`\n *\n * The special name `*` can be used in the body mapping to define that\n * every field not bound by the path template should be mapped to the\n * request body.  This enables the following alternative definition of\n * the update method:\n *\n *     service Messaging {\n *       rpc UpdateMessage(Message) returns (Message) {\n *         option (google.api.http) = {\n *           put: \"/v1/messages/{message_id}\"\n *           body: \"*\"\n *         };\n *       }\n *     }\n *     message Message {\n *       string message_id = 1;\n *       string text = 2;\n *     }\n *\n * The following HTTP JSON to RPC mapping is enabled:\n *\n * HTTP | RPC\n * -----|-----\n * `PUT /v1/messages/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id: \"123456\" text: \"Hi!\")`\n *\n * Note that when using `*` in the body mapping, it is not possible to\n * have HTTP parameters, as all fields not bound by the path end in\n * the body. This makes this option more rarely used in practice of\n * defining REST APIs. The common usage of `*` is in custom methods\n * which don't use the URL at all for transferring data.\n *\n * It is possible to define multiple HTTP methods for one RPC by using\n * the `additional_bindings` option. Example:\n *\n *     service Messaging {\n *       rpc GetMessage(GetMessageRequest) returns (Message) {\n *         option (google.api.http) = {\n *           get: \"/v1/messages/{message_id}\"\n *           additional_bindings {\n *             get: \"/v1/users/{user_id}/messages/{message_id}\"\n *           }\n *         };\n *       }\n *     }\n *     message GetMessageRequest {\n *       string message_id = 1;\n *       string user_id = 2;\n *     }\n *\n * This enables the following two alternative HTTP JSON to RPC\n * mappings:\n *\n * HTTP | RPC\n * -----|-----\n * `GET /v1/messages/123456` | `GetMessage(message_id: \"123456\")`\n * `GET /v1/users/me/messages/123456` | `GetMessage(user_id: \"me\" message_id: \"123456\")`\n *\n * # Rules for HTTP mapping\n *\n * The rules for mapping HTTP path, query parameters, and body fields\n * to the request message are as follows:\n *\n * 1. The `body` field specifies either `*` or a field path, or is\n *    omitted. If omitted, it indicates there is no HTTP request body.\n * 2. Leaf fields (recursive expansion of nested messages in the\n *    request) can be classified into three types:\n *     (a) Matched in the URL template.\n *     (b) Covered by body (if body is `*`, everything except (a) fields;\n *         else everything under the body field)\n *     (c) All other fields.\n * 3. URL query parameters found in the HTTP request are mapped to (c) fields.\n * 4. Any body sent with an HTTP request can contain only (b) fields.\n *\n * The syntax of the path template is as follows:\n *\n *     Template = \"/\" Segments [ Verb ] ;\n *     Segments = Segment { \"/\" Segment } ;\n *     Segment  = \"*\" | \"**\" | LITERAL | Variable ;\n *     Variable = \"{\" FieldPath [ \"=\" Segments ] \"}\" ;\n *     FieldPath = IDENT { \".\" IDENT } ;\n *     Verb     = \":\" LITERAL ;\n *\n * The syntax `*` matches a single path segment. The syntax `**` matches zero\n * or more path segments, which must be the last part of the path except the\n * `Verb`. The syntax `LITERAL` matches literal text in the path.\n *\n * The syntax `Variable` matches part of the URL path as specified by its\n * template. A variable template must not contain other variables. If a variable\n * matches a single path segment, its template may be omitted, e.g. `{var}`\n * is equivalent to `{var=*}`.\n *\n * If a variable contains exactly one path segment, such as `\"{var}\"` or\n * `\"{var=*}\"`, when such a variable is expanded into a URL path, all characters\n * except `[-_.~0-9a-zA-Z]` are percent-encoded. Such variables show up in the\n * Discovery Document as `{var}`.\n *\n * If a variable contains one or more path segments, such as `\"{var=foo/*}\"`\n * or `\"{var=**}\"`, when such a variable is expanded into a URL path, all\n * characters except `[-_.~/0-9a-zA-Z]` are percent-encoded. Such variables\n * show up in the Discovery Document as `{+var}`.\n *\n * NOTE: While the single segment variable matches the semantics of\n * [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2\n * Simple String Expansion, the multi segment variable **does not** match\n * RFC 6570 Reserved Expansion. The reason is that the Reserved Expansion\n * does not expand special characters like `?` and `#`, which would lead\n * to invalid URLs.\n *\n * NOTE: the field paths in variables and in the `body` must not refer to\n * repeated fields or map fields.\n */\nexport interface HttpRule {\n  /**\n   * Selects methods to which this rule applies.\n   *\n   * Refer to [selector][google.api.DocumentationRule.selector] for syntax details.\n   */\n  selector: string;\n  pattern?:\n    | { $case: \"get\"; get: string }\n    | { $case: \"put\"; put: string }\n    | { $case: \"post\"; post: string }\n    | { $case: \"delete\"; delete: string }\n    | { $case: \"patch\"; patch: string }\n    | { $case: \"custom\"; custom: CustomHttpPattern }\n    | undefined;\n  /**\n   * The name of the request field whose value is mapped to the HTTP body, or\n   * `*` for mapping all fields not captured by the path pattern to the HTTP\n   * body. NOTE: the referred field must not be a repeated field and must be\n   * present at the top-level of request message type.\n   */\n  body: string;\n  /**\n   * Additional HTTP bindings for the selector. Nested bindings must\n   * not contain an `additional_bindings` field themselves (that is,\n   * the nesting may only be one level deep).\n   */\n  additionalBindings: HttpRule[];\n}\n\n/** A custom pattern is used for defining custom HTTP verb. */\nexport interface CustomHttpPattern {\n  /** The name of this custom HTTP verb. */\n  kind: string;\n  /** The path matched by this custom verb. */\n  path: string;\n}\n\nfunction createBaseHttp(): Http {\n  return { rules: [], fullyDecodeReservedExpansion: false };\n}\n\nexport const Http: MessageFns<Http> = {\n  encode(message: Http, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    for (const v of message.rules) {\n      HttpRule.encode(v!, writer.uint32(10).fork()).join();\n    }\n    if (message.fullyDecodeReservedExpansion !== false) {\n      writer.uint32(16).bool(message.fullyDecodeReservedExpansion);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): Http {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHttp();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.rules.push(HttpRule.decode(reader, reader.uint32()));\n          continue;\n        }\n        case 2: {\n          if (tag !== 16) {\n            break;\n          }\n\n          message.fullyDecodeReservedExpansion = reader.bool();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<Http>, I>>(base?: I): Http {\n    return Http.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<Http>, I>>(object: I): Http {\n    const message = createBaseHttp();\n    message.rules = object.rules?.map((e) => HttpRule.fromPartial(e)) || [];\n    message.fullyDecodeReservedExpansion = object.fullyDecodeReservedExpansion ?? false;\n    return message;\n  },\n};\n\nfunction createBaseHttpRule(): HttpRule {\n  return { selector: \"\", pattern: undefined, body: \"\", additionalBindings: [] };\n}\n\nexport const HttpRule: MessageFns<HttpRule> = {\n  encode(message: HttpRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.selector !== \"\") {\n      writer.uint32(10).string(message.selector);\n    }\n    switch (message.pattern?.$case) {\n      case \"get\":\n        writer.uint32(18).string(message.pattern.get);\n        break;\n      case \"put\":\n        writer.uint32(26).string(message.pattern.put);\n        break;\n      case \"post\":\n        writer.uint32(34).string(message.pattern.post);\n        break;\n      case \"delete\":\n        writer.uint32(42).string(message.pattern.delete);\n        break;\n      case \"patch\":\n        writer.uint32(50).string(message.pattern.patch);\n        break;\n      case \"custom\":\n        CustomHttpPattern.encode(message.pattern.custom, writer.uint32(66).fork()).join();\n        break;\n    }\n    if (message.body !== \"\") {\n      writer.uint32(58).string(message.body);\n    }\n    for (const v of message.additionalBindings) {\n      HttpRule.encode(v!, writer.uint32(90).fork()).join();\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): HttpRule {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseHttpRule();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.selector = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.pattern = { $case: \"get\", get: reader.string() };\n          continue;\n        }\n        case 3: {\n          if (tag !== 26) {\n            break;\n          }\n\n          message.pattern = { $case: \"put\", put: reader.string() };\n          continue;\n        }\n        case 4: {\n          if (tag !== 34) {\n            break;\n          }\n\n          message.pattern = { $case: \"post\", post: reader.string() };\n          continue;\n        }\n        case 5: {\n          if (tag !== 42) {\n            break;\n          }\n\n          message.pattern = { $case: \"delete\", delete: reader.string() };\n          continue;\n        }\n        case 6: {\n          if (tag !== 50) {\n            break;\n          }\n\n          message.pattern = { $case: \"patch\", patch: reader.string() };\n          continue;\n        }\n        case 8: {\n          if (tag !== 66) {\n            break;\n          }\n\n          message.pattern = { $case: \"custom\", custom: CustomHttpPattern.decode(reader, reader.uint32()) };\n          continue;\n        }\n        case 7: {\n          if (tag !== 58) {\n            break;\n          }\n\n          message.body = reader.string();\n          continue;\n        }\n        case 11: {\n          if (tag !== 90) {\n            break;\n          }\n\n          message.additionalBindings.push(HttpRule.decode(reader, reader.uint32()));\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<HttpRule>, I>>(base?: I): HttpRule {\n    return HttpRule.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<HttpRule>, I>>(object: I): HttpRule {\n    const message = createBaseHttpRule();\n    message.selector = object.selector ?? \"\";\n    if (object.pattern?.$case === \"get\" && object.pattern?.get !== undefined && object.pattern?.get !== null) {\n      message.pattern = { $case: \"get\", get: object.pattern.get };\n    }\n    if (object.pattern?.$case === \"put\" && object.pattern?.put !== undefined && object.pattern?.put !== null) {\n      message.pattern = { $case: \"put\", put: object.pattern.put };\n    }\n    if (object.pattern?.$case === \"post\" && object.pattern?.post !== undefined && object.pattern?.post !== null) {\n      message.pattern = { $case: \"post\", post: object.pattern.post };\n    }\n    if (object.pattern?.$case === \"delete\" && object.pattern?.delete !== undefined && object.pattern?.delete !== null) {\n      message.pattern = { $case: \"delete\", delete: object.pattern.delete };\n    }\n    if (object.pattern?.$case === \"patch\" && object.pattern?.patch !== undefined && object.pattern?.patch !== null) {\n      message.pattern = { $case: \"patch\", patch: object.pattern.patch };\n    }\n    if (object.pattern?.$case === \"custom\" && object.pattern?.custom !== undefined && object.pattern?.custom !== null) {\n      message.pattern = { $case: \"custom\", custom: CustomHttpPattern.fromPartial(object.pattern.custom) };\n    }\n    message.body = object.body ?? \"\";\n    message.additionalBindings = object.additionalBindings?.map((e) => HttpRule.fromPartial(e)) || [];\n    return message;\n  },\n};\n\nfunction createBaseCustomHttpPattern(): CustomHttpPattern {\n  return { kind: \"\", path: \"\" };\n}\n\nexport const CustomHttpPattern: MessageFns<CustomHttpPattern> = {\n  encode(message: CustomHttpPattern, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {\n    if (message.kind !== \"\") {\n      writer.uint32(10).string(message.kind);\n    }\n    if (message.path !== \"\") {\n      writer.uint32(18).string(message.path);\n    }\n    return writer;\n  },\n\n  decode(input: BinaryReader | Uint8Array, length?: number): CustomHttpPattern {\n    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = createBaseCustomHttpPattern();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1: {\n          if (tag !== 10) {\n            break;\n          }\n\n          message.kind = reader.string();\n          continue;\n        }\n        case 2: {\n          if (tag !== 18) {\n            break;\n          }\n\n          message.path = reader.string();\n          continue;\n        }\n      }\n      if ((tag & 7) === 4 || tag === 0) {\n        break;\n      }\n      reader.skip(tag & 7);\n    }\n    return message;\n  },\n\n  create<I extends Exact<DeepPartial<CustomHttpPattern>, I>>(base?: I): CustomHttpPattern {\n    return CustomHttpPattern.fromPartial(base ?? ({} as any));\n  },\n  fromPartial<I extends Exact<DeepPartial<CustomHttpPattern>, I>>(object: I): CustomHttpPattern {\n    const message = createBaseCustomHttpPattern();\n    message.kind = object.kind ?? \"\";\n    message.path = object.path ?? \"\";\n    return message;\n  },\n};\n\ntype Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;\n\nexport type DeepPartial<T> = T extends Builtin ? T\n  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>\n  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>\n  : T extends { $case: string } ? { [K in keyof Omit<T, \"$case\">]?: DeepPartial<T[K]> } & { $case: T[\"$case\"] }\n  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : Partial<T>;\n\ntype KeysOfUnion<T> = T extends T ? keyof T : never;\nexport type Exact<P, I extends P> = P extends Builtin ? P\n  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };\n\nexport interface MessageFns<T> {\n  encode(message: T, writer?: BinaryWriter): BinaryWriter;\n  decode(input: BinaryReader | Uint8Array, length?: number): T;\n  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;\n  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;\n}\n"]}