import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export declare const protobufPackage = "snapchat.lenses.snappable";
export interface EncryptionData {
    key: Uint8Array;
    ivStore: {
        [key: string]: Uint8Array;
    };
    isKeyServerEncrypted: boolean;
    isKeyE2eEncrypted: boolean;
    encryptionScheme: EncryptionData_EncryptionScheme;
}
export declare enum EncryptionData_EncryptionScheme {
    NOT_APPLICABLE = "NOT_APPLICABLE",
    SPOOKEY = "SPOOKEY",
    REGISTRY = "REGISTRY",
    FIDELIUS = "FIDELIUS",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function encryptionData_EncryptionSchemeFromJSON(object: any): EncryptionData_EncryptionScheme;
export declare function encryptionData_EncryptionSchemeToNumber(object: EncryptionData_EncryptionScheme): number;
export interface EncryptionData_IvStoreEntry {
    key: string;
    value: Uint8Array;
}
export interface PlayerData {
    store: {
        [key: string]: string;
    };
    serializedStore: Uint8Array;
}
export interface PlayerData_StoreEntry {
    key: string;
    value: string;
}
export interface SessionData {
    playerData: {
        [key: string]: PlayerData;
    };
}
export interface SessionData_PlayerDataEntry {
    key: string;
    value: PlayerData | undefined;
}
export interface SnappableMedia {
    sessionId: string;
    playerId: string;
    url: string;
    key: string;
    createdTime: string;
}
export interface Snap3DData {
    allowZippedMedia: boolean;
}
export interface UsesCameraRoll {
    usesCameraRoll: boolean;
}
export interface SnappableMessage {
    snappable: Snappable | undefined;
    media: SnappableMedia[];
    effectId: string;
    userIds: string[];
    focusPointX: number;
    focusPointY: number;
    focusPointWidth: number;
    replyType: SnappableMessage_ReplyType;
    snap3dData: Snap3DData | undefined;
    usesCameraRollData: UsesCameraRoll | undefined;
    assetBatchId: string;
}
export declare enum SnappableMessage_ReplyType {
    NOT_APPLICABLE = "NOT_APPLICABLE",
    CONTEXT = "CONTEXT",
    INTERSTITIAL = "INTERSTITIAL",
    UNRECOGNIZED = "UNRECOGNIZED"
}
export declare function snappableMessage_ReplyTypeFromJSON(object: any): SnappableMessage_ReplyType;
export declare function snappableMessage_ReplyTypeToNumber(object: SnappableMessage_ReplyType): number;
export interface Snappable {
    id: string;
    sessionId: string;
    playerId: string;
    sessionData: SessionData | undefined;
    createdTime: string;
    expireTime: string;
    version: number;
    encryptionData: EncryptionData | undefined;
    sessionDepth: number;
}
export interface PutSnappableRequest {
    snappable: Snappable | undefined;
    media: SnappableMedia[];
}
export interface PutSnappableResponse {
    id: string;
}
export interface GetSnappableRequest {
    id: string;
}
export interface GetSnappableResponse {
    data: Snappable | undefined;
    media: SnappableMedia[];
}
export interface SnappableEncryptedKey {
    encryptedKey: Uint8Array;
    encryptionKeyId: string;
    encryptionKeyIv: Uint8Array;
}
export declare const EncryptionData: MessageFns<EncryptionData>;
export declare const EncryptionData_IvStoreEntry: MessageFns<EncryptionData_IvStoreEntry>;
export declare const PlayerData: MessageFns<PlayerData>;
export declare const PlayerData_StoreEntry: MessageFns<PlayerData_StoreEntry>;
export declare const SessionData: MessageFns<SessionData>;
export declare const SessionData_PlayerDataEntry: MessageFns<SessionData_PlayerDataEntry>;
export declare const SnappableMedia: MessageFns<SnappableMedia>;
export declare const Snap3DData: MessageFns<Snap3DData>;
export declare const UsesCameraRoll: MessageFns<UsesCameraRoll>;
export declare const SnappableMessage: MessageFns<SnappableMessage>;
export declare const Snappable: MessageFns<Snappable>;
export declare const PutSnappableRequest: MessageFns<PutSnappableRequest>;
export declare const PutSnappableResponse: MessageFns<PutSnappableResponse>;
export declare const GetSnappableRequest: MessageFns<GetSnappableRequest>;
export declare const GetSnappableResponse: MessageFns<GetSnappableResponse>;
export declare const SnappableEncryptedKey: MessageFns<SnappableEncryptedKey>;
type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;
export type DeepPartial<T> = T extends Builtin ? T : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {
    $case: string;
} ? {
    [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]>;
} & {
    $case: T["$case"];
} : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P : P & {
    [K in keyof P]: Exact<P[K], I[K]>;
} & {
    [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
};
export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
export {};
//# sourceMappingURL=snappable.d.ts.map