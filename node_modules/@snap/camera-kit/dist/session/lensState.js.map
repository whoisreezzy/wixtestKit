{"version":3,"file":"lensState.js","sourceRoot":"","sources":["../../src/session/lensState.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Actions } from \"@snap/state-management\";\nimport {\n    defineAction,\n    defineActions,\n    defineState,\n    defineStates,\n    dispatch,\n    forActions,\n    inStates,\n    StateMachine,\n} from \"@snap/state-management\";\nimport { Injectable } from \"@snap/ts-inject\";\nimport {\n    catchError,\n    exhaustMap,\n    forkJoin,\n    from,\n    map,\n    merge,\n    mergeMap,\n    Observable,\n    of,\n    switchMap,\n    take,\n    takeUntil,\n    tap,\n} from \"rxjs\";\nimport type { Lens } from \"../lens/Lens\";\nimport type { LensRepository } from \"../lens/LensRepository\";\nimport { lensRepositoryFactory } from \"../lens/LensRepository\";\nimport type { AddLensInput } from \"../lens-core-module/generated-types\";\nimport type { IndexedDBPersistence } from \"../persistence/IndexedDBPersistence\";\nimport { lensPersistenceStoreFactory } from \"../lens/LensPersistenceStore\";\nimport type { LensLaunchData } from \"../lens/LensLaunchData\";\nimport { encodeLensLaunchData } from \"../lens/LensLaunchData\";\nimport type { LegalState } from \"../legal/legalState\";\nimport { legalStateFactory } from \"../legal/legalState\";\nimport type { LensAssetRepository } from \"../lens/assets/LensAssetRepository\";\nimport { lensAssetRepositoryFactory } from \"../lens/assets/LensAssetRepository\";\nimport type { LegalError, LensContentValidationError, LensError } from \"../namedErrors\";\nimport { legalError, lensContentValidationError, lensError } from \"../namedErrors\";\nimport { getLogger } from \"../logger/logger\";\nimport { Timer } from \"../metrics/operational/Timer\";\nimport { unsubscribed } from \"../observable-operators/unsubscribed\";\nimport { assertUnreachable } from \"../common/assertions\";\nimport type { MetricsClient } from \"../clients/metricsClient\";\nimport { metricsClientFactory } from \"../clients/metricsClient\";\nimport type { LensCore } from \"../lens-core-module/lensCore\";\nimport { lensCoreFactory } from \"../lens-core-module/loader/lensCoreFactory\";\nimport type { RemoteConfiguration } from \"../remote-configuration/remoteConfiguration\";\nimport { remoteConfigurationFactory } from \"../remote-configuration/remoteConfiguration\";\nimport { watermarksLensGroup } from \"../lens/fetchWatermarkLens\";\nimport type { UserDataAccessResolver } from \"../lens/userDataAccessResolver\";\nimport { userDataAccessResolverFactory } from \"../lens/userDataAccessResolver\";\n\nconst logger = getLogger(\"LensState\");\n\nconst createLensState = () => {\n    const actions = defineActions(\n        defineAction(\"applyLens\")<{ lens: Lens; launchData?: LensLaunchData }>(),\n        defineAction(\"downloadComplete\")<Lens>(),\n        defineAction(\"turnedOn\")<Lens>(),\n        defineAction(\"resourcesLoaded\")<Lens>(),\n        defineAction(\"firstFrameProcessed\")<Lens>(),\n        defineAction(\"applyLensComplete\")<Lens>(),\n        defineAction(\"applyLensFailed\")<{ error: LensErrors; lens: Lens }>(),\n        defineAction(\"applyLensAborted\")<Lens>(),\n\n        defineAction(\"removeLens\")(),\n        defineAction(\"turnedOff\")<Lens>(),\n        defineAction(\"removeLensComplete\")(),\n        defineAction(\"removeLensFailed\")<Error>()\n    );\n\n    const states = defineStates(\n        defineState(\"noLensApplied\")(),\n        defineState(\"applyingLens\")<Lens>(),\n        defineState(\"lensApplied\")<Lens>()\n    );\n\n    return new StateMachine(actions, states, states.noLensApplied(), (events) =>\n        merge(\n            events.pipe(\n                // We allow a new lens to be applied at any time, no matter the state.\n                inStates(\"noLensApplied\", \"applyingLens\", \"lensApplied\"),\n                forActions(\"applyLens\"),\n                map(([a]) => states.applyingLens(a.data.lens))\n            ),\n            events.pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"applyLensComplete\"),\n                map(([a]) => states.lensApplied(a.data))\n            ),\n            events.pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"applyLensFailed\"),\n                map(() => states.noLensApplied())\n            ),\n            events.pipe(\n                inStates(\"lensApplied\"),\n                forActions(\"removeLensComplete\"),\n                map(() => states.noLensApplied())\n            )\n        )\n    );\n};\n\nexport type LensErrors = LegalError | LensContentValidationError | LensError;\n\nexport type LensState = ReturnType<typeof createLensState>;\n\nexport const lensStateFactory = Injectable(\n    \"lensState\",\n    [\n        lensCoreFactory.token,\n        lensRepositoryFactory.token,\n        lensAssetRepositoryFactory.token,\n        lensPersistenceStoreFactory.token,\n        legalStateFactory.token,\n        metricsClientFactory.token,\n        remoteConfigurationFactory.token,\n        userDataAccessResolverFactory.token,\n    ] as const,\n    (\n        lensCore: LensCore,\n        lensRepository: LensRepository,\n        lensAssetRepository: LensAssetRepository,\n        lensPersistence: IndexedDBPersistence<ArrayBuffer>,\n        legalState: LegalState,\n        metrics: MetricsClient,\n        remoteConfig: RemoteConfiguration,\n        getUserDataAccess: UserDataAccessResolver\n    ): LensState => {\n        const lensState = createLensState();\n        let firstLensApply = true;\n\n        /**\n         * Apply lens\n         */\n        lensState.events\n            .pipe(\n                forActions(\"applyLens\"),\n\n                // Determine the legal state (e.g. terms have been accepted). Using exhaustMap means while we are\n                // ascertaining legal status (which may include prompting the end user to accept terms), we will ignore\n                // any new applyLens actions.\n                exhaustMap(([a]) =>\n                    of(legalState.actions.requestLegalPrompt()).pipe(\n                        dispatch(legalState),\n                        inStates(\"accepted\", \"rejected\"),\n                        take(1),\n                        map(([, { name }]) => {\n                            if (name === \"accepted\") return a;\n                            return lensState.actions.applyLensFailed({\n                                error: legalError(\n                                    `Failed to apply lens ${a.data.lens.id}. Required legal terms were not accepted.`\n                                ),\n                                lens: a.data.lens,\n                            });\n                        })\n                    )\n                ),\n\n                // The use of switchMap is important so that if we get a new applyLens action while we're still\n                // downloading lens content for a previously-requested lens, we can cancel those requests and ensure\n                // that lenses are applied in the order they're requested.\n                switchMap((a) => {\n                    if (a.name === \"applyLensFailed\") return of(a);\n\n                    const { lens } = a.data;\n                    // Convenience method making dispatching an action with Lens data less verbose.\n                    const dispatch = (action: Extract<Actions<LensState>, { data: Lens }>[\"name\"]) => {\n                        lensState.dispatch(action, lens);\n                    };\n\n                    // We record if this was the first lens apply for this page load, since there may be additional\n                    // sources of latency (e.g. remote configuration that needs to be loaded) on the first apply that\n                    // are not present for subsequent applies.\n                    const applyTimer = new Timer(\"lens\").mark(\"apply\", { first: `${firstLensApply}` });\n                    firstLensApply = false;\n\n                    return forkJoin({\n                        watermarkInput: remoteConfig.getInitializationConfig().pipe(\n                            mergeMap((config) => {\n                                if (!config.watermarkEnabled) return of(undefined);\n\n                                return from(lensRepository.loadLens(\"\", watermarksLensGroup)).pipe(\n                                    mergeMap((watermark) =>\n                                        // NOTE: we expect that watermark lens is preloaded,\n                                        // to not affect loading time of the actual lens\n                                        from(lensRepository.getLensContent(watermark)).pipe(\n                                            map(({ lensBuffer, lensChecksum }): AddLensInput => {\n                                                return {\n                                                    lensId: watermark.id,\n                                                    // Copy buffer, so LC can own the copy\n                                                    lensDataBuffer: lensBuffer.slice(0),\n                                                    lensChecksum,\n                                                    launchData: new ArrayBuffer(0),\n                                                };\n                                            })\n                                        )\n                                    )\n                                );\n                            })\n                        ),\n\n                        lensInput: of(a.data).pipe(\n                            mergeMap(({ lens, launchData }) => {\n                                // If retrieval throws an error, we still want to proceed with the lens\n                                // because persisted data is not a necessity.\n                                return from(lensPersistence.retrieve(lens.id).catch(() => undefined)).pipe(\n                                    map((persistentStore) => ({ lens, launchData, persistentStore }))\n                                );\n                            }),\n\n                            map(({ lens, launchData, persistentStore }) => {\n                                const lensDetails = lensRepository.getLensMetadata(lens.id);\n                                if (!lensDetails) {\n                                    throw new Error(\n                                        `Cannot apply lens ${lens.id}. It has not been loaded by the Lens ` +\n                                            `repository. Use CameraKit.lensRepository.loadLens (or loadLensGroups) ` +\n                                            `to load lens metadata before calling CameraKitSession.applyLens.`\n                                    );\n                                }\n\n                                const { content, isThirdParty } = lensDetails;\n                                if (!content) {\n                                    throw new Error(\n                                        `Cannot apply lens ${lens.id}. Metadata retrieved for this lens does not ` +\n                                            `include the lens content URL.`\n                                    );\n                                }\n\n                                return {\n                                    lens,\n                                    launchData: encodeLensLaunchData(\n                                        launchData ?? {},\n                                        persistentStore ?? new ArrayBuffer(0)\n                                    ),\n                                    content,\n                                    isThirdParty,\n                                };\n                            }),\n\n                            // Load lens assets and the lens itself in parallel. Both count toward lens download time.\n                            // TODO: use RxJS fetch utilities so that these requests can be cancelled on unsubscribe.\n                            mergeMap(({ lens, launchData, content, isThirdParty }) => {\n                                const networkTimer = applyTimer.mark(\"network\");\n\n                                return from(\n                                    Promise.all([\n                                        lensRepository.getLensContent(lens).finally(() => networkTimer.measure(\"lens\")),\n                                        isThirdParty ? getUserDataAccess(lens) : undefined,\n                                        content.assetManifest.length > 0\n                                            ? lensAssetRepository\n                                                  .cacheAssets(content.assetManifest, lens)\n                                                  .finally(() => networkTimer.measure(\"assets\"))\n                                            : Promise.resolve(),\n                                    ])\n                                ).pipe(\n                                    tap(() => {\n                                        networkTimer.measure();\n                                        lensState.dispatch(\"downloadComplete\", lens);\n                                    }),\n                                    map(([{ lensBuffer, lensChecksum }, userDataAccess]): AddLensInput => {\n                                        // NOTE: cached array buffer has to be copied each time in order to be reused,\n                                        // otherwise the original cached copy would be detached by LensCore\n                                        // One optimization can be done here: do not copy the array if getLensContent()\n                                        // returned uncached buffer\n                                        const lensDataBuffer = lensBuffer.slice(0);\n                                        return {\n                                            lensId: lens.id,\n                                            lensDataBuffer,\n                                            lensChecksum,\n                                            launchData,\n                                            apiVisibility: isThirdParty\n                                                ? lensCore.LensApiVisibility.Public\n                                                : lensCore.LensApiVisibility.Private,\n                                            publicApiUserDataAccess:\n                                                userDataAccess === \"restricted\"\n                                                    ? lensCore.UserDataAccess.Restricted\n                                                    : lensCore.UserDataAccess.Unrestricted,\n                                        };\n                                    })\n                                );\n                            })\n                        ),\n                    }).pipe(\n                        // If removeLens is dispatched while downloading, cancel download, don't apply the lens.\n                        takeUntil(lensState.events.pipe(forActions(\"removeLens\"))),\n\n                        // Once the lens has downloaded, we can call replaceLenses. We're not concerned about\n                        // waiting for prior in-progress calls to replaceLenses to complete, because LensCore\n                        // guarantees that calls to replaceLenses will always be processed sequentially in the order\n                        // they are received.\n                        mergeMap(\n                            ({ lensInput, watermarkInput }) =>\n                                new Observable<Actions<LensState>>((subscriber) => {\n                                    const coreTimer = applyTimer.mark(\"core\");\n\n                                    // replaceLenses has the property that if it fails, LensCore guarantees that no\n                                    // lenses are active – so we can safely dispatch applyLensFailed and transition\n                                    // to noLensApplied state.\n                                    lensCore\n                                        .replaceLenses({\n                                            lenses: [\n                                                {\n                                                    ...lensInput,\n                                                    onTurnOn: () => dispatch(\"turnedOn\"),\n                                                    onResourcesLoaded: () => dispatch(\"resourcesLoaded\"),\n\n                                                    // onFirstFrameProcessed marks the end of the lens application for\n                                                    // the end-user -- this is when they see the newly applied lens\n                                                    // begin to render. As such, this is where we stop our overall\n                                                    // latency measurement and report latency metrics.\n                                                    onFirstFrameProcessed: () => {\n                                                        coreTimer.measure(\"first-frame\");\n                                                        applyTimer.measure(\"success\");\n                                                        applyTimer.stopAndReport(metrics);\n                                                        dispatch(\"firstFrameProcessed\");\n                                                    },\n                                                    onTurnOff: () => dispatch(\"turnedOff\"),\n                                                },\n                                                // Watermark is always applied last\n                                                ...(watermarkInput ? [watermarkInput] : []),\n                                            ],\n                                        })\n                                        .then(() => {\n                                            coreTimer.measure(\"success\");\n\n                                            // We emit applyLensComplete (and applyLensFailed, below) on an\n                                            // Observable, which is piped to `dispatch` – this allows `switchMap` to\n                                            // properly cancel the dispatch of these actions if a new applyLens\n                                            // arrives while we're waiting for onSuccess/onFailure.\n                                            //\n                                            // That's desirable behavior, because we don't want the applyingLens\n                                            // state due to a *subsequent applyLens action* to be transitioned to\n                                            // lensApplied by this action.\n                                            subscriber.next(lensState.actions.applyLensComplete(lens));\n                                            subscriber.complete();\n                                        })\n                                        .catch((lensCoreError) => {\n                                            coreTimer.measure(\"failure\");\n                                            applyTimer.measure(\"failure\");\n                                            applyTimer.stopAndReport(metrics);\n\n                                            const message = `Failed to apply lens ${lensInput.lensId}.`;\n                                            const error = /validation failed/.test(lensCoreError.message)\n                                                ? lensContentValidationError(message, lensCoreError)\n                                                : lensError(message, lensCoreError);\n\n                                            subscriber.next(lensState.actions.applyLensFailed({ error, lens }));\n                                            subscriber.complete();\n                                        });\n                                })\n                        ),\n                        catchError((error: LensErrors) => {\n                            applyTimer.measure(\"failure\");\n                            applyTimer.stopAndReport(metrics);\n                            return of(lensState.actions.applyLensFailed({ error, lens }));\n                        }),\n\n                        // If a new applyLens is received, `switchMap` will unsubscribe from this inner observable,\n                        // which stops the current lens application. When this happens we can record a separate metric\n                        // to measure aborted lens applications.\n                        unsubscribed(() => {\n                            applyTimer.measure(\"abort\");\n                            applyTimer.stopAndReport(metrics);\n                        })\n                    );\n                }),\n                dispatch(lensState)\n            )\n            .subscribe({\n                error: logger.error,\n            });\n\n        /**\n         * Remove lens\n         */\n        lensState.events\n            .pipe(\n                inStates(\"lensApplied\", \"noLensApplied\"),\n                forActions(\"removeLens\"),\n                mergeMap(\n                    () =>\n                        new Observable<Actions<LensState>>((subscriber) => {\n                            lensCore\n                                .clearAllLenses()\n                                .then(() => {\n                                    subscriber.next(lensState.actions.removeLensComplete());\n                                    subscriber.complete();\n                                })\n                                .catch((lensCoreError) => {\n                                    const error = new Error(\"Failed to remove lenses.\", { cause: lensCoreError });\n                                    subscriber.next(lensState.actions.removeLensFailed(error));\n                                    subscriber.complete();\n                                });\n                        })\n                ),\n                dispatch(lensState)\n            )\n            .subscribe({\n                error: logger.error,\n            });\n\n        lensState.events\n            .pipe(\n                inStates(\"applyingLens\"),\n                forActions(\"removeLens\"),\n                switchMap(([a]) =>\n                    lensState.events.pipe(\n                        // Wait to remove the lens until it has been applied.\n                        inStates(\"lensApplied\"),\n                        // But cancel the removal if a new applyLens supersedes the current lens. The goal here is to\n                        // make sure the latest apply/remove preempts any previous request to apply/remove.\n                        takeUntil(lensState.events.pipe(forActions(\"applyLens\"))),\n                        map(() => a)\n                    )\n                ),\n                dispatch(lensState)\n            )\n            .subscribe({\n                error: logger.error,\n            });\n\n        // Log transitions\n        lensState.events.subscribe(([a, s]) => {\n            const data = extractLoggableData(a);\n            logger.debug(`Action: \"${a.name}\", state: \"${s.name}\"${data ? \", data: \" + JSON.stringify(data) : \"\"}`);\n        });\n\n        return lensState;\n    }\n);\n\nfunction extractLoggableData(action: Actions<LensState>): Record<string, string> | undefined {\n    switch (action.name) {\n        case \"applyLens\":\n            return { lensId: action.data.lens.id };\n        case \"applyLensFailed\":\n            return { lensId: action.data.lens.id, error: action.data.error.message };\n        case \"downloadComplete\":\n        case \"turnedOn\":\n        case \"resourcesLoaded\":\n        case \"firstFrameProcessed\":\n        case \"applyLensComplete\":\n        case \"applyLensAborted\":\n        case \"turnedOff\":\n            return { lensId: action.data.id };\n        case \"removeLens\":\n        case \"removeLensComplete\":\n            return undefined;\n        case \"removeLensFailed\":\n            return { error: action.data.message };\n        default:\n            assertUnreachable(action);\n    }\n}\n"]}