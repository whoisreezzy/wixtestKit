{"version":3,"file":"LensKeyboard.js","sourceRoot":"","sources":["../../src/session/LensKeyboard.ts"],"names":[],"mappings":"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","sourcesContent":["import { isState, forActions } from \"@snap/state-management\";\nimport { Injectable } from \"@snap/ts-inject\";\nimport { TypedCustomEvent } from \"../events/TypedCustomEvent\";\nimport type { TypedEventListener, TypedEventListenerOptions } from \"../events/TypedEventTarget\";\nimport { TypedEventTarget } from \"../events/TypedEventTarget\";\nimport type { UriHandler, UriResponse } from \"../uri-handlers/UriHandlers\";\nimport type { Lens } from \"../lens/Lens\";\nimport { getLogger } from \"../logger/logger\";\nimport type { LensState } from \"./lensState\";\nimport { lensStateFactory } from \"./lensState\";\n\nconst logger = getLogger(\"LensKeyboard\");\n\n/**\n * \"active\" event payload.\n *\n * This event is emitted when a lens requests a keyboard to be shown or dismissed.\n * The application should listen for this event and display or remove its keyboard UI accordingly.\n */\nexport interface KeyboardActiveEvent {\n    /**\n     * Indicates whether the keyboard should be displayed (`true`) or hidden (`false`).\n     */\n    active: boolean;\n\n    /**\n     * The current text input associated with the keyboard.\n     */\n    text: string;\n\n    /**\n     * The lens that initiated the keyboard request.\n     */\n    lens: Lens;\n\n    /**\n     * @deprecated Clients apps are responsible to create keyboard UI.\n     */\n    element: HTMLTextAreaElement;\n}\n\n/**\n * Defines events emitted by the `Keyboard` API.\n */\nexport type KeyboardEvents = TypedCustomEvent<\"active\", KeyboardActiveEvent>;\n\n/**\n * Listener of {@link KeyboardEvents} events.\n */\nexport type KeyboardEventListener = TypedEventListener<KeyboardEvents>;\n\n/**\n * The `Keyboard` API enables applications to handle text input requests triggered by lenses.\n *\n * Lenses can request a keyboard display by emitting an `active` event. The application is responsible for displaying\n * a keyboard UI in response to this event.\n *\n * As users type, the application sends the typed text back to the lens using {@link Keyboard.sendInputToLens},\n * allowing the lens to display the text accordingly.\n *\n * Lenses can also request the keyboard to be dismissed. When this happens, the application receives an event\n * and should remove the displayed keyboard UI.\n *\n * @example\n * ```ts\n * cameraKitSession.keyboard.addEventListener('active', ({ detail }) => {\n *   const { active, text } = detail;\n *   if (active) {\n *     showKeyboard(text, (newText) => cameraKitSession.keyboard.sendInputToLens(newText));\n *   } else {\n *     hideKeyboard();\n *   }\n * });\n * ```\n *\n * @category Lenses\n */\nexport interface Keyboard {\n    /**\n     * Adds an event listener for keyboard-related events.\n     *\n     * @param type - The type of event to listen for (e.g., \"active\").\n     * @param callback - Function that handles the event.\n     * @param options - Additional options for event listener behavior (optional).\n     */\n    addEventListener: (\n        type: \"active\",\n        callback: TypedEventListener<KeyboardEvents>,\n        options?: TypedEventListenerOptions\n    ) => void;\n\n    /**\n     * Removes a previously added event listener.\n     *\n     * @param type - The type of event to remove.\n     * @param callback - The event listener function to remove.\n     */\n    removeEventListener: (type: \"active\", callback: TypedEventListener<KeyboardEvents>) => void;\n\n    /**\n     * Sends a string of text to the active lens. The application should use this method\n     * to provide user-typed input to the lens for display.\n     *\n     * @param text - The text to send to the lens. Supports escape sequences (e.g., `\\n` for multiline input).\n     */\n    sendInputToLens: (text: string) => void;\n\n    /**\n     * Dismisses the keyboard, clears the text input, and triggers an `active` event with `active: false`.\n     * Applications can use this to remove on-screen text input elements when input is no longer needed.\n     */\n    dismiss: () => void;\n\n    /**\n     * @deprecated Clients apps are responsible to create keyboard UI.\n     */\n    getElement: () => HTMLTextAreaElement;\n}\n\n// eslint-disable-next-line max-len\n// https://github.sc-corp.net/Snapchat/LensCore/blob/4c05e721d0321133d50148e5b37fea5078516abd/Src/Scenarium/Infrastructure/TextInputSystem.Scn.hpp#L38\ntype KeyboardType = \"Text\" | \"Number\" | \"Phone\" | \"Url\";\n\n// eslint-disable-next-line max-len\n// https://github.sc-corp.net/Snapchat/LensCore/blob/4c05e721d0321133d50148e5b37fea5078516abd/Src/Scenarium/Infrastructure/TextInputSystem.Scn.hpp#L44\ntype ReturnKeyType = \"Done\" | \"Go\" | \"Next\" | \"Return\" | \"Search\" | \"Send\";\n\ninterface RequestKeyboardData {\n    enablePreview: boolean;\n    end: number;\n    keyboardType: KeyboardType;\n    returnKeyType: ReturnKeyType;\n    start: number;\n    text: string;\n}\n\ninterface DismissReply {\n    keyboardOpen: false;\n}\n\ninterface SetTextReply {\n    text: string;\n    start: number;\n    end: number;\n    done: boolean;\n    shouldNotify: boolean;\n}\n\n/** @internal */\nexport class LensKeyboard {\n    public readonly uriHandler: UriHandler;\n    private readonly events: TypedEventTarget<KeyboardEvents>;\n    private readonly element: HTMLTextAreaElement;\n    private active = false;\n    private text: string | undefined = undefined;\n    private reply: (response: UriResponse) => void = () => {};\n\n    constructor(private readonly lensState: LensState) {\n        this.onElementKeyPress = this.onElementKeyPress.bind(this);\n        this.events = new TypedEventTarget<KeyboardEvents>();\n        this.element = document.createElement(\"textarea\");\n        this.element.addEventListener(\"keypress\", this.onElementKeyPress);\n        this.uriHandler = {\n            uri: \"app://textInput/\",\n            handleRequest: (request, reply) => {\n                if (request.uri === \"app://textInput/requestKeyboard\") {\n                    const data = JSON.parse(new TextDecoder().decode(request.data)) as RequestKeyboardData;\n                    this.element.value = data.text;\n                    this.text = data.text;\n                    this.reply = reply;\n                    this.active = true;\n                    this.notifyClient();\n                    this.element.focus();\n                } else if (request.uri === \"app://textInput/dismissKeyboard\") {\n                    this.active = false;\n                    this.sendReply({ keyboardOpen: false });\n                    this.notifyClient();\n                } else {\n                    logger.error(new Error(`Unhandled lens keyboard request '${request.uri}'.`));\n                }\n            },\n        };\n        lensState.events.pipe(forActions(\"turnedOff\")).subscribe(() => {\n            this.dismiss();\n        });\n    }\n\n    dismiss(): void {\n        this.active = false;\n        this.element.value = \"\";\n        this.text = \"\";\n        this.sendReply({ keyboardOpen: false });\n        this.notifyClient();\n    }\n\n    getElement(): HTMLTextAreaElement {\n        return this.element;\n    }\n\n    sendInputToLens(text: string): void {\n        this.element.value = text;\n        this.text = text;\n        this.sendReply({\n            text: text,\n            start: text.length,\n            end: text.length,\n            done: true,\n            shouldNotify: true,\n        });\n    }\n\n    addEventListener(\n        type: \"active\",\n        callback: TypedEventListener<KeyboardEvents>,\n        options?: TypedEventListenerOptions\n    ): void {\n        this.events.addEventListener(type, callback, options);\n    }\n\n    removeEventListener(type: \"active\", callback: TypedEventListener<KeyboardEvents>): void {\n        this.events.removeEventListener(type, callback);\n    }\n\n    toPublicInterface(): Keyboard {\n        return {\n            addEventListener: this.addEventListener.bind(this),\n            removeEventListener: this.removeEventListener.bind(this),\n            sendInputToLens: this.sendInputToLens.bind(this),\n            dismiss: this.dismiss.bind(this),\n            getElement: this.getElement.bind(this),\n        };\n    }\n\n    destroy() {\n        // TODO: remove when removing deprecated element ref\n        this.element.removeEventListener(\"keypress\", this.onElementKeyPress);\n    }\n\n    private sendReply(data: DismissReply | SetTextReply) {\n        this.reply({\n            code: 200,\n            description: \"\",\n            contentType: \"application/json\",\n            data: new TextEncoder().encode(JSON.stringify(data)),\n        });\n    }\n\n    private notifyClient(): void {\n        const state = this.lensState.getState();\n        // If lens keyboard status is changing, we know a lens must be applied.\n        if (isState(state, \"noLensApplied\")) return;\n        this.events.dispatchEvent(\n            new TypedCustomEvent(\"active\", {\n                element: this.element,\n                active: this.active,\n                text: this.text ?? \"\",\n                // If the keyboard is up, it has been triggered by an active lens.\n                lens: state.data,\n            })\n        );\n    }\n\n    private onElementKeyPress(event: KeyboardEvent) {\n        if (event.code === \"Enter\" && !event.shiftKey) {\n            event.preventDefault();\n            this.sendInputToLens(this.element.value);\n        }\n    }\n}\n\n/**\n * Factory function for creating a LensKeyboard instance.\n *\n * @internal\n */\nexport const lensKeyboardFactory = Injectable(\n    \"lensKeyboard\",\n    [lensStateFactory.token] as const,\n    (lensState: LensState) => new LensKeyboard(lensState)\n);\n"]}