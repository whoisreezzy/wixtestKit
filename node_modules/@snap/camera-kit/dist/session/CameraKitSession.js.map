{"version":3,"file":"CameraKitSession.js","sourceRoot":"","sources":["../../src/session/CameraKitSession.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/member-ordering */\nimport type { Observable, Subscription } from \"rxjs\";\nimport { filter, firstValueFrom, map, of, takeUntil, tap } from \"rxjs\";\nimport { dispatch, forActions, inStates, isAction, isState } from \"@snap/state-management\";\nimport { Injectable } from \"@snap/ts-inject\";\nimport type { Lens } from \"../lens/Lens\";\nimport { isLens } from \"../lens/Lens\";\nimport { lensCoreFactory } from \"../lens-core-module/loader/lensCoreFactory\";\nimport type { LensLaunchData } from \"../lens/LensLaunchData\";\nimport { isLensLaunchDataOrUndefined } from \"../lens/LensLaunchData\";\nimport { getTypeName, validate } from \"../common/validate\";\nimport { TypedEventTarget } from \"../events/TypedEventTarget\";\nimport { TypedCustomEvent } from \"../events/TypedCustomEvent\";\nimport type { CameraKitDeviceOptions, CameraKitSource } from \"../media-sources/CameraKitSource\";\nimport { isCameraKitSource, isPartialCameraKitDeviceOptionsOrUndefined } from \"../media-sources/CameraKitSource\";\nimport { cameraKitSourceError, LensExecutionError } from \"../namedErrors\";\nimport { createMediaStreamSource } from \"../media-sources/MediaStreamSource\";\nimport { createVideoSource } from \"../media-sources/VideoSource\";\nimport type { LogEntry } from \"../logger/logger\";\nimport { getLogger } from \"../logger/logger\";\nimport { errorLoggingDecorator } from \"../logger/errorLoggingDecorator\";\nimport { logEntriesFactory } from \"../logger/logEntries\";\nimport type { PageVisibility } from \"../common/pageVisibility\";\nimport { pageVisibilityFactory } from \"../common/pageVisibility\";\nimport type { LensCore } from \"../lens-core-module/lensCore\";\nimport type { CanvasType } from \"../lens-core-module/generated-types\";\nimport { isUndefined, isValidNumber } from \"../common/typeguards\";\nimport { LensPerformanceMetrics } from \"./LensPerformanceMetrics\";\nimport type { LensState } from \"./lensState\";\nimport { lensStateFactory } from \"./lensState\";\nimport type { SessionState } from \"./sessionState\";\nimport { sessionStateFactory } from \"./sessionState\";\nimport type { Keyboard, LensKeyboard } from \"./LensKeyboard\";\nimport { lensKeyboardFactory } from \"./LensKeyboard\";\nimport type { CameraKitSessionEvents } from \"./CameraKitSessionEvents\";\nimport { isPublicLensError } from \"./CameraKitSessionEvents\";\n\nconst logger = getLogger(\"CameraKitSession\");\n\nfunction isAllowedSource(value: unknown): value is CameraKitSource | MediaStream | HTMLVideoElement {\n    return isCameraKitSource(value) || isMediaStream(value) || isHTMLVideoElement(value);\n}\nfunction isMediaStream(value: unknown): value is MediaStream {\n    return value instanceof MediaStream;\n}\nfunction isHTMLVideoElement(value: unknown): value is HTMLVideoElement {\n    return value instanceof HTMLVideoElement;\n}\n\nfunction isRenderTargetOrUndefined(value: unknown): value is RenderTarget | undefined {\n    return isUndefined(value) || value === \"live\" || value === \"capture\";\n}\n\n/**\n * Enumerates the supported render targets.\n *\n * Lenses may render to different render targets, as designed by the lens creator. In CameraKit, it's possible to choose\n * which render target to render, and the result for each target is available as a separate `<canvas>` element.\n *\n * @category Rendering\n * @category Lenses\n */\nexport type RenderTarget = \"live\" | \"capture\";\n\n/**\n * A CameraKitSession represents a single rendering pipeline connecting an input media source to output `<canvas>`\n * elements. When a Lens is applied to the session, CameraKit uses the Lens to transform the input media into rendered\n * output.\n *\n * CameraKitSession is the primary object that applications interact with when integrating the CameraKit SDK.\n *\n * A CameraKitSession instance is obtained by calling {@link CameraKit.createSession}.\n *\n * @example\n * ```ts\n * const cameraKit = await bootstrapCameraKit(config)\n * const session = await cameraKit.createSession()\n * ```\n *\n * @category Rendering\n * @category Lenses\n */\nclass CameraKitSession {\n    /**\n     * CameraKitSession renders video output to a `<canvas>` element. In fact, each session contains two canvas outputs\n     * corresponding to the RenderTargets used by Lens creators, when using LensStudio to create a Lens.\n     *\n     * The `live` output renders content suitable for the Lens user (e.g. it may contain additional UI elements\n     * applicable only to the person applying the lens). The `capture` output renders content suitable for sharing with\n     * other users (e.g. sent to the other members of a video call, or saved to disk for sharing later).\n     *\n     * For many lenses, these outputs are identical – but each lens is free to render differently, based on its own\n     * use-case.\n     */\n    readonly output: {\n        live: HTMLCanvasElement;\n        capture: HTMLCanvasElement;\n    };\n\n    /**\n     * Indicates whether or not the session is currently rendering. If `false`, rendering is stopped. Otherwise the\n     * value indicates which output is being rendered.\n     */\n    playing: {\n        live: boolean;\n        capture: boolean;\n    };\n\n    /**\n     * Add event listeners here to handle events which occur during the CameraKitSession.\n     *\n     * **Note:** Applications may want to handle the `error` event, and check the contained error type -- if the type\n     * is {@link LensExecutionError}, this means the current lens was unable to render and CameraKit will automatically\n     * remove the lens.\n     *\n     * @example\n     * ```ts\n     * cameraKitSession.events.addEventListener('error', ({ detail }) => {\n     *   if (detail.error.name === 'LensExecutionError') {\n     *     console.log(`Lens ${detail.lens.name} encountered an error and was removed. Please pick a different lens.`)\n     *   }\n     * })\n     * ```\n     */\n    readonly events = new TypedEventTarget<CameraKitSessionEvents>();\n\n    /**\n     * Use this to measure current lens performance.\n     */\n    readonly metrics: LensPerformanceMetrics;\n\n    /**\n     * The {@link Keyboard} API enables applications to handle keyboard input requests from lenses.\n     * When a lens requests a keyboard, the app displays it in its preferred UI. As users type,\n     * the app sends the text back to the lens for display. The lens can also request keyboard dismissal,\n     * prompting the app to remove the displayed keyboard.\n     */\n    readonly keyboard: Keyboard;\n\n    private readonly removePageVisibilityHandlers: () => void;\n    private source?: CameraKitSource;\n    private subscriptions: Subscription[];\n\n    /**\n     * @internal\n     */\n    constructor(\n        private readonly innerKeyboard: LensKeyboard,\n        private readonly lensCore: LensCore,\n        private readonly sessionState: SessionState,\n        private readonly lensState: LensState,\n        logEntries: Observable<LogEntry>,\n        pageVisibility: PageVisibility\n    ) {\n        this.keyboard = innerKeyboard.toPublicInterface();\n        const outputs = this.lensCore.getOutputCanvases();\n        this.output = {\n            live: outputs[this.lensCore.CanvasType.Preview.value],\n            capture: outputs[this.lensCore.CanvasType.Capture.value],\n        };\n        this.playing = {\n            live: false,\n            capture: false,\n        };\n\n        this.metrics = new LensPerformanceMetrics(this.lensCore);\n\n        const removeOnHidden = pageVisibility.onPageHidden(() => this.sessionState.dispatch(\"suspend\", this));\n        const removeOnVisible = pageVisibility.onPageVisible(() => this.sessionState.dispatch(\"resume\", this));\n        this.removePageVisibilityHandlers = () => {\n            removeOnHidden();\n            removeOnVisible();\n        };\n\n        this.subscriptions = [\n            // In case of an abort error, the only option is to destroy the current session,\n            // as it becomes inoperable.\n            lensCore.errors\n                .pipe(filter((error) => error.name === \"LensCoreAbortError\"))\n                .subscribe(() => this.destroy()),\n\n            // In case of LensCore lens execution error, we must remove the lens from rendering\n            // NOTE: LensCore doesn't differentiate recoverable vs non-recoverable errors and\n            // it is recommended to always remove the lens.\n            lensCore.errors\n                .pipe(filter((error) => error.name !== \"LensCoreAbortError\" && error.isFrameError))\n                .subscribe(() => this.removeLens()),\n\n            // Forward logged errors that are public to the app\n            logEntries\n                .pipe(\n                    filter((entry) => entry.level === \"error\"),\n                    map((entry) => entry.messages.find((e) => e instanceof Error)),\n                    filter(isPublicLensError)\n                )\n                .subscribe((error) => {\n                    const state = lensState.getState();\n                    if (!isState(state, \"noLensApplied\")) {\n                        this.events.dispatchEvent(new TypedCustomEvent(\"error\", { error, lens: state.data }));\n                    } else {\n                        // NOTE: at this point the error is already reported, so we can just log a warning\n                        logger.warn(\"Lens error occurred even though there is no active lens.\", error);\n                    }\n                }),\n        ];\n    }\n\n    /**\n     * Apply a Lens to this session.\n     *\n     * This method will download (and cache) the Lens executable, and then use that Lens for rendering. If the session\n     * is currently playing, this will immediately update the rendered output. Otherwise, the new Lens will be used\n     * when session playback in resumed.\n     *\n     * Calling `applyLens` replaces any prior Lens – only one Lens is allowed at a time (per session).\n     *\n     * **NOTE**: Errors may occur after the Lens is applied. If the Lens encounters errors while rendering,\n     * Camera Kit will automatically remove the Lens from the session and emit a {@link LensExecutionError} event.\n     * Applications may want to listen for this error and, for example,\n     * prevent the Lens from being selected again by the user.\n     *\n     * ```ts\n     * session.events.addEventListener(\"error\", ({ detail }) => {\n     *   if (detail.error.name === \"LensExecutionError\") {\n     *     preventFutureLensSelection(detail.lens);\n     *     showMessage(\"We're sorry, but the Lens you selected encountered an error. Please choose a different Lens.\");\n     *   }\n     * });\n     * ```\n     *\n     * @param lens The Lens to apply to this session.\n     * @param launchData This can optionally be provided to pass some initial data to the Lens – only certain Lenses\n     * expect launch data.\n     * @returns A promise which can have the following results:\n     * 1. Resolved with `true`: the Lens has been applied.\n     * 2. Resolved with `false`: the Lens has not been applied, but no error occurred – this can happen if a\n     * subsequent call to `applyLens` interrupted the Lens application.\n     * 3. Rejected: the Lens has not been applied because an error occurred. This can happen if:\n     *   - The Lens ID cannot be found in the LensRepository (use LensRepository to load the Lens before calling this\n     *     method)\n     *   - Lens content download fails, or the download of any required lens assets fails.\n     *   - An internal failure occurs in the Lens rendering engine when attempting to apply the Lens.\n     */\n    @validate(isLens, isLensLaunchDataOrUndefined)\n    @errorLoggingDecorator(logger)\n    async applyLens(lens: Lens, launchData?: LensLaunchData): Promise<boolean> {\n        const action = this.lensState.actions.applyLens({ lens, launchData });\n        return firstValueFrom(\n            of(action).pipe(\n                dispatch(this.lensState),\n\n                // If another applyLens occurs while we're waiting, resolve this applyLens promise early – we're no\n                // longer waiting for the requested lens to be applied.\n                takeUntil(\n                    this.lensState.events.pipe(\n                        forActions(\"applyLens\"),\n                        filter(([a]) => a !== action)\n                    )\n                ),\n\n                // If lens application failed, convert this into a rejected promise by throwing the error.\n                tap(([a]) => {\n                    if (isAction(a, \"applyLensFailed\") && a.data.lens.id === lens.id) throw a.data.error;\n                }),\n\n                inStates(\"lensApplied\"),\n\n                map(() => true)\n            ),\n            // The default value is used if `takeUntil` completes the Observable early – i.e. the lens was not\n            // applied (application was interrupted by a new call to `applyLens`), so we'll resolve with `false`.\n            { defaultValue: false }\n        );\n    }\n\n    /**\n     * Remove a Lens from this session.\n     *\n     * When a Lens is removed, rendering continues if the session is playing. It will just render the session input\n     * directly to the outputs without any image processing.\n     *\n     * @returns A promise which can have the following results:\n     * 1. Resolved with `true`: the session's rendered output has no lens applied.\n     * 2. Resolved with `false`: the current lens has been removed, but a subsequent call to `applyLens` means that the\n     * session's rendered output will still have a (new) lens applied.\n     * 3. Rejected: the lens has failed to be removed. This can happen if an internal failure occurs in the Lens\n     * rendering engine when attempting to remove the lens.\n     */\n    @errorLoggingDecorator(logger)\n    async removeLens(): Promise<boolean> {\n        if (isState(this.lensState.getState(), \"noLensApplied\")) return true;\n        return firstValueFrom(\n            of(this.lensState.actions.removeLens()).pipe(\n                dispatch(this.lensState),\n                // If lens removal failed, convert this into a rejected promise by throwing the error.\n                tap(([a]) => {\n                    if (isAction(a, \"removeLensFailed\")) throw a.data;\n                }),\n                inStates(\"noLensApplied\"),\n\n                // If applyLens is called while we're waiting for removal, complete immediately – applying the next lens\n                // will replace the current one.\n                takeUntil(this.lensState.events.pipe(forActions(\"applyLens\"))),\n                map(() => true)\n            ),\n            // The default value is used if `takeUntil` completes the Observable early (otherwise firstValueFrom will\n            // return a rejected Promise).\n            { defaultValue: false }\n        );\n    }\n\n    /**\n     * Start/resume session playback – LensCore will begin rendering frames to the output.\n     *\n     * If no source has been set for the session, calling `play()` will update the playing state, but no actual image\n     * processing will occur until `setSource()` is called.\n     *\n     * @example\n     * ```ts\n     * const cameraKitSession = await cameraKit.createSession()\n     * await cameraKitSession.setSource(mySource)\n     * await cameraKitSession.play()\n     *\n     * // If you call `play` before `setSource`, the call to `play` will resolve but playback will only begin once a\n     * // media source has been set.\n     * ```\n     *\n     * @param target Specify the {@link RenderTarget} to render. Defaults to the `live` RenderTarget.\n     * @returns Promise resolves when playback state has been updated. If no source has been set, this means `play` will\n     * resolve before any frames are processed -- but once a source is set, frames will immediately begin processing.\n     */\n    @validate(isRenderTargetOrUndefined)\n    @errorLoggingDecorator(logger)\n    async play(target: RenderTarget = \"live\"): Promise<void> {\n        if (this.playing[target]) return;\n\n        this.playing[target] = true;\n        const type = this.renderTargetToCanvasType(target);\n        return this.lensCore.playCanvas({ type }).catch((error) => {\n            this.playing[target] = false;\n            throw error;\n        });\n    }\n\n    /**\n     * Pause session playback – LensCore will stop rendering frames to the output.\n     *\n     * @param target Specify the RenderTarget to pause playback. May be either `'live'` or `'capture'`.\n     * Default is `'live'`.\n     * @returns Promise resolves when playback has stopped.\n     */\n    @validate(isRenderTargetOrUndefined)\n    @errorLoggingDecorator(logger)\n    async pause(target: RenderTarget = \"live\"): Promise<void> {\n        if (this.playing[target] === false) return;\n        this.playing[target] = false;\n        const type = this.renderTargetToCanvasType(target);\n        return this.lensCore.pauseCanvas({ type }).catch((error) => {\n            this.playing[target] = true;\n            throw error;\n        });\n    }\n\n    /**\n     * Mute all sounds (default SDK state is unmuted).\n     *\n     * @param fade Do we want audio to fade out?\n     */\n    @errorLoggingDecorator(logger)\n    mute(fade: boolean = false): void {\n        this.lensCore.setAllSoundsMuted({\n            muted: true,\n            fade,\n        });\n    }\n\n    /**\n     * Unmute all sounds.\n     *\n     * @param fade Do we want audio to fade in?\n     */\n    @errorLoggingDecorator(logger)\n    unmute(fade: boolean = false): void {\n        this.lensCore.setAllSoundsMuted({\n            muted: false,\n            fade,\n        });\n    }\n\n    /**\n     * Set the media source for this session.\n     *\n     * Sessions may only have one source at a time - if `setSource` is called multiple times, subsequent calls replace\n     * the prior source. Setting the source does not trigger rendering (that’s done by `session.play()`). If the session\n     * is already playing, setting the source will immediately begin rendering the new source.\n     *\n     * The CameraKit SDK provides implementations for various common sources, which applications can create using the\n     * following functions:\n     * - {@link createMediaStreamSource}\n     * - {@link createVideoSource}\n     * - {@link createImageSource}\n     *\n     * **Important:** Once a source has been set for a session, it cannot be set again, even if it has been replaced\n     * by another one. You must provide a new instance of {@link CameraKitSource} to {@link CameraKitSession.setSource}.\n     * If you want to reuse the existing source, you can use its {@link CameraKitSource.copy} method to create a new\n     * instance.\n     *\n     * @param source A CameraKitSource object representing input media (e.g. a webcam stream, video, or some other\n     * source of image data), which CameraKit will supply to Lenses in order for them to render effects on top of that\n     * source.\n     * @returns Promise is resolved when the source has successfully been set. If the session was already in the playing\n     * state, the Promise resolves when the first frame from the new source has been rendered. The resolved value is\n     * the {@link CameraKitSource} object attached to the session.\n     */\n    async setSource(source: CameraKitSource): Promise<CameraKitSource>;\n    async setSource(\n        source: MediaStream | HTMLVideoElement,\n        options?: Partial<CameraKitDeviceOptions>\n    ): Promise<CameraKitSource>;\n\n    @validate(isAllowedSource, isPartialCameraKitDeviceOptionsOrUndefined)\n    @errorLoggingDecorator(logger)\n    async setSource(\n        source: CameraKitSource | MediaStream | HTMLVideoElement,\n        options: Partial<CameraKitDeviceOptions> = {}\n    ): Promise<CameraKitSource> {\n        await this.safelyDetachSource();\n\n        // For convenience, we allow callers to pass in native objects (e.g. MediaStream) as well as CameraKitSource.\n        // Native objects are wrapped in corresponding CameraKitSource classes with default options.\n        const cameraKitSource = isMediaStream(source)\n            ? createMediaStreamSource(source, options)\n            : isHTMLVideoElement(source)\n            ? createVideoSource(source, options)\n            : source;\n\n        const priorPlayingState = this.playing;\n        this.playing = {\n            live: false,\n            capture: false,\n        };\n\n        // The source will provide its data to LensCore, and use other LensCore APIs (e.g. setRenderSize,\n        // setInputTransform) to render the source correctly.\n        await cameraKitSource.attach(this.lensCore, (error) => {\n            logger.error(cameraKitSourceError(\"Error occurred during source attachment.\", error));\n        });\n\n        // If attachment is successful, we'll update our source so that we can detach it later.\n        this.source = cameraKitSource;\n\n        // Finally we'll resume playback, if appropriate.\n        if (priorPlayingState.live) await this.play(\"live\");\n        if (priorPlayingState.capture) await this.play(\"capture\");\n\n        return cameraKitSource;\n    }\n\n    /**\n     * Set an FPS limit.\n     *\n     * This may be useful to reduce CPU/GPU resource usage by CameraKit if, for example, the input\n     * media source has a low FPS – CameraKit would then not try to render more frequently than the source produces\n     * new frames.\n     *\n     * This may also be useful to gracefully degrade performance in situations where lowering FPS is preferable over\n     * alternatives.\n     *\n     * @param fpsLimit A maximum FPS, rendering will not exceed this limit\n     * @returns Promise is resolved when the limit is successfully set.\n     */\n    @validate(isValidNumber)\n    @errorLoggingDecorator(logger)\n    async setFPSLimit(fpsLimit: number): Promise<void> {\n        // LensCore uses 0 to remove the limit.\n        const fps = fpsLimit < Number.POSITIVE_INFINITY ? fpsLimit : 0;\n        return this.lensCore.setFPSLimit({ fps });\n    }\n\n    /**\n     * Destroy the session.\n     *\n     * The session will become inoperable. Frame processing stops, and any session-scoped graphical resources are freed.\n     */\n    @errorLoggingDecorator(logger)\n    async destroy(): Promise<void> {\n        try {\n            await this.lensCore.clearAllLenses();\n            await this.lensCore.teardown();\n        } catch (error) {\n            // If a LensCore is in an aborted state, the above lines may throw an error.\n            // In such cases, we should continue with the cleanup process.\n            // We are also not interested in reporting these errors to our backend.\n            logger.warn(\"An error occurred in LensCore during the session termination process.\", error);\n        }\n        this.subscriptions.forEach((sub) => sub.unsubscribe());\n        await this.safelyDetachSource();\n        this.removePageVisibilityHandlers();\n        this.sessionState.dispatch(\"destroy\", undefined);\n        this.innerKeyboard.destroy();\n    }\n\n    private renderTargetToCanvasType(target: RenderTarget): CanvasType {\n        return target === \"capture\" ? this.lensCore.CanvasType.Capture : this.lensCore.CanvasType.Preview;\n    }\n\n    private async safelyDetachSource(): Promise<void> {\n        if (this.source) {\n            try {\n                await this.source.detach((error) => {\n                    logger.error(cameraKitSourceError(\"Error occurred during source detachment.\", error));\n                });\n                // If there's a failure to detach, we will report the error and proceed. Failure to detach may lead to a\n                // memory leak, but it shouldn't prevent us from switching to the new source.\n            } catch (error) {\n                logger.error(\n                    cameraKitSourceError(`Detaching prior source of type ${getTypeName(this.source)} failed.`, error)\n                );\n            }\n        }\n    }\n}\n\n// NOTE: jest doesn't like default exports of classes with decorated methods.\nexport { CameraKitSession };\n\n/**\n * @internal\n */\nexport const cameraKitSessionFactory = Injectable(\n    \"CameraKitSession\",\n    [\n        lensCoreFactory.token,\n        logEntriesFactory.token,\n        lensKeyboardFactory.token,\n        sessionStateFactory.token,\n        lensStateFactory.token,\n        pageVisibilityFactory.token,\n    ] as const,\n    (\n        lensCore: LensCore,\n        logEntries: Observable<LogEntry>,\n        keyboard: LensKeyboard,\n        sessionState: SessionState,\n        lensState: LensState,\n        pageVisibility: PageVisibility\n    ) => new CameraKitSession(keyboard, lensCore, sessionState, lensState, logEntries, pageVisibility)\n);\n"]}