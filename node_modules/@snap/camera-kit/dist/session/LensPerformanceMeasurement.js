const getDefaultFrameMetricsState = () => ({
    avgFps: 0,
    averageProcessingTime: 0,
    n: 0,
    processingTimeBuckets: new Uint32Array(frameProcessingTimeMedianMax + 1),
    procFrameCount: 0,
    procFrameMean: 0,
    procFrameD2: 0,
});
const frameDurationThreshold = 1;
const frameProcessingTimeMedianMax = 200;
export class LensPerformanceMeasurement {
    constructor(instances) {
        this.instances = instances;
        this.state = Object.assign({}, getDefaultFrameMetricsState());
        this.instances.add(this);
    }
    update(processingTimeMs) {
        this.computeRunningStats(processingTimeMs);
    }
    measure() {
        let median = 0;
        let count = 0;
        for (; median < this.state.processingTimeBuckets.length; median++) {
            count += this.state.processingTimeBuckets[median];
            if (count >= (this.state.n + 1) / 2)
                break;
        }
        return {
            avgFps: this.state.avgFps,
            lensFrameProcessingTimeMsAvg: this.state.procFrameMean,
            lensFrameProcessingTimeMsStd: Math.sqrt(this.state.procFrameD2 / this.state.procFrameCount),
            lensFrameProcessingTimeMsMedian: this.state.n > 0 ? median : 0,
            lensFrameProcessingN: this.state.n,
        };
    }
    reset() {
        this.state = Object.assign({}, getDefaultFrameMetricsState());
    }
    end() {
        this.instances.delete(this);
    }
    computeRunningStats(processingTimeMs) {
        const delta = processingTimeMs - this.state.procFrameMean;
        this.state.procFrameCount += 1;
        this.state.procFrameMean += delta / this.state.procFrameCount;
        const delta2 = processingTimeMs - this.state.procFrameMean;
        this.state.procFrameD2 += delta * delta2;
        if (this.priorFrameCompletedTime === undefined) {
            this.priorFrameCompletedTime = performance.now();
        }
        else {
            const frameDurationSec = (performance.now() - this.priorFrameCompletedTime) / 1000;
            if (frameDurationSec < frameDurationThreshold) {
                this.state.avgFps = (this.state.avgFps + 1 / frameDurationSec) / 2;
            }
            this.priorFrameCompletedTime = performance.now();
        }
        this.state.n++;
        this.state.processingTimeBuckets[Math.min(Math.round(processingTimeMs), frameProcessingTimeMedianMax)]++;
    }
}
//# sourceMappingURL=LensPerformanceMeasurement.js.map