{"version":3,"file":"createTsProtoClient.js","sourceRoot":"","sources":["../../src/clients/createTsProtoClient.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAwCzD,SAAS,YAAY,CAAI,OAA0B,EAAE,IAAO;IACxD,OAAO,MAAM,OAAO;QAChB;YACI,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,CAAC;QACnD,CAAC;QAED,MAAM,CAAC,iBAAiB,CAAC,IAAgB;YACrC,OAAO,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,EAAa,CAAC;QAC1E,CAAC;QAED,eAAe;YACX,OAAO,OAAO,CAAC,MAAM,CAAC,IAAW,CAAC,CAAC,MAAM,EAAE,CAAC;QAChD,CAAC;QAED,QAAQ;YACJ,OAAO,IAAI,CAAC;QAChB,CAAC;KACJ,CAAC;AACN,CAAC;AAaD,MAAM,UAAU,mBAAmB,CAC/B,iBAAoB,EACpB,OAAoB;IAEpB,OAAO,WAAW,CACd,OAAO,CAAC,iBAAiB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,UAAU,EAAE,gBAAgB,CAAC,EAAE,EAAE;QACtE,OAAO;YACH,UAAU;YACV,CAAO,OAAgB,EAAE,EAAE;gBACvB,MAAM,WAAW,GAAG,YAAY,CAAC,gBAAgB,CAAC,WAAW,EAAE,OAAO,CAAC,CAAC;gBACxE,MAAM,YAAY,GAAG,YAAY,CAAC,gBAAgB,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;gBACrE,OAAO,OAAO,CAAC;oBACX,WAAW,EAAE,iBAAiB,CAAC,QAAQ;oBACvC,UAAU,EAAE,gBAAgB,CAAC,IAAI;oBACjC,WAAW;oBACX,YAAY;iBACf,CAAC,CAAC;YACP,CAAC,CAAA;SACJ,CAAC;IAMN,CAAC,CAAC,CACsB,CAAC;AACjC,CAAC","sourcesContent":["import type { grpc } from \"@improbable-eng/grpc-web\";\nimport type { BinaryWriter } from \"@bufbuild/protobuf/wire\";\nimport { entries, fromEntries } from \"../common/entries\";\nimport type { Result } from \"../common/result\";\nimport type { Exact, DeepPartial } from \"../generated-proto/pb_schema/camera_kit/v3/service\";\nimport type { GrpcHandler } from \"./grpcHandler\";\n\ntype TsProtoServiceDefinition<Methods extends TsProtoMethods> = {\n    name: string;\n    fullName: string;\n    methods: Methods;\n};\n\ntype TsProtoMethods = { [methodName: string]: TsProtoMethodDefinition<any, any> };\n\ntype TsProtoMethodDefinition<Request, Response> = {\n    name: string;\n    requestType: TsProtoMessage<Request>;\n    responseType: TsProtoMessage<Response>;\n};\n\ntype TsProtoMessage<M> = {\n    encode: (message: M) => BinaryWriter;\n    decode: (message: Uint8Array) => M;\n    fromPartial: (partialMessage: any) => M;\n};\n\nexport type TsProtoServiceClient<S extends TsProtoServiceDefinition<any>> = {\n    [MethodName in keyof S[\"methods\"]]: InferTsProtoMethod<S[\"methods\"][MethodName]>;\n};\n\ntype InferTsProtoMethod<M extends TsProtoMethodDefinition<any, any>> = M extends TsProtoMethodDefinition<\n    infer Request,\n    infer Response\n>\n    ? <I extends Exact<DeepPartial<Request>, I>>(\n          request: I\n      ) => Promise<\n          Result<grpc.UnaryOutput<Response & grpc.ProtobufMessage>, grpc.UnaryOutput<Response & grpc.ProtobufMessage>>\n      >\n    : never;\n\nfunction messageClass<M>(message: TsProtoMessage<M>, data: M): grpc.ProtobufMessageClass<grpc.ProtobufMessage> {\n    return class Message implements grpc.ProtobufMessage {\n        constructor() {\n            Object.assign(this, message.fromPartial(data));\n        }\n\n        static deserializeBinary(data: Uint8Array): Message {\n            return new (messageClass(message, message.decode(data)))() as Message;\n        }\n\n        serializeBinary(): Uint8Array {\n            return message.encode(this as any).finish();\n        }\n\n        toObject(): this {\n            return this;\n        }\n    };\n}\n\n/**\n * Convert a service definition generated by ts-proto (using the `outputServices=generic-definitions` CLI option) into\n * a working client.\n *\n * @param serviceDefinition\n * @param handler\n * @returns A client that can make requests to a remote service by sending Protobuf-encoded messages over HTTP using the\n * grpc-web package.\n *\n * @internal\n */\nexport function createTsProtoClient<S extends TsProtoServiceDefinition<TsProtoMethods>>(\n    serviceDefinition: S,\n    handler: GrpcHandler\n): TsProtoServiceClient<S> {\n    return fromEntries(\n        entries(serviceDefinition.methods).map(([methodName, methodDefinition]) => {\n            return [\n                methodName,\n                async (request: unknown) => {\n                    const requestType = messageClass(methodDefinition.requestType, request);\n                    const responseType = messageClass(methodDefinition.responseType, {});\n                    return handler({\n                        serviceName: serviceDefinition.fullName,\n                        methodName: methodDefinition.name,\n                        requestType,\n                        responseType,\n                    });\n                },\n            ];\n            // Safety: We're mapping from the method definitions object into the GrpcServiceClient object in a manner\n            // that preserves each key in the method definitions object, pairing it with the corresponding\n            // serialization/deserialization logic for that particular method. But in doing this, we lose type\n            // specificity by converting the method definition object to a list of entries, mapping them, and then\n            // converting back into the client object -- so we're forced into this type cast.\n        })\n    ) as TsProtoServiceClient<S>;\n}\n"]}