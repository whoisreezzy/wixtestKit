import type { grpc } from "@improbable-eng/grpc-web";
import type { BinaryWriter } from "@bufbuild/protobuf/wire";
import type { Result } from "../common/result";
import type { Exact, DeepPartial } from "../generated-proto/pb_schema/camera_kit/v3/service";
import type { GrpcHandler } from "./grpcHandler";
type TsProtoServiceDefinition<Methods extends TsProtoMethods> = {
    name: string;
    fullName: string;
    methods: Methods;
};
type TsProtoMethods = {
    [methodName: string]: TsProtoMethodDefinition<any, any>;
};
type TsProtoMethodDefinition<Request, Response> = {
    name: string;
    requestType: TsProtoMessage<Request>;
    responseType: TsProtoMessage<Response>;
};
type TsProtoMessage<M> = {
    encode: (message: M) => BinaryWriter;
    decode: (message: Uint8Array) => M;
    fromPartial: (partialMessage: any) => M;
};
export type TsProtoServiceClient<S extends TsProtoServiceDefinition<any>> = {
    [MethodName in keyof S["methods"]]: InferTsProtoMethod<S["methods"][MethodName]>;
};
type InferTsProtoMethod<M extends TsProtoMethodDefinition<any, any>> = M extends TsProtoMethodDefinition<infer Request, infer Response> ? <I extends Exact<DeepPartial<Request>, I>>(request: I) => Promise<Result<grpc.UnaryOutput<Response & grpc.ProtobufMessage>, grpc.UnaryOutput<Response & grpc.ProtobufMessage>>> : never;
/**
 * Convert a service definition generated by ts-proto (using the `outputServices=generic-definitions` CLI option) into
 * a working client.
 *
 * @param serviceDefinition
 * @param handler
 * @returns A client that can make requests to a remote service by sending Protobuf-encoded messages over HTTP using the
 * grpc-web package.
 *
 * @internal
 */
export declare function createTsProtoClient<S extends TsProtoServiceDefinition<TsProtoMethods>>(serviceDefinition: S, handler: GrpcHandler): TsProtoServiceClient<S>;
export {};
//# sourceMappingURL=createTsProtoClient.d.ts.map