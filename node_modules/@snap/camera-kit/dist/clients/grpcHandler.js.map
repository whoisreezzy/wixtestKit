{"version":3,"file":"grpcHandler.js","sourceRoot":"","sources":["../../src/clients/grpcHandler.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,0BAA0B,CAAC;AAChD,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAC7C,OAAO,EAAE,mBAAmB,EAAsC,MAAM,iCAAiC,CAAC;AAE1G,OAAO,EAAE,kBAAkB,EAAE,MAAM,kBAAkB,CAAC;AAEtD,OAAO,EAAE,GAAG,EAAE,EAAE,EAAE,MAAM,kBAAkB,CAAC;AAE3C,OAAO,EAAE,mCAAmC,EAAE,MAAM,iDAAiD,CAAC;AAEtG,OAAO,EACH,iCAAiC,EACjC,8BAA8B,GACjC,MAAM,yCAAyC,CAAC;AACjD,OAAO,EAAE,iBAAiB,EAAE,MAAM,oDAAoD,CAAC;AAgBvF,MAAM,CAAC,MAAM,sBAAsB,GAAG,WAAW,CAAC;AAUlD,SAAS,mBAAmB,CAAC,MAAc;IACvC,OAAO,CACH,MAAM,KAAK,iBAAiB,CAAC,OAAO,CAAC,qBAAqB,CAAC,IAAI;QAC/D,MAAM,KAAK,iBAAiB,CAAC,OAAO,CAAC,iBAAiB,CAAC,IAAI,CAC9D,CAAC;AACN,CAAC;AAQD,MAAM,CAAC,MAAM,kBAAkB,GAAG,UAAU,CACxC,oBAAoB,EACpB,CAAC,kBAAkB,EAAE,mCAAmC,CAAC,KAAK,EAAE,8BAA8B,CAAC,KAAK,CAAU,EAC9G,CACI,aAAqC,EACrC,YAA0B,EAC1B,uBAAgD,EACrC,EAAE;IACb,MAAM,IAAI,GAAG,WAAW,aAAa,CAAC,WAAW,EAAE,CAAC;IAEpD,MAAM,uBAAuB,GAAG,IAAI,mBAAmB,CAAC,YAAY,CAAC,CAAC,GAAG,CAErE,iCAAiC,CAAwB,uBAAuB,CAAC,CACpF,CAAC,OAAO,CAAC;IAOV,MAAM,SAAS,GAA0B,CAAC,OAAO,EAAE,EAAE;QACjD,IAAI,QAAQ,GAA8B,SAAS,CAAC;QACpD,MAAM,UAAU,GAAG,UAAU,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,eAAe,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;QAClF,IAAI,SAAS,GAAG,KAAK,CAAC;QACtB,OAAO;YACH,WAAW,CAAC,QAAQ;;gBAChB,MAAM,WAAW,GAAG;oBAChB,OAAO,EAAE,MAAA,QAAQ,aAAR,QAAQ,uBAAR,QAAQ,CAAE,SAAS,EAAE,mCAAI,EAAE;oBACpC,MAAM,EAAE,MAAM;oBACd,IAAI,EAAE,QAAQ;oBACd,MAAM,EAAE,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,MAAM;iBAC7B,CAAC;gBACF,MAAM,iBAAiB,GAA0B;oBAC7C,WAAW,EAAE,sBAAsB;oBACnC,UAAU,EAAE,OAAO,CAAC,gBAAgB,CAAC,UAAU;iBAClD,CAAC;gBAKF,MAAM,OAAO,GAAG,mBAAmB,CAAC,OAAO,CAAC,gBAAgB,CAAC,UAAU,CAAC;oBACpE,CAAC,CAAC,YAAY,CAAC,OAAO,CAAC,GAAG,EAAE,WAAW,CAAC;oBACxC,CAAC,CAAC,uBAAuB,CAAC,CAAC,OAAO,CAAC,GAAG,EAAE,iBAAiB,CAAC,EAAE,WAAW,CAAC,CAAC;gBAC7E,OAAO;qBACF,IAAI,CAAC,CAAC,QAAQ,EAAE,EAAE;oBACf,OAAO,CAAC,SAAS,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;oBACxE,OAAO,QAAQ,CAAC,WAAW,EAAE,CAAC;gBAClC,CAAC,CAAC;qBACD,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE;oBACX,IAAI,SAAS;wBAAE,OAAO;oBACtB,OAAO,CAAC,OAAO,CAAC,IAAI,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC;oBACtC,OAAO,CAAC,KAAK,EAAE,CAAC;gBACpB,CAAC,CAAC;qBACD,KAAK,CAAC,CAAC,KAAK,EAAE,EAAE;oBACb,IAAI,SAAS;wBAAE,OAAO;oBACtB,SAAS,GAAG,IAAI,CAAC;oBACjB,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;gBACzB,CAAC,CAAC,CAAC;YACX,CAAC;YAED,KAAK,CAAC,CAAC;gBACH,QAAQ,GAAG,CAAC,CAAC;YACjB,CAAC;YAED,UAAU,KAAI,CAAC;YAEf,MAAM;gBACF,IAAI,SAAS;oBAAE,OAAO;gBACtB,SAAS,GAAG,IAAI,CAAC;gBACjB,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,KAAK,EAAE,CAAC;YACxB,CAAC;SACJ,CAAC;IACN,CAAC,CAAC;IAEF,OAAO,CAAO,OAAO,EAAE,EAAE;QACrB,OAAA,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;YACpB,IAAI,CAAC,KAAK,CACN;gBACI,UAAU,EAAE,OAAO,CAAC,UAAU;gBAC9B,OAAO,EAAE,EAAE,WAAW,EAAE,OAAO,CAAC,WAAW,EAAE;gBAC7C,aAAa,EAAE,KAAK;gBACpB,cAAc,EAAE,KAAK;gBACrB,WAAW,EAAE,OAAO,CAAC,WAAW;gBAChC,YAAY,EAAE,OAAO,CAAC,YAAY;aACrC,EACD;gBACI,OAAO,EAAE,IAAI,OAAO,CAAC,WAAW,EAAE;gBAClC,IAAI;gBACJ,KAAK,EAAE,CAAC,QAAQ,EAAE,EAAE;oBAChB,IAAI,eAAe,CAAC,QAAQ,CAAC,EAAE;wBAC3B,OAAO,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;qBACzB;yBAAM;wBACH,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC;qBAC1B;gBACL,CAAC;gBACD,SAAS;aACZ,CACJ,CAAC;QACN,CAAC,CAAC,CAAA;MAAA,CAAC;AACX,CAAC,CACJ,CAAC;AAEF,SAAS,eAAe,CACpB,KAA6C;IAE7C,OAAO,KAAK,CAAC,MAAM,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;AACzC,CAAC","sourcesContent":["import { grpc } from \"@improbable-eng/grpc-web\";\nimport { Injectable } from \"@snap/ts-inject\";\nimport { HandlerChainBuilder, type Handler, type RequestMetadata } from \"../handlers/HandlerChainBuilder\";\nimport type { CameraKitConfiguration } from \"../configuration\";\nimport { configurationToken } from \"../configuration\";\nimport type { Result } from \"../common/result\";\nimport { Err, Ok } from \"../common/result\";\nimport type { FetchHandler } from \"../handlers/defaultFetchHandler\";\nimport { cameraKitServiceFetchHandlerFactory } from \"../handlers/cameraKitServiceFetchHandlerFactory\";\nimport type { RequestStateEventTarget } from \"../handlers/requestStateEmittingHandler\";\nimport {\n    createRequestStateEmittingHandler,\n    requestStateEventTargetFactory,\n} from \"../handlers/requestStateEmittingHandler\";\nimport { MetricsDefinition } from \"../generated-proto/pb_schema/camera_kit/v3/service\";\n\nexport interface GrpcRequest {\n    serviceName: string;\n    methodName: string;\n    requestType: grpc.ProtobufMessageClass<grpc.ProtobufMessage>;\n    responseType: grpc.ProtobufMessageClass<grpc.ProtobufMessage>;\n}\n\nexport type GrpcHandler = Handler<GrpcRequest, GrpcResult, RequestMetadata>;\n\nexport type GrpcResult = Result<\n    grpc.UnaryOutput<grpc.ProtobufMessage> & { status: grpc.Code.OK },\n    grpc.UnaryOutput<grpc.ProtobufMessage>\n>;\n\nexport const GRPC_CALL_REQUEST_TYPE = \"grpc_call\";\n\nexport interface GrpcRequestDimensions extends Record<string, string> {\n    requestType: typeof GRPC_CALL_REQUEST_TYPE;\n    methodName: string;\n}\n\n/**\n * Returns true if the given string is the name of a metric gRPC method.\n */\nfunction isMetricsGrpcMethod(method: string) {\n    return (\n        method === MetricsDefinition.methods.setOperationalMetrics.name ||\n        method === MetricsDefinition.methods.setBusinessEvents.name\n    );\n}\n\n/**\n * An Injectable handler that can make requests to the CameraKit backend service via grpc-web. This handler can be\n * passed to {@link createTsProtoClient} to produce a well-typed service client.\n *\n * @internal\n */\nexport const grpcHandlerFactory = Injectable(\n    \"grpcHandlerFactory\",\n    [configurationToken, cameraKitServiceFetchHandlerFactory.token, requestStateEventTargetFactory.token] as const,\n    (\n        configuration: CameraKitConfiguration,\n        fetchHandler: FetchHandler,\n        requestStateEventTarget: RequestStateEventTarget\n    ): GrpcHandler => {\n        const host = `https://${configuration.apiHostname}`;\n\n        const fetchHandlerWithMetrics = new HandlerChainBuilder(fetchHandler).map(\n            // TODO: ideally we don't need it here: https://jira.sc-corp.net/browse/CAMKIT-6350\n            createRequestStateEmittingHandler<GrpcRequestDimensions>(requestStateEventTarget)\n        ).handler;\n\n        // We define our own Transport so that we can use our custom `fetch` implementation. This is important for two\n        // reasons:\n        //   1. Our custom fetch includes features like retries that we want to use for these requests.\n        //   2. Applications may override this fetch implementation (via our DI system) to support more advanced\n        //      use-cases.\n        const transport: grpc.TransportFactory = (options) => {\n            let metadata: grpc.Metadata | undefined = undefined;\n            const controller = globalThis.AbortController ? new AbortController() : undefined;\n            let cancelled = false;\n            return {\n                sendMessage(msgBytes) {\n                    const requestInit = {\n                        headers: metadata?.toHeaders() ?? {},\n                        method: \"POST\",\n                        body: msgBytes,\n                        signal: controller?.signal,\n                    };\n                    const metricsDimensions: GrpcRequestDimensions = {\n                        requestType: GRPC_CALL_REQUEST_TYPE,\n                        methodName: options.methodDefinition.methodName,\n                    };\n                    // Note: Currently, we do not report network metrics for the metrics requests\n                    // themselves because that triggers an infinite loop of metrics reporting. Ideally,\n                    // we still want to report them, but attach them to the next metrics request without\n                    // triggering it.\n                    const request = isMetricsGrpcMethod(options.methodDefinition.methodName)\n                        ? fetchHandler(options.url, requestInit)\n                        : fetchHandlerWithMetrics([options.url, metricsDimensions], requestInit);\n                    request\n                        .then((response) => {\n                            options.onHeaders(new grpc.Metadata(response.headers), response.status);\n                            return response.arrayBuffer();\n                        })\n                        .then((body) => {\n                            if (cancelled) return;\n                            options.onChunk(new Uint8Array(body));\n                            options.onEnd();\n                        })\n                        .catch((error) => {\n                            if (cancelled) return;\n                            cancelled = true;\n                            options.onEnd(error);\n                        });\n                },\n\n                start(m) {\n                    metadata = m;\n                },\n\n                finishSend() {},\n\n                cancel() {\n                    if (cancelled) return;\n                    cancelled = true;\n                    controller?.abort();\n                },\n            };\n        };\n\n        return async (request) =>\n            new Promise((resolve) => {\n                grpc.unary(\n                    {\n                        methodName: request.methodName,\n                        service: { serviceName: request.serviceName },\n                        requestStream: false,\n                        responseStream: false,\n                        requestType: request.requestType,\n                        responseType: request.responseType,\n                    },\n                    {\n                        request: new request.requestType(),\n                        host,\n                        onEnd: (response) => {\n                            if (isUnaryOutputOk(response)) {\n                                resolve(Ok(response));\n                            } else {\n                                resolve(Err(response));\n                            }\n                        },\n                        transport,\n                    }\n                );\n            });\n    }\n);\n\nfunction isUnaryOutputOk(\n    value: grpc.UnaryOutput<grpc.ProtobufMessage>\n): value is grpc.UnaryOutput<grpc.ProtobufMessage> & { status: grpc.Code.OK } {\n    return value.status === grpc.Code.OK;\n}\n"]}