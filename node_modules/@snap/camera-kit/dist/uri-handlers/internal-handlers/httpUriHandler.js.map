{"version":3,"file":"httpUriHandler.js","sourceRoot":"","sources":["../../../src/uri-handlers/internal-handlers/httpUriHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import type { RemoteApiSpecsClient } from \"../../clients/remoteApiSpecsClient\";\nimport type { Lens } from \"../../lens/Lens\";\nimport type { LensState } from \"../../session/lensState\";\nimport { getLogger } from \"../../logger/logger\";\nimport type { SessionState } from \"../../session/sessionState\";\nimport { namedError } from \"../../namedErrors\";\nimport type { CameraKitBootstrapConfiguration, LensHttpHandler } from \"../../configuration\";\nimport type { UriHandler, UriRequest, UriResponse } from \"../UriHandlers\";\nimport { createUriRequestProcessor } from \"../uriRequestProcessor\";\nimport type { RemoteApiSpec } from \"../../generated-proto/pb_schema/camera_kit/v3/remote_api_spec\";\nimport { isPromise } from \"../../common/typeguards\";\nimport type { ContentType } from \"../../lens-core-module/generated-types\";\nimport { requestValidationErrorName, validateRequest } from \"./httpValidators\";\n\nconst logger = getLogger(\"lensHttpHandler\");\n\nconst lensHttpHandlerErrorName = \"LensHttpHandlerError\";\nconst lensHttpHandlerError = namedError(lensHttpHandlerErrorName);\n\ntype LensHttpRequestErrorType = \"UnknownError\" | \"LensHttpHandlerError\" | \"RequestValidationError\";\n\nconst allowedResponseHeaders = [\n    \"Accept-Ranges\",\n    \"Cache-Control\",\n    \"Content-Language\",\n    \"Content-Length\",\n    \"Content-Type\",\n    \"Date\",\n    \"ETag\",\n    \"Expires\",\n    \"Last-Modified\",\n    \"Location\",\n];\n\nconst requestHeadersToExclude = [\"x-sc-lenses-remote-api-spec-id\"];\n\n/**\n *\n * @internal\n *\n * @param lensState\n * @param sessionState\n * @param remoteApiSpecsClient\n * @param clientLentHttpRequestHandler\n * @returns\n */\nexport function createHttpUriHandler(\n    lensState: LensState,\n    sessionState: SessionState,\n    remoteApiSpecsClient: RemoteApiSpecsClient,\n    customLentFetchHandler: LensHttpHandler | undefined\n): UriHandler {\n    let allowlistPromise: Promise<RemoteApiSpec[]> | undefined = undefined;\n\n    return createUriRequestProcessor({\n        uri: [\"http://\", \"https://\"],\n        lensState,\n        sessionState,\n        async processRequest({ request, lens, reply, setCancellationHandler }) {\n            allowlistPromise = allowlistPromise ?? getAllowlist(remoteApiSpecsClient);\n            const allowlist = await allowlistPromise;\n            handleHttpUriRequest(request, lens, reply, setCancellationHandler, allowlist, customLentFetchHandler);\n        },\n        processInternalError(error: Error) {\n            // The expectation is that if an error occurs, it happens in our own implementation,\n            // because app callbacks are wrapped with try..catch blocks.\n            // Therefore, we would like to report this error.\n            logger.error(error);\n        },\n    });\n}\n\nasync function getAllowlist(remoteApiSpecsClient: RemoteApiSpecsClient) {\n    const result = await remoteApiSpecsClient.getRemoteApiSpecs({});\n    if (!result.ok) throw new Error(\"Failed getting Remote API specs.\", { cause: result.unwrapErr() });\n    return result.unwrap().message?.remoteApiSpecs ?? [];\n}\n\n/**\n *\n * @internal\n *\n * @param request\n * @param lens\n * @param reply\n * @param setCancellationHandler\n * @param allowlist\n * @param clientLensHttpRequestHandler\n */\nexport async function handleHttpUriRequest(\n    request: UriRequest,\n    lens: Lens,\n    reply: (response: UriResponse) => void,\n    setCancellationHandler: (fn: () => void) => void,\n    allowlist: RemoteApiSpec[],\n    customLensHttpHandler: LensHttpHandler | undefined\n) {\n    try {\n        validateRequest(request, allowlist);\n        const { url, init } = mapLensToFetchRequest(request);\n\n        // abort controller to abort fetch request when lens sends cancellation request\n        const abortController = new AbortController();\n        init.signal = abortController.signal;\n        setCancellationHandler(() => abortController.abort());\n\n        let response: Response;\n        if (customLensHttpHandler) {\n            const handlerName = \"lensHttpHandler\" satisfies keyof CameraKitBootstrapConfiguration;\n            try {\n                const { uri, identifier, method, metadata, data } = request;\n                const responsePromise = customLensHttpHandler(url, init, {\n                    url: uri,\n                    identifier,\n                    method,\n                    data,\n                    headers: metadata,\n                    lens,\n                });\n                if (!isPromise(responsePromise)) {\n                    throw lensHttpHandlerError(\n                        `The '${handlerName}' callback provided to Camera Kit must return a Promise.`\n                    );\n                }\n                response = await responsePromise;\n            } catch (error) {\n                // NOTE: This error message will be displayed in browser only\n                error =\n                    error instanceof Error && error.name === lensHttpHandlerErrorName\n                        ? error\n                        : lensHttpHandlerError(\n                              `The '${handlerName}' callback provided to Camera Kit configuration failed.`,\n                              error\n                          );\n                throw error;\n            }\n        } else {\n            response = await fetch(url, init);\n        }\n\n        reply(await mapFetchToLensResponse(response));\n    } catch (error) {\n        if (error instanceof Error && error.name === lensHttpHandlerErrorName) {\n            // We do not report errors generated in partners's app code\n            logger.warn(error);\n            reply(\n                getErrorResponse(\n                    \"LensHttpHandlerError\",\n                    // In case of an error in partner provided callback,\n                    // we just send a generic message to lens, which is common for all Camera Kit SDKs.\n                    `The lens HTTP request handler provided to Camera Kit failed.`\n                )\n            );\n        } else if (error instanceof Error && error.name === requestValidationErrorName) {\n            // We do not report validation error caused by lens code\n            logger.warn(error);\n            reply(\n                getErrorResponse(\n                    \"RequestValidationError\",\n                    // NOTE: Validation errors sent to lens should be consistent with the other Camera Kit SDKs\n                    error.message\n                )\n            );\n        } else {\n            // We report error to our backend only in case of unknown error\n            logger.error(error);\n            reply(\n                getErrorResponse(\n                    \"UnknownError\",\n                    // NOTE: we don't want to expose error details to lens\n                    \"An unknown error occurred.\"\n                )\n            );\n        }\n    }\n}\n\nfunction getErrorResponse(errorType: LensHttpRequestErrorType, message: string): UriResponse {\n    return {\n        code: 400,\n        description: \"\",\n        contentType: \"text/plain\",\n        metadata: {\n            \"x-camera-kit-error-type\": errorType,\n        },\n        data: new TextEncoder().encode(message),\n    };\n}\n\n/**\n * @internal\n */\nexport function mapLensToFetchRequest({ uri, method, metadata, data }: UriRequest): { url: string; init: RequestInit } {\n    const headers = new Headers(metadata);\n    // remove internal headers that LensCore adds\n    for (const header of requestHeadersToExclude) {\n        headers.delete(header);\n    }\n    return {\n        url: uri,\n        init: {\n            headers: Object.fromEntries(headers.entries()),\n            body: method !== \"GET\" && (method as any) !== \"HEAD\" && method !== undefined ? data : undefined,\n            method,\n        },\n    };\n}\n\n/**\n * @internal\n */\nexport async function mapFetchToLensResponse(response: Response): Promise<UriResponse> {\n    const metadata: Record<string, string> = {};\n    for (const allowedHeader of allowedResponseHeaders) {\n        const value = response.headers.get(allowedHeader);\n        if (value) {\n            metadata[allowedHeader.toLowerCase()] = value;\n        }\n    }\n    return {\n        code: response.status,\n        description: \"\",\n        // Safety: At the time of writing any contentType value provided in the response object will be ignored:\n        // eslint-disable-next-line max-len\n        // https://github.sc-corp.net/Snapchat/LensCore/blob/722629250973cdf1064baef85d9360229f9dff76/Src/Scenarium/Primitives/RemoteServiceModule.cpp#L517-L533\n        // But we still try to provide it with the correct value for consistency with mobile SDKs.\n        contentType: (response.headers.get(\"Content-Type\") ?? \"\") as ContentType,\n        metadata,\n        data: await response.arrayBuffer(),\n    };\n}\n"]}