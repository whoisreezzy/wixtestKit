{"version":3,"file":"remoteApiUriHandler.js","sourceRoot":"","sources":["../../../src/uri-handlers/internal-handlers/remoteApiUriHandler.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable } from \"@snap/ts-inject\";\nimport { RemoteApiInfo } from \"../../generated-proto/pb_schema/camera_kit/v3/features/remote_api_info\";\nimport {\n    ResponseCode,\n    responseCodeToNumber,\n} from \"../../generated-proto/pb_schema/lenses/remote_api/remote_api_service\";\nimport type { LensRepository } from \"../../lens/LensRepository\";\nimport type { Lens } from \"../../lens/Lens\";\nimport type { LensState } from \"../../session/lensState\";\nimport type { SessionState } from \"../../session/sessionState\";\nimport { getLogger } from \"../../logger/logger\";\nimport type { EnumToPublicStringLiteralMap, ExcludeKeys } from \"../../common/types\";\nimport type { MetricsClient } from \"../../clients/metricsClient\";\nimport { Count } from \"../../metrics/operational/Count\";\nimport { joinMetricNames } from \"../../metrics/operational/Metric\";\nimport { createUriRequestProcessor } from \"../uriRequestProcessor\";\nimport type { UriHandler, UriResponse } from \"../UriHandlers\";\nimport { extractSchemeAndRoute } from \"../UriHandlers\";\n\n// NOTE: There's potential for overloads when reporting metrics if reporting is triggered on each frame,\n// (i.e., when the lens sends Remote API requests every frame).\n// As of now, this isn't a concern because src/metrics/operational/operationalMetricsReporter.ts aggregates\n// \"count\" metrics into a single metric within a batch, and the Remote API service currently\n// reports only \"count\" metrics. For instance, if 30 metrics with the same name are generated per second,\n// given the current bundle size of 100 operational metrics, there will be one metrics report approximately\n// every 3.3 seconds.\n// In the future, if we opt to report \"histogram\" or other metric types, they must be approached with caution:\n// either the operationalMetricsReporter should be enhanced to aggregate such metrics,\n// or the Remote API service should manage it directly.\n// Mobiles ticket: https://jira.sc-corp.net/browse/CAMKIT-3092\n\nconst logger = getLogger(\"RemoteApiServices\");\n\nconst uriResponseOkCode = 200;\nconst apiResponseStatusHeader = \":sc_lens_api_status\";\nconst apiBinaryContentType = \"application/octet-stream\";\nconst remoteApiInfoProtobufTypeUrl = \"type.googleapis.com/com.snap.camerakit.v3.features.RemoteApiInfo\";\nconst remoteApiUploadImageSpecId = \"af3f69c8-2e62-441f-8b1c-d3956f7b336c\";\n\nconst statusToResponseCodeMap: ExcludeKeys<\n    EnumToPublicStringLiteralMap<typeof ResponseCode>,\n    \"responseCodeUnset\" | \"unrecognized\"\n> = {\n    success: ResponseCode.SUCCESS,\n    redirected: ResponseCode.REDIRECTED,\n    badRequest: ResponseCode.BAD_REQUEST,\n    accessDenied: ResponseCode.ACCESS_DENIED,\n    notFound: ResponseCode.NOT_FOUND,\n    timeout: ResponseCode.TIMEOUT,\n    requestTooLarge: ResponseCode.REQUEST_TOO_LARGE,\n    serverError: ResponseCode.SERVER_ERROR,\n    cancelled: ResponseCode.CANCELLED,\n    proxyError: ResponseCode.PROXY_ERROR,\n    // NOTE: This rule helps keep the public-facing RemoteApiStatus type consistent with the proto.\n    // We prefer using a separate type for TypeDoc purposes.\n} satisfies Record<RemoteApiStatus, ResponseCode>;\n\n/**\n * Status of a Remote API response.\n */\nexport type RemoteApiStatus =\n    | \"success\"\n    | \"redirected\"\n    | \"badRequest\"\n    | \"accessDenied\"\n    | \"notFound\"\n    | \"timeout\"\n    | \"requestTooLarge\"\n    | \"serverError\"\n    | \"cancelled\"\n    | \"proxyError\";\n\n/**\n * Remote API request sent by a lens.\n */\nexport interface RemoteApiRequest {\n    /**\n     * Unique id of the remote API service specification.\n     */\n    apiSpecId: string;\n    /**\n     * Unique id of the remote API service endpoint requested by this request.\n     */\n    endpointId: string;\n    /**\n     * A map of named parameters associated with the request.\n     */\n    parameters: Record<string, string>;\n    /**\n     * Additional binary request payload.\n     */\n    body: ArrayBuffer;\n}\n\n/**\n * Remote API response to a request sent by a lens.\n */\nexport interface RemoteApiResponse {\n    /**\n     * Status of the response\n     */\n    status: RemoteApiStatus;\n    /**\n     * A map of named metadata associated with the response.\n     */\n    metadata: Record<string, string>;\n    /**\n     * Additional binary request payload.\n     */\n    body: ArrayBuffer;\n}\n\n/**\n * Represents a Remote API request cancellation handler function.\n */\nexport type RemoteApiCancelRequestHandler = () => void;\n\n/**\n * Represents a Remote API request handler function.\n * It is provided with a reply callback that must be invoked to send a response back to the lens.\n * The reply callback can be invoked multiple times if needed.\n * Additionally, the handler can return a cancellation callback, which is triggered when the lens cancels the request.\n */\nexport type RemoteApiRequestHandler = (\n    reply: (response: RemoteApiResponse) => void\n) => RemoteApiCancelRequestHandler | void;\n\n/**\n * Service to handle a lens Remote API request.\n */\nexport interface RemoteApiService {\n    /**\n     * Remote API spec ID(s).\n     */\n    apiSpecId: string;\n\n    /**\n     * This method is called by Camera Kit when a lens triggers a Remote API request with a corresponding spec ID.\n     * If the service can handle the request, the method returns a request handler; otherwise, it returns nothing.\n     * @param request Remote API request object.\n     * @param lens Lens that triggers the request.\n     * @returns A request handler if applicable.\n     */\n    getRequestHandler(request: RemoteApiRequest, lens: Lens): RemoteApiRequestHandler | undefined;\n}\n\nexport type RemoteApiServices = RemoteApiService[];\n\nexport const remoteApiServicesFactory = Injectable(\"remoteApiServices\", () => {\n    const remoteApiServices: RemoteApiServices = [];\n    return remoteApiServices;\n});\n\ndeclare global {\n    // See internal-packages/camera-kit-extensions for the meaning of the field.\n    var __snap_camkit_ra_1: string | undefined;\n}\n\n/**\n * Goes over provided services and returns the first request handler that is able to handle the request.\n */\nfunction getFirstRequestHandler(services: RemoteApiService[], remoteApiRequest: RemoteApiRequest, lens: Lens) {\n    for (const service of services) {\n        try {\n            return service.getRequestHandler(remoteApiRequest, lens);\n        } catch (error) {\n            logger.warn(\"Client's Remote API request handler factory threw an error.\", error);\n        }\n    }\n    return undefined;\n}\n\n/**\n * Provides a URI handler that searches for a match within the provided services to handle Remote API requests,\n * i.e., those whose URI starts with 'app://remote-api/performApiRequest'.\n */\nexport function createRemoteApiUriHandler(\n    registeredServices: RemoteApiService[],\n    sessionState: SessionState,\n    lensState: LensState,\n    lensRepository: LensRepository,\n    metrics: MetricsClient\n): UriHandler {\n    // Groups services by spec ID for faster lookups.\n    const registeredServiceMap = new Map<string, RemoteApiService[]>();\n    for (const service of registeredServices) {\n        const existingServices = registeredServiceMap.get(service.apiSpecId) || [];\n        registeredServiceMap.set(service.apiSpecId, [...existingServices, service]);\n    }\n\n    return createUriRequestProcessor({\n        uri: \"app://remote-api/performApiRequest\",\n        lensState,\n        sessionState,\n        createLensRequestState(_request, lens) {\n            return {\n                supportedSpecIds: new Set([\n                    // Parse lens metadata to obtain supported Remote API specs.\n                    ...(lensRepository.getLensMetadata(lens.id)?.featureMetadata ?? [])\n                        .filter((feature) => feature.typeUrl === remoteApiInfoProtobufTypeUrl)\n                        .flatMap((any) => RemoteApiInfo.decode(any.value).apiSpecIds),\n                    // Also add remoteApiUploadImageSpecId as this spec should be available for all lenses.\n                    // See https://jira.sc-corp.net/browse/CAMKIT-6245.\n                    remoteApiUploadImageSpecId,\n                ]),\n            };\n        },\n        processRequest({ request, reply, lens, setCancellationHandler, state }) {\n            // Extracts the spec ID and endpoint ID from the provided Remote API request URI.\n            // The given URI is expected to conform to the following specification:\n            // eslint-disable-next-line max-len\n            // https://docs.google.com/document/d/18fbGYDhD2N_aMTe4ZLY4QKeCSoMeJuklG28TutDzLZc/edit#bookmark=id.p2y39gwgbm4g\n            const { route } = extractSchemeAndRoute(request.uri);\n            const [specId, endpointIdWithQuery] = route.split(\"/\").slice(2);\n            const [endpointId] = endpointIdWithQuery.split(\"?\");\n\n            const dimensions = { specId };\n            const reportSingleCount = (name: string) => {\n                metrics.setOperationalMetrics(\n                    Count.count(joinMetricNames([\"lens\", \"remote-api\", name]), 1, dimensions)\n                );\n            };\n            reportSingleCount(\"requests\");\n\n            // Only handle requests for API spec ID that current lens supports.\n            if (!state?.supportedSpecIds.has(specId)) return;\n\n            const remoteApiRequest: RemoteApiRequest = {\n                apiSpecId: specId,\n                body: request.data,\n                endpointId,\n                parameters: request.metadata,\n            };\n\n            let requestHandler = getFirstRequestHandler(registeredServiceMap.get(specId) ?? [], remoteApiRequest, lens);\n\n            // Check maybe there is an internal catch-all handler.\n            if (!requestHandler && globalThis.__snap_camkit_ra_1) {\n                requestHandler = getFirstRequestHandler(\n                    registeredServiceMap.get(globalThis.__snap_camkit_ra_1) ?? [],\n                    remoteApiRequest,\n                    lens\n                );\n            }\n            if (!requestHandler) return;\n\n            reportSingleCount(\"handled-requests\");\n\n            let cancellationHandler: RemoteApiCancelRequestHandler | void = undefined;\n            try {\n                // Calls client's Remote API handler to process the request.\n                cancellationHandler = requestHandler((response) => {\n                    reportSingleCount(\"responses\");\n\n                    const responseCode = statusToResponseCodeMap[response.status] ?? ResponseCode.UNRECOGNIZED;\n                    const uriResponse: UriResponse = {\n                        code: uriResponseOkCode,\n                        description: \"\",\n                        contentType: apiBinaryContentType,\n                        data: response.body,\n                        metadata: {\n                            ...response.metadata,\n                            [apiResponseStatusHeader]: responseCodeToNumber(responseCode).toString(),\n                        },\n                    };\n                    reply(uriResponse);\n                });\n            } catch (error) {\n                logger.warn(\"Client's Remote API request handler threw an error.\", error);\n            }\n\n            if (typeof cancellationHandler === \"function\") {\n                setCancellationHandler(() => {\n                    try {\n                        cancellationHandler!();\n                    } catch (error) {\n                        logger.warn(\"Client's Remote API request cancellation handler threw an error.\", error);\n                    }\n                });\n            }\n        },\n        processInternalError(error) {\n            // The expectation is that if an error occurs, it happens in our own implementation,\n            // because app callbacks are wrapped with try..catch blocks.\n            // Therefore, we would like to report this error.\n            logger.error(error);\n            metrics.setOperationalMetrics(Count.count(joinMetricNames([\"lens\", \"remote-api\", \"errors\"]), 1));\n        },\n    });\n}\n"]}