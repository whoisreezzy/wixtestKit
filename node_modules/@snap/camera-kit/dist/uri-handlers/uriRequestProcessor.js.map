{"version":3,"file":"uriRequestProcessor.js","sourceRoot":"","sources":["../../src/uri-handlers/uriRequestProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["import { catchError, map, merge, retry, Subject, takeUntil, tap } from \"rxjs\";\nimport { forActions } from \"@snap/state-management\";\nimport type { Lens } from \"../lens/Lens\";\nimport type { LensState } from \"../session/lensState\";\nimport type { SessionState } from \"../session/sessionState\";\nimport type { Uri, UriCancelRequest, UriHandler, UriRequest, UriResponse } from \"./UriHandlers\";\n\ntype LensId = string;\ntype RequestId = string;\n\nexport type UriRequestEvent = {\n    request: UriRequest;\n    reply: (response: UriResponse) => void;\n    lens: Lens;\n};\n\ntype UriCancelRequestEvent = {\n    request: UriCancelRequest;\n    lens: Lens;\n};\n\ninterface LensRequestState<T = undefined> {\n    cancellationHandlers: Map<RequestId, RemoteApiCancelRequestHandler>;\n    custom: T;\n}\n\n/**\n * Represents a Remote API request cancellation handler function.\n */\nexport type RemoteApiCancelRequestHandler = () => void;\n\n/**\n * Invokes the cancellation handler associated with the provided key and removes it from the collection of handlers.\n */\nfunction callCancellationHandler(\n    cancellationHandlers: Map<RequestId, RemoteApiCancelRequestHandler>,\n    ...keys: RequestId[]\n) {\n    for (const key of keys) {\n        cancellationHandlers.get(key)?.();\n        cancellationHandlers.delete(key);\n    }\n}\n\n/**\n * Removes the specified lenses' metadata from the cache and invokes their cancellation callbacks.\n *\n * @param lensRequestState The state representing the lens cache.\n * @param lensIds An array of lens IDs to be removed from the cache\n * and for which the cancellation callbacks will be invoked.\n */\nfunction handleLensApplicationEnd(lensRequestState: Map<LensId, LensRequestState<any>>, ...lensIds: LensId[]) {\n    for (const lensId of lensIds) {\n        const state = lensRequestState.get(lensId);\n        if (state) {\n            callCancellationHandler(state.cancellationHandlers, ...state.cancellationHandlers.keys());\n            lensRequestState.delete(lensId);\n        }\n    }\n}\n\nexport type CreateLensRequestState<State> = (request: UriRequest, lens: Lens) => State;\n\nexport type ProcessRequest<State> = (input: {\n    request: UriRequest;\n    reply: (response: UriResponse) => void;\n    lens: Lens;\n    setCancellationHandler: (fn: () => void) => void;\n    state: State;\n}) => void;\n\nexport type ProcessError = (error: Error) => void;\n\n/**\n * Creates a UriHandler for the provided URI.\n * Handles lens and sessions state events, so provides clear abstraction for internal usages.\n *\n * @internal\n */\nexport function createUriRequestProcessor<State = undefined>({\n    uri,\n    lensState,\n    sessionState,\n    createLensRequestState,\n    processRequest,\n    processInternalError,\n}: {\n    uri: Uri | Uri[];\n    lensState: LensState;\n    sessionState: SessionState;\n    createLensRequestState?: CreateLensRequestState<State>;\n    processRequest: ProcessRequest<State>;\n    processInternalError: ProcessError;\n}): UriHandler {\n    const uriRequests = new Subject<UriRequestEvent>();\n    const uriCancelRequests = new Subject<UriCancelRequestEvent>();\n    const lensRequestState = new Map<LensId, LensRequestState<State>>();\n\n    const lensTurnOffEvents = lensState.events.pipe(\n        forActions(\"turnedOff\"),\n        tap(([action]) => handleLensApplicationEnd(lensRequestState, action.data.id))\n    );\n\n    const uriRequestEvents = uriRequests.pipe(\n        map(({ request, lens, reply }) => {\n            if (!lensRequestState.has(lens.id)) {\n                const custom = createLensRequestState?.(request, lens);\n                const state: LensRequestState<State> = {\n                    // Prepares a collection to store cancellation handlers.\n                    // A specific handler will be invoked when a cancellation request is issued by the lens.\n                    // All handlers will be invoked when the lens is replaced with another one or the session\n                    // is destroyed.\n                    cancellationHandlers: new Map(),\n                    // Safety: it is fine for State to be undefined\n                    custom: custom as State,\n                };\n                lensRequestState.set(lens.id, state);\n            }\n            const requestState = lensRequestState.get(lens.id)!;\n\n            return {\n                request,\n                reply,\n                lens,\n                state: requestState.custom,\n                setCancellationHandler: (fn: () => any) => {\n                    requestState.cancellationHandlers.set(request.identifier, fn);\n                },\n            };\n        }),\n\n        tap(processRequest)\n    );\n\n    const uriCancelRequestEvents = uriCancelRequests.pipe(\n        tap((uriRequest) => {\n            const cancellationHandlers = lensRequestState.get(uriRequest.lens.id)?.cancellationHandlers;\n            if (cancellationHandlers) {\n                callCancellationHandler(cancellationHandlers, uriRequest.request.requestId);\n            }\n        })\n    );\n\n    merge(lensTurnOffEvents, uriRequestEvents, uriCancelRequestEvents)\n        .pipe(\n            catchError((error, sourcePipe) => {\n                processInternalError(error);\n                // Return the source pipe so that we can retry the pipe instead of just completing it.\n                return sourcePipe;\n            }),\n            // When the pipe completes due to an error,\n            // we want to resubscribe to the original pipe to keep it alive.\n            retry(),\n            takeUntil(sessionState.events.pipe(forActions(\"destroy\")))\n        )\n        .subscribe({\n            complete: () => handleLensApplicationEnd(lensRequestState, ...lensRequestState.keys()),\n        });\n\n    return {\n        uri,\n\n        handleRequest(request, reply, lens) {\n            uriRequests.next({ request, reply, lens });\n        },\n\n        cancelRequest(request, lens) {\n            uriCancelRequests.next({ request, lens });\n        },\n    };\n}\n"]}