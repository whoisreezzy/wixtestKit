import { __awaiter } from "tslib";
import { ensureError } from "../common/errorHelpers";
import { cacheKeyNotFoundError } from "../namedErrors";
import { getLogger } from "../logger/logger";
const logger = getLogger("responseCachingHandler");
const notFound = (key) => cacheKeyNotFoundError(`Response for key ${key} not found in cache.`);
const strategyFailed = (key, cause) => new Error(`Network request and cache lookup for key ${key} both failed.`, { cause });
export const staleIfErrorStrategy = (options) => (key, cache, network) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    try {
        const response = yield network();
        cache.store(key, response).catch((error) => {
            logger.warn(`staleIfErrorStrategy failed to store key ${key}.`, error);
        });
        return response;
    }
    catch (networkError) {
        try {
            const cachedResponse = yield cache.retrieve(key);
            if (!cachedResponse) {
                (_a = options === null || options === void 0 ? void 0 : options.onMiss) === null || _a === void 0 ? void 0 : _a.call(options);
                throw notFound(key);
            }
            logger.debug(`staleIfErrorStrategy successfully fell back to cache for key ${key} after network error.`, networkError);
            (_b = options === null || options === void 0 ? void 0 : options.onHit) === null || _b === void 0 ? void 0 : _b.call(options);
            return cachedResponse;
        }
        catch (cacheError) {
            const error = ensureError(cacheError);
            error.cause = networkError;
            throw strategyFailed(key, error);
        }
    }
});
export const staleWhileRevalidateStrategy = (options) => (key, cache, network) => __awaiter(void 0, void 0, void 0, function* () {
    var _c, _d;
    try {
        const cachedResponse = yield cache.retrieve(key);
        if (!cachedResponse)
            throw notFound(key);
        network({ isSideEffect: true })
            .then((response) => cache.store(key, response))
            .catch((error) => {
            logger.warn(`staleWhileRevalidateStrategy failed to retrieve and store key ${key}.`, error);
        });
        (_c = options === null || options === void 0 ? void 0 : options.onHit) === null || _c === void 0 ? void 0 : _c.call(options);
        return cachedResponse;
    }
    catch (cacheError) {
        (_d = options === null || options === void 0 ? void 0 : options.onMiss) === null || _d === void 0 ? void 0 : _d.call(options);
        try {
            const response = yield network();
            cache.store(key, response).catch((error) => {
                logger.warn(`staleWhileRevalidateStrategy failed to store key ${key}.`, error);
            });
            logger.debug(`staleWhileRevalidateStrategy successfully fell back to network for key ${key} after cache error.`, cacheError);
            return response;
        }
        catch (networkError) {
            const error = ensureError(networkError);
            error.cause = cacheError;
            throw strategyFailed(key, error);
        }
    }
});
export const createResponseCachingHandler = (cache, resolveKey, strategy) => {
    return (next) => (request, metadata) => __awaiter(void 0, void 0, void 0, function* () {
        const network = (additionalMetadata = {}) => {
            const m = Object.assign(Object.assign({}, metadata), additionalMetadata);
            return next(request, m);
        };
        let key;
        try {
            key = resolveKey(request, metadata);
        }
        catch (error) {
            logger.warn("Cache lookup failed because the cache key could not be resolved.", error);
            return network();
        }
        return strategy(key, cache, network);
    });
};
//# sourceMappingURL=responseCachingHandler.js.map