export class HandlerChainBuilder {
    constructor(inner) {
        this.inner = inner;
    }
    get handler() {
        return this.inner;
    }
    map(outer) {
        const outerHandler = (req, metadata) => {
            var _a;
            const abort = new AbortController();
            const signal = abort.signal;
            let innerCompleted = false;
            const maybeAbort = () => {
                var _a;
                if (signal.aborted || innerCompleted)
                    return;
                abort.abort();
                (_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", maybeAbort);
            };
            (_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.addEventListener("abort", maybeAbort);
            const innerHandler = new Proxy(this.inner, {
                apply: (target, thisArg, args) => {
                    const [req, metadata] = args;
                    if (metadata === null || metadata === void 0 ? void 0 : metadata.isSideEffect)
                        innerCompleted = true;
                    const abortListeners = [];
                    signal.addEventListener = new Proxy(signal.addEventListener, {
                        apply: (target, thisArg, args) => {
                            abortListeners.push(args[1]);
                            return Reflect.apply(target, thisArg, args);
                        },
                    });
                    const cleanupAndMarkComplete = () => {
                        var _a;
                        (_a = metadata === null || metadata === void 0 ? void 0 : metadata.signal) === null || _a === void 0 ? void 0 : _a.removeEventListener("abort", maybeAbort);
                        abortListeners.forEach((listener) => signal.removeEventListener("abort", listener));
                        innerCompleted = true;
                    };
                    const innerResponse = Reflect.apply(target, thisArg, [
                        req,
                        Object.assign(Object.assign({}, metadata), { isSideEffect: false, signal }),
                    ]);
                    innerResponse.catch(() => { }).then(cleanupAndMarkComplete);
                    return innerResponse;
                },
            });
            const outerResponse = outer(innerHandler)(req, metadata);
            outerResponse.catch(() => { }).then(maybeAbort);
            return outerResponse;
        };
        return new HandlerChainBuilder(outerHandler);
    }
}
//# sourceMappingURL=HandlerChainBuilder.js.map