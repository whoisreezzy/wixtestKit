import type { Container } from "@snap/ts-inject";
import type { LensRepository } from "./lens/LensRepository";
import type { LensCoreError } from "./lens-core-module/lensCoreError";
import type { LensCore } from "./lens-core-module/lensCore";
import type { CameraKitSession } from "./session/CameraKitSession";
import type { RootServices } from "./RootServices";
import type { MetricsEventTarget } from "./metrics/metricsEventTarget";
import { TypedEventTarget } from "./events/TypedEventTarget";
import type { TypedCustomEvent } from "./events/TypedCustomEvent";
import type { LensView } from "./metrics/reporters/reportLensView";
import type { LensWait } from "./metrics/reporters/reportLensWait";
import type { PageVisibility } from "./common/pageVisibility";
import type { RemoteConfiguration } from "./remote-configuration/remoteConfiguration";
/**
 * Lens metrics events.
 *
 * These events are emitted by {@link CameraKit} to report lens usage, performance, apply latency, etc.
 *
 * @category Lenses
 * @category Metrics
 */
export type LensMetricsEvents = TypedCustomEvent<LensView["name"], LensView> | TypedCustomEvent<LensWait["name"], LensWait>;
/**
 * Options available when creating a {@link CameraKitSession}.
 *
 * @category Rendering
 */
export interface CreateSessionOptions {
    /**
     * Optionally provide an existing canvas element, on which the Live RenderTarget will be rendered.
     *
     * If this is not provided, CameraKit will create a new canvas element which can be added to the DOM.
     */
    liveRenderTarget?: HTMLCanvasElement;
    /**
     * Browsers optimize tabs when they are hidden - for example, by pausing the execution of requestAnimationFrame
     * callbacks.
     *
     * If you need the CameraKitSession to continue rendering even when the tab is in the background, set this to true.
     * There is a small performance penalty, and it's a good practice to only render in the background if absolutely
     * necessary.
     */
    renderWhileTabHidden?: boolean;
}
/**
 * The entry point to the CameraKit SDK's API. Most of CameraKit's features are accessed via this class.
 *
 * Applications obtain an instance of CameraKit by calling {@link bootstrapCameraKit}.
 *
 * @example
 * ```ts
 * const cameraKit = await bootstrapCameraKit(config)
 * ```
 *
 * Then this class can be used to:
 * - Create a {@link CameraKitSession} instance, which provides the API for setting up media inputs, applying Lenses,
 * and obtaining rendered `<canvas>` outputs.
 * - Query for lenses using {@link LensRepository}.
 * - Listen for lens usage metrics events using {@link MetricsEventTarget}.
 *
 * @category Rendering
 * @category Lenses
 */
export declare class CameraKit {
    /**
     * Used to query for lenses and lens groups.
     */
    readonly lensRepository: LensRepository;
    private readonly lensCore;
    private readonly pageVisibility;
    private readonly container;
    private readonly remoteConfig;
    /** @deprecated Use {@link lensRepository} */
    readonly lenses: {
        repository: LensRepository;
    };
    /**
     * Business metrics (e.g. each time a lens is viewed) are emitted here.
     */
    readonly metrics: TypedEventTarget<LensMetricsEvents>;
    private sessions;
    /** @internal */
    constructor(
    /**
     * Used to query for lenses and lens groups.
     */
    lensRepository: LensRepository, lensCore: LensCore, pageVisibility: PageVisibility, container: Container<RootServices>, remoteConfig: RemoteConfiguration, allMetrics: MetricsEventTarget);
    /**
     * Create a CameraKitSession.
     *
     * This initializes the rendering engine and returns a {@link CameraKitSession} instance, which provides access
     * to Lens rendering.
     *
     * @example
     * ```ts
     * const cameraKit = await bootstrapCameraKit(config)
     * const session = await cameraKit.createSession()
     *
     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)
     * session.applyLens(lens)
     * ```
     *
     * @param options
     */
    createSession({ liveRenderTarget, renderWhileTabHidden, }?: CreateSessionOptions): Promise<CameraKitSession>;
    /**
     * Destroys all sessions and frees all resources.
     */
    destroy(): Promise<void>;
}
/** @internal */
export declare const cameraKitFactory: {
    (args_0: LensRepository, args_1: MetricsEventTarget, args_2: {
        ErrorType: {
            LensDeserialization: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Validation: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Uncategorized: import("./lens-core-module/generated-types").LensCoreEnumValue;
            LensExecution: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Abort: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Uninitialized: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        AssetType: {
            RemoteMediaByUrl: import("./lens-core-module/generated-types").LensCoreEnumValue;
            DeviceDependent: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Static: import("./lens-core-module/generated-types").LensCoreEnumValue;
            URL: import("./lens-core-module/generated-types").LensCoreEnumValue;
            BitmojiDynamicAsset: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        CanvasType: {
            None: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Preview: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Capture: import("./lens-core-module/generated-types").LensCoreEnumValue;
            All: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        LensApiVisibility: {
            Dev: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Private: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Public: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        DeviceClass: {
            Undefined: import("./lens-core-module/generated-types").LensCoreEnumValue;
            BarelyWorking: import("./lens-core-module/generated-types").LensCoreEnumValue;
            LowEnd: import("./lens-core-module/generated-types").LensCoreEnumValue;
            MidEnd: import("./lens-core-module/generated-types").LensCoreEnumValue;
            HighEnd: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        RenderLoopMode: {
            SetTimeout: import("./lens-core-module/generated-types").LensCoreEnumValue;
            RequestAnimationFrame: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        UserDataAccess: {
            Restricted: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Unrestricted: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        InterfaceControl: {
            ToggleCameraButton: import("./lens-core-module/generated-types").LensCoreEnumValue;
            ImagePicker: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Hint: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Modal: import("./lens-core-module/generated-types").LensCoreEnumValue;
            LinkBitmojiCallToAction: import("./lens-core-module/generated-types").LensCoreEnumValue;
            SnapButton: import("./lens-core-module/generated-types").LensCoreEnumValue;
            PlayButton: import("./lens-core-module/generated-types").LensCoreEnumValue;
            All: import("./lens-core-module/generated-types").LensCoreEnumValue;
            ExitFullScreenButton: import("./lens-core-module/generated-types").LensCoreEnumValue;
            MemoriesButton: import("./lens-core-module/generated-types").LensCoreEnumValue;
            LensAttachmentButton: import("./lens-core-module/generated-types").LensCoreEnumValue;
            ReverseCamera: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        InterfaceAction: {
            EnableHighlight: import("./lens-core-module/generated-types").LensCoreEnumValue;
            DisableHighlight: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Trigger: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Show: import("./lens-core-module/generated-types").LensCoreEnumValue;
            Hide: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        ExternalMediaOrientation: {
            CW0: import("./lens-core-module/generated-types").LensCoreEnumValue;
            CW90: import("./lens-core-module/generated-types").LensCoreEnumValue;
            CW180: import("./lens-core-module/generated-types").LensCoreEnumValue;
            CW270: import("./lens-core-module/generated-types").LensCoreEnumValue;
        };
        mainScriptUrlOrBlob: string;
    } & {
        getCoreVersion: () => number;
        getOutputCanvases: () => import("./lens-core-module/generated-types").GetOutputCanvasesOutput;
        startProfiling: () => void;
        endProfiling: () => void;
        registerUriListener: (scheme: string, route: string, listener: import("./lens-core-module/generated-types").UriListener) => void;
        provideUriResponse: (requestId: string, response: import(".").UriResponse) => void;
        setRemoteAssetsProvider: (provider: import("./lens-core-module/generated-types").SetRemoteAssetsProviderInput) => void;
        setRemoteAssetsUploadHandler: (provider: import("./lens-core-module/generated-types").SetRemoteAssetsUploadHandlerInput) => void;
        provideRemoteAssetsUploadResponse: (assetResponse: import("./lens-core-module/generated-types").ProvideRemoteAssetsUploadResponseInput) => void;
        registerShowHintCallback: (callback: import("./lens-core-module/generated-types").ShowHintCallback) => void;
        registerHideHintCallback: (callback: import("./lens-core-module/generated-types").HideHintCallback) => void;
        registerSavePersistentStoreCallback: (callback: import("./lens-core-module/generated-types").SavePersistentStoreCallback) => void;
        setInterfaceControlVisibility: (config: import("./lens-core-module/generated-types").SetInterfaceControlVisibilityInput) => void;
        handleClientInterfaceAction: (config: import("./lens-core-module/generated-types").HandleClientInterfaceActionInput) => void;
        provideExternalImage: (config: import("./lens-core-module/generated-types").ProvideExternalImageInput) => void;
        provideExternalVideo: (config: import("./lens-core-module/generated-types").ProvideExternalVideoInput) => void;
        setScreenDimmingRequestHandler: (callback: import("./lens-core-module/generated-types").ScreenDimmingRequestHandler) => void;
        setClientInterfaceRequestHandler: (callback: import("./lens-core-module/generated-types").ClientInterfaceRequestHandler) => void;
        setPreloadedConfiguration: (config: import("./lens-core-module/generated-types").SetPreloadedConfigurationInput) => void;
        setAllSoundsMuted: (config: import("./lens-core-module/generated-types").SetAllSoundsMutedInput) => void;
        setSystemFonts: (config: import("./lens-core-module/generated-types").SetSystemFontsInput) => void;
        registerBeginWebXrHandler: (handler: ((config: import("./lens-core-module/generated-types").BeginWebXrInput) => void) | null) => void;
        registerEndWebXrHandler: (handler: (() => void) | null) => void;
        setGeoDataProvider: (provider: import("./lens-core-module/generated-types").SetGeoDataProviderInput) => void;
        provideGeoData: (config: import("./lens-core-module/generated-types").ProvideGeoDataInput) => void;
    } & {
        processFrame: (input: Omit<import("./lens-core-module/generated-types").ProcessFrameInput, "onFailure" | "onSuccess">) => Promise<any>;
        addLens: (input: Omit<import("./lens-core-module/generated-types").AddLensInput, "onFailure" | "onSuccess">) => Promise<any>;
        replaceLenses: (input: Omit<import("./lens-core-module/generated-types").ReplaceLensesInput, "onFailure" | "onSuccess">) => Promise<any>;
        removeLens: (input: Omit<import("./lens-core-module/generated-types").RemoveLensInput, "onFailure" | "onSuccess">) => Promise<any>;
        clearAllLenses: () => Promise<any>;
        teardown: () => Promise<any>;
        useMediaElement: (input: Omit<import("./lens-core-module/generated-types").UseMediaElementInput, "onFailure" | "onSuccess">) => Promise<any>;
        setFPSLimit: (input: Omit<import("./lens-core-module/generated-types").SetFpsLimitInput, "onFailure" | "onSuccess">) => Promise<any>;
        setRenderLoopMode: (input: Omit<import("./lens-core-module/generated-types").SetRenderLoopInput, "onFailure" | "onSuccess">) => Promise<any>;
        pauseCanvas: (input: Omit<import("./lens-core-module/generated-types").PauseCanvasInput, "onFailure" | "onSuccess">) => Promise<any>;
        setRenderSize: (input: Omit<import("./lens-core-module/generated-types").SetRenderSizeMatchInputResolutionInput, "onFailure" | "onSuccess"> | Omit<import("./lens-core-module/generated-types").SetRenderSizeExplicitInput, "onFailure" | "onSuccess">) => Promise<any>;
        setInputTransform: (input: Omit<import("./lens-core-module/generated-types").SetInputTransformInput, "onFailure" | "onSuccess">) => Promise<any>;
        imageToYuvBuffer: (input: Omit<import("./lens-core-module/generated-types").ImageToYuvBufferInput, "onFailure" | "onSuccess">) => Promise<ArrayBuffer>;
        yuvBufferToBitmap: (input: Omit<import("./lens-core-module/generated-types").YuvBufferToBitmapInput, "onFailure" | "onSuccess">) => Promise<ImageBitmap>;
        setOnFrameProcessedCallback: (input: Omit<import("./lens-core-module/generated-types").SetOnFrameProcessedInput, "onFailure" | "onSuccess">) => Promise<any>;
        setDeviceClass: (input: Omit<import("./lens-core-module/generated-types").SetDeviceClassInput, "onFailure" | "onSuccess">) => Promise<any>;
        setAudioParameters: (input: Omit<import("./lens-core-module/generated-types").SetAudioParametersInput, "onFailure" | "onSuccess">) => Promise<any>;
        processAudioSampleBuffer: (input: Omit<import("./lens-core-module/generated-types").ProcessAudioSampleBufferInput, "onFailure" | "onSuccess">) => Promise<any>;
        setGpuIndex: (input: Omit<import("./lens-core-module/generated-types").SetGpuIndexInput, "onFailure" | "onSuccess">) => Promise<any>;
    } & {
        initialize(input: {
            canvas?: string | HTMLCanvasElement | undefined;
            outputResolution?: import("./lens-core-module/generated-types").Dimensions | undefined;
            showFpsPanel?: boolean | undefined;
            shouldUseWorker?: boolean | undefined;
            onFrameProcessed?: ((arg: import("./lens-core-module/generated-types").OnFrameProcessedParam) => void) | undefined;
            xrCapabilities?: import("./lens-core-module/generated-types").XrCapabilities | undefined;
            exceptionHandler?: ((err: LensCoreError) => void) | undefined;
        }): Promise<void>;
        provideRemoteAssetsResponse(input: {
            assetId: string;
            assetType: import("./lens-core-module/generated-types").LensCoreEnumValue;
            assetBuffer?: ArrayBuffer | undefined;
            assetChecksum?: string | undefined;
            onFailure?: ((err: LensCoreError) => void) | undefined;
        }): void;
        playCanvas(input: Omit<import("./lens-core-module/generated-types").PlayCanvasInput, "onFailure" | "onSuccess" | "onReady">): Promise<void>;
    } & import("./lens-core-module/lensCore").LensCoreErrorField, args_3: PageVisibility, args_4: RemoteConfiguration, args_5: Container<{
        LensRepository: LensRepository;
    } & {
        metricsEventTarget: MetricsEventTarget;
    } & {
        lensCore: LensCore;
    } & {
        pageVisibility: PageVisibility;
    } & {
        remoteConfiguration: RemoteConfiguration;
    } & {
        lensCore: LensCore;
    } & import("./RootServices").PublicServices & import("@snap/ts-inject").ServicesFromInjectables<[{
        (): PageVisibility;
        token: "pageVisibility";
        dependencies: [];
    }, {
        (): MetricsEventTarget;
        token: "metricsEventTarget";
        dependencies: [];
    }, {
        (): import("./handlers/requestStateEmittingHandler").RequestStateEventTarget;
        token: "requestStateEventTarget";
        dependencies: [];
    }, {
        (args_0: import("./configuration").CameraKitConfiguration, args_1: import(".").FetchHandler): import("./handlers/HandlerChainBuilder").Handler<RequestInfo, Response, RequestInit | undefined>;
        token: "cameraKitServiceFetchHandler";
        dependencies: readonly ["configuration", "defaultFetchHandler"];
    }, {
        (args_0: import("./configuration").CameraKitConfiguration, args_1: import(".").FetchHandler, args_2: import("./handlers/requestStateEmittingHandler").RequestStateEventTarget): import("./clients/grpcHandler").GrpcHandler;
        token: "grpcHandlerFactory";
        dependencies: readonly ["configuration", "cameraKitServiceFetchHandler", "requestStateEventTarget"];
    }, {
        (args_0: import("./clients/grpcHandler").GrpcHandler): import("./clients/lensesClient").LensesClient;
        token: "lensesClient";
        dependencies: readonly ["grpcHandlerFactory"];
    }, {
        (args_0: import("./clients/grpcHandler").GrpcHandler): import("./clients/remoteApiSpecsClient").RemoteApiSpecsClient;
        token: "remoteApiSpecsClient";
        dependencies: readonly ["grpcHandlerFactory"];
    }, {
        (args_0: import("./configuration").CameraKitConfiguration, args_1: import("./handlers/requestStateEmittingHandler").RequestStateEventTarget, args_2: import("./clients/metricsClient").MetricsClient): import("./handlers/HandlerChainBuilder").Handler<Partial<import("./generated-proto/pb_schema/cdp/cof/config_request").ConfigTargetingRequest>, import("./generated-proto/pb_schema/cdp/cof/config_response").ConfigTargetingResponse, import("./remote-configuration/cofHandler").Metadata & {
            signal?: AbortSignal | null | undefined;
            isSideEffect?: boolean | undefined;
        }>;
        token: "cofHandler";
        dependencies: readonly ["configuration", "requestStateEventTarget", "metricsClient"];
    }, {
        (args_0: import("./configuration").CameraKitConfiguration, args_1: import("./handlers/HandlerChainBuilder").Handler<Partial<import("./generated-proto/pb_schema/cdp/cof/config_request").ConfigTargetingRequest>, import("./generated-proto/pb_schema/cdp/cof/config_response").ConfigTargetingResponse, import("./remote-configuration/cofHandler").Metadata & {
            signal?: AbortSignal | null | undefined;
            isSideEffect?: boolean | undefined;
        }>, args_2: import("./clients/grpcHandler").GrpcHandler): RemoteConfiguration;
        token: "remoteConfiguration";
        dependencies: readonly ["configuration", "cofHandler", "grpcHandlerFactory"];
    }, {
        (args_0: import("./handlers/requestStateEmittingHandler").RequestStateEventTarget, args_1: import(".").FetchHandler, args_2: import(".").LensSource[], args_3: import("./lens/assets/LensAssetRepository").LensAssetRepository): LensRepository;
        token: "LensRepository";
        dependencies: readonly ["requestStateEventTarget", "defaultFetchHandler", "lensSources", "lensAssetRepository"];
    }, {
        (args_0: LensCore): import("./persistence/IndexedDBPersistence").IndexedDBPersistence<ArrayBuffer>;
        token: "lensPersistenceStore";
        dependencies: readonly ["lensCore"];
    }, {
        (args_0: import("rxjs").Subject<import(".").Metric>, args_1: import("./clients/grpcHandler").GrpcHandler, args_2: PageVisibility): import("./clients/metricsClient").MetricsClient;
        token: "metricsClient";
        dependencies: readonly ["externalMetricsSubject", "grpcHandlerFactory", "pageVisibility"];
    }, {
        (args_0: LensCore, args_1: import(".").AssetLoader, args_2: import(".").AssetLoader, args_3: import(".").AssetLoader, args_4: MetricsEventTarget, args_5: import("./handlers/requestStateEmittingHandler").RequestStateEventTarget): import("./lens/assets/LensAssetRepository").LensAssetRepository;
        token: "lensAssetRepository";
        dependencies: readonly ["lensCore", "deviceDependentAssetLoader", "remoteMediaAssetLoader", "staticAssetLoader", "metricsEventTarget", "requestStateEventTarget"];
    }, {
        (args_0: import(".").FetchHandler, args_1: RemoteConfiguration): import(".").AssetLoader;
        token: "deviceDependentAssetLoader";
        dependencies: readonly ["defaultFetchHandler", "remoteConfiguration"];
    }, {
        (args_0: import(".").FetchHandler): import(".").AssetLoader;
        token: "staticAssetLoader";
        dependencies: readonly ["defaultFetchHandler"];
    }, {
        (args_0: RemoteConfiguration, args_1: import("./legal/legalPrompt").LegalPromptFactory): import("@snap/state-management").StateMachine<import("@snap/state-management").Action<"requestLegalPrompt", undefined> | import("@snap/state-management").Action<"accept", string> | import("@snap/state-management").Action<"reject", string>, import("@snap/state-management").State<"unknown", undefined> | import("@snap/state-management").State<"accepted", undefined> | import("@snap/state-management").State<"rejected", undefined>>;
        token: "legalState";
        dependencies: readonly ["remoteConfiguration", "legalPrompt"];
    }, {
        (): import("./legal/legalPrompt").LegalPromptFactory;
        token: "legalPrompt";
        dependencies: [];
    }, {
        (): import("rxjs").Observable<import("./logger/logger").LogEntry>;
        token: "logEntries";
        dependencies: [];
    }, {
        (args_0: import("rxjs").Observable<import("./logger/logger").LogEntry>, args_1: MetricsEventTarget, args_2: import("./clients/metricsClient").MetricsClient): import("./metrics/reporters/reportGlobalException").GlobalExceptionReporter;
        token: "reportGlobalException";
        dependencies: readonly ["logEntries", "metricsEventTarget", "metricsClient"];
    }]>>): CameraKit;
    token: "CameraKit";
    dependencies: readonly ["LensRepository", "metricsEventTarget", "lensCore", "pageVisibility", "remoteConfiguration", "$container"];
};
//# sourceMappingURL=CameraKit.d.ts.map