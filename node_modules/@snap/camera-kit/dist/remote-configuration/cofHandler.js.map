{"version":3,"file":"cofHandler.js","sourceRoot":"","sources":["../../src/remote-configuration/cofHandler.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable max-len */\nimport { BrowserHeaders } from \"browser-headers\";\nimport { Injectable } from \"@snap/ts-inject\";\nimport { getCameraKitUserAgent } from \"../platform/cameraKitUserAgent\";\nimport { ensureError } from \"../common/errorHelpers\";\nimport { unionBy } from \"../common/unionBy\";\nimport { CircumstancesServiceClientImpl, GrpcWebImpl } from \"../generated-proto/pb_schema/cdp/cof/circumstance_service\";\nimport type { ConfigTargetingRequest } from \"../generated-proto/pb_schema/cdp/cof/config_request\";\nimport type { ConfigTargetingResponse } from \"../generated-proto/pb_schema/cdp/cof/config_response\";\nimport type { RequestMetadata } from \"../handlers/HandlerChainBuilder\";\nimport { HandlerChainBuilder } from \"../handlers/HandlerChainBuilder\";\nimport type { RequestStateEventTarget } from \"../handlers/requestStateEmittingHandler\";\nimport {\n    dispatchRequestCompleted,\n    dispatchRequestErrored,\n    dispatchRequestStarted,\n    requestStateEventTargetFactory,\n} from \"../handlers/requestStateEmittingHandler\";\nimport { createResponseCachingHandler, staleWhileRevalidateStrategy } from \"../handlers/responseCachingHandler\";\nimport { createRetryingHandler } from \"../handlers/retryingHandler\";\nimport { createTimeoutHandler } from \"../handlers/timeoutHandler\";\nimport { IndexedDBPersistence } from \"../persistence/IndexedDBPersistence\";\nimport type { CameraKitConfiguration } from \"../configuration\";\nimport { configurationToken } from \"../configuration\";\nimport { getLogger } from \"../logger/logger\";\nimport { ExpiringPersistence } from \"../persistence/ExpiringPersistence\";\nimport { convertDaysToSeconds } from \"../common/time\";\nimport type { MetricsClient } from \"../clients/metricsClient\";\nimport { metricsClientFactory } from \"../clients/metricsClient\";\nimport { Count } from \"../metrics/operational/Count\";\n\nexport interface Metadata {\n    [key: string]: string;\n}\n\nexport const COF_REQUEST_TYPE = \"cof\";\n\nexport type CofDimensions = { requestType: typeof COF_REQUEST_TYPE; delta: string };\n\nconst logger = getLogger(\"cofHandler\");\n\n/**\n * Handler chain used to make COF requests. Uses the COF client to perform the\n * requests, with retries, timeout, and caching.\n *\n * The handler will first attempt to retrieve the COF response from cache. If it is found, the result is returned\n * immediately and the cache is updated in the background. If no response is found, a COF request is made. This request\n * will retry (with exponential backoff + jitter) for 5 seconds before returning an error to the caller.\n */\nexport const cofHandlerFactory = Injectable(\n    \"cofHandler\",\n    [configurationToken, requestStateEventTargetFactory.token, metricsClientFactory.token] as const,\n    (config: CameraKitConfiguration, requestStateEventTarget: RequestStateEventTarget, metrics: MetricsClient) => {\n        const cofCache = new ExpiringPersistence<ConfigTargetingResponse>(\n            () => convertDaysToSeconds(365),\n            new IndexedDBPersistence({ databaseName: \"COFCache\" })\n        );\n        const getCacheKey = (r: Partial<ConfigTargetingRequest>) => JSON.stringify(r);\n        // We need to wrap `targetingQuery` to create a usable Handler â€“ the main issue is that HandlerChainBuilder\n        // always adds a `signal` property to the metadata argument (second argument of the Handler), but\n        // `targetingQuery` expects the second argument to only contain headers.\n        return (\n            new HandlerChainBuilder(\n                async (\n                    request: Partial<ConfigTargetingRequest>,\n                    { signal, isSideEffect: _, ...metadata }: Metadata & RequestMetadata\n                ) => {\n                    const rpc = new GrpcWebImpl(`https://${config.apiHostname}`, {});\n                    const client = new CircumstancesServiceClientImpl(rpc);\n                    return new Promise<ConfigTargetingResponse>(async (resolve, reject) => {\n                        if (signal) {\n                            signal.addEventListener(\"abort\", () =>\n                                reject(new Error(\"COF request aborted by handler chain.\"))\n                            );\n                        }\n\n                        const cachedResponse = await cofCache.retrieve(getCacheKey(request)).catch((e) => {\n                            logger.warn(\"Unable to get COF response from cache.\", e);\n                            return {\n                                configResultsEtag: undefined,\n                                configResults: [],\n                            };\n                        });\n                        const dimensions: CofDimensions = {\n                            requestType: COF_REQUEST_TYPE,\n                            delta: `${!!cachedResponse?.configResultsEtag}`,\n                        };\n                        const { requestId } = dispatchRequestStarted(requestStateEventTarget, { dimensions });\n\n                        try {\n                            const response = await client.targetingQuery(\n                                {\n                                    ...request,\n                                    configResultsEtag: cachedResponse?.configResultsEtag,\n                                    deltaSync: !!cachedResponse?.configResultsEtag,\n                                },\n                                new BrowserHeaders({\n                                    authorization: `Bearer ${config.apiToken}`,\n                                    \"x-snap-client-user-agent\": getCameraKitUserAgent(),\n                                    ...metadata,\n                                })\n                            );\n\n                            // NOTE: in order for cache persistence to work, we need to make the\n                            // object cloneable i.e. with no methods (it appears targetingQuery()\n                            // attaches toObject() to response object). Safety: We have to cast response\n                            // object to a type that has toObject defined, because that is indeed\n                            // what generated code has:\n                            // eslint-disable-next-line max-len\n                            // https://github.sc-corp.net/Snapchat/camera-kit-web-sdk/blob/8d6b4e8bfa3717b376ab197a49972a1e410851f7/packages/web-sdk/src/generated-proto/pb_schema/cdp/cof/circumstance_service.ts#L1459\n                            delete (response as any).toObject;\n\n                            // Merge the cached configs into the just-returned configs,\n                            // making sure to remove any configs that are marked as deleted -- this will then get cached\n                            // by the responseCachingHandler as we return up the handler chain.\n                            const configResults = unionBy(\n                                \"configId\",\n                                cachedResponse?.configResults ?? [],\n                                response.configResults\n                            ).filter((config) => !config.delete);\n\n                            // TODO: We hardcode status code and sizeByte values because we do not have access to\n                            // underlying transport of configs-web.\n                            // When this ticket is done https://jira.sc-corp.net/browse/CAMKIT-2840,\n                            // we will remove this handler and benefit from existing ones.\n                            const status = 200;\n                            let sizeByte = 0;\n                            try {\n                                sizeByte = new TextEncoder().encode(JSON.stringify(response)).byteLength;\n                            } finally {\n                                dispatchRequestCompleted(requestStateEventTarget, {\n                                    requestId,\n                                    dimensions,\n                                    status,\n                                    sizeByte,\n                                });\n                            }\n\n                            resolve({\n                                ...response,\n                                configResults,\n                            });\n                        } catch (error) {\n                            dispatchRequestErrored(requestStateEventTarget, {\n                                requestId,\n                                dimensions,\n                                error: ensureError(error),\n                            });\n                            reject(error);\n                        }\n                    });\n                }\n            )\n                // targetingQuery() always converts failed responses into errors (unlike fetch()), so we need a custom\n                // retryPredicate that retries all errors. We'll keep retrying (with backoff) for 20 seconds total\n                // elapsed time before we return an error back up the chain.\n                .map(createRetryingHandler({ retryPredicate: (r) => r instanceof Error }))\n                // API gateway has 15 seconds timeout, so we rely on that first\n                .map(createTimeoutHandler({ timeout: 20 * 1000 }))\n                .map(\n                    createResponseCachingHandler(\n                        cofCache,\n                        getCacheKey,\n                        // If we have a matching response already in cache,\n                        // we'll return it immediately and then update the cache in the background.\n                        staleWhileRevalidateStrategy({\n                            onMiss: () => {\n                                metrics.setOperationalMetrics(\n                                    Count.count(\"cache_miss\", 1, { request_type: COF_REQUEST_TYPE })\n                                );\n                            },\n                        })\n                    )\n                ).handler\n        );\n    }\n);\n"]}