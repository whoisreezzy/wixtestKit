import { from, map, mergeMap, shareReplay, take } from "rxjs";
import { Injectable } from "@snap/ts-inject";
import { configurationToken } from "../configuration";
import { Namespace } from "../generated-proto/pb_schema/cdp/cof/namespace";
import { MetricsDefinition } from "../generated-proto/pb_schema/camera_kit/v3/service";
import { grpcHandlerFactory } from "../clients/grpcHandler";
import { createTsProtoClient } from "../clients/createTsProtoClient";
import { cofHandlerFactory } from "./cofHandler";
const defaultTargetingRequest = {
    namespaces: [Namespace.LENS_CORE, Namespace.CAMERA_KIT_CORE, Namespace.LENS_CORE_CONFIG],
};
export class RemoteConfiguration {
    constructor(lensPerformance, cofHandler, grpcClient) {
        const lensCluster = Promise.resolve(lensPerformance).then((lensPerformance) => {
            return (lensPerformance === null || lensPerformance === void 0 ? void 0 : lensPerformance.cluster) === 0 ? undefined : lensPerformance === null || lensPerformance === void 0 ? void 0 : lensPerformance.cluster;
        });
        this.configById = from(lensCluster).pipe(mergeMap((lensClusterOrig4) => from(cofHandler(Object.assign(Object.assign({}, defaultTargetingRequest), { lensClusterOrig4 })))), map((result) => {
            const configById = new Map();
            result.configResults.forEach((config) => {
                var _a;
                const configsWithId = (_a = configById.get(config.configId)) !== null && _a !== void 0 ? _a : [];
                configsWithId.push(config);
                configById.set(config.configId, configsWithId);
            });
            return configById;
        }), shareReplay(1));
        this.initializationConfig = from(grpcClient.getInitializationConfig({})).pipe(map((result) => {
            if (result.ok) {
                const response = result.unwrap();
                if (response.message)
                    return response.message;
                else
                    throw new Error("Failed to load initialization config. gRPC response successful, but " +
                        `message was null. gRPC status: ${response.statusMessage}`);
            }
            throw new Error(`Failed to load initialization config. gRPC status message: ${result.unwrapErr().statusMessage}`);
        }), shareReplay(1));
    }
    get(configId) {
        return this.configById.pipe(map((config) => { var _a; return (_a = config.get(configId)) !== null && _a !== void 0 ? _a : []; }));
    }
    getInitializationConfig() {
        return this.initializationConfig;
    }
    getGpuIndexConfig() {
        const lensClusterConfigName = "LENS_FEATURE_GPU_INDEX";
        return this.get(lensClusterConfigName).pipe(map((configResults) => {
            var _a, _b;
            if (configResults.length === 0) {
                throw new Error(`Cannot find '${lensClusterConfigName}' config.`);
            }
            return (_b = (_a = configResults[0].value) === null || _a === void 0 ? void 0 : _a.intValue) !== null && _b !== void 0 ? _b : -1;
        }), shareReplay(1));
    }
    getNamespace(namespace) {
        return this.configById.pipe(map((configs) => {
            const namespaceConfigs = Array.from(configs.values())
                .filter((values) => values.some((c) => c.namespace === namespace))
                .flatMap((results) => results);
            return namespaceConfigs;
        }));
    }
}
export const remoteConfigurationFactory = Injectable("remoteConfiguration", [configurationToken, cofHandlerFactory.token, grpcHandlerFactory.token], (config, cofHandler, grpcHandler) => {
    const remoteConfig = new RemoteConfiguration(config.lensPerformance, cofHandler, createTsProtoClient(MetricsDefinition, grpcHandler));
    remoteConfig.get("").pipe(take(1)).subscribe();
    return remoteConfig;
});
//# sourceMappingURL=remoteConfiguration.js.map