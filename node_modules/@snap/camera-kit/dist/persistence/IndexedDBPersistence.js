import { __awaiter } from "tslib";
import { isValidKey } from "./Persistence";
function wrapRequest(request) {
    const p = new Promise((resolve, reject) => {
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
    });
    p.request = request;
    return p;
}
function wrapCursorRequest(request) {
    return new Promise((resolve, reject) => {
        request.onsuccess = () => {
            const cursor = request.result;
            if (!cursor)
                resolve({ cursor: null, continue: () => Promise.reject() });
            else
                resolve({
                    cursor,
                    continue: () => {
                        cursor.continue();
                        return wrapCursorRequest(request);
                    },
                });
        };
        request.onerror = () => reject(request.error);
    });
}
export class IndexedDBPersistence {
    constructor(options) {
        var _a;
        this.databaseName = `Snap.CameraKit.${options.databaseName}`;
        this.databaseVersion = options.databaseVersion;
        this.objectStore = (_a = options.objectStore) !== null && _a !== void 0 ? _a : options.databaseName;
        this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
        this.size = 0;
    }
    retrieve(key) {
        return this.simpleTransaction("readonly", (store) => store.get(key));
    }
    retrieveAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const { store, done } = yield this.transaction("readonly");
            let request = yield wrapCursorRequest(store.openCursor());
            while (request.cursor) {
                results.push([request.cursor.primaryKey, request.cursor.value]);
                request = yield request.continue();
            }
            yield done;
            return results;
        });
    }
    remove(key) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.simpleTransaction("readwrite", (store) => store.delete(key));
            this.size--;
        });
    }
    removeAll() {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const { store, done } = yield this.transaction("readwrite");
            let request = yield wrapCursorRequest(store.openCursor());
            const deleteRequests = [];
            while (request.cursor) {
                results.push(request.cursor.value);
                deleteRequests.push(wrapRequest(store.delete(request.cursor.key)));
                request = yield request.continue();
            }
            yield Promise.all(deleteRequests.concat(done));
            this.size = 0;
            return results;
        });
    }
    store(keyOrValue, maybeValue) {
        return __awaiter(this, void 0, void 0, function* () {
            const [key, value] = maybeValue === undefined ? [undefined, keyOrValue] : [keyOrValue, maybeValue];
            if (!isValidKey(key) && typeof key !== "undefined")
                throw new TypeError(`IndexedDBPersistence failed to ` + `store a value. Invalid key type: ${typeof key}`);
            const storedKey = yield this.simpleTransaction("readwrite", (store) => store.put(value, key));
            this.size++;
            return storedKey;
        });
    }
    openDatabase(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const dbPromise = wrapRequest(request);
            dbPromise.request.onupgradeneeded = () => {
                try {
                    dbPromise.request.result.createObjectStore(this.objectStore, { autoIncrement: true });
                }
                catch (error) {
                    if (error instanceof DOMException && error.name === "ConstraintError")
                        return;
                    throw error;
                }
            };
            const db = yield dbPromise;
            db.onclose = () => {
                this.db = this.openDatabase(indexedDB.open(this.databaseName, this.databaseVersion));
            };
            return db;
        });
    }
    simpleTransaction(mode, operation) {
        return __awaiter(this, void 0, void 0, function* () {
            const { store, done } = yield this.transaction(mode);
            const [result] = yield Promise.all([wrapRequest(operation(store)), done]);
            return result;
        });
    }
    transaction(mode) {
        return __awaiter(this, void 0, void 0, function* () {
            const db = yield this.db;
            const tx = db.transaction(this.objectStore, mode);
            const store = tx.objectStore(this.objectStore);
            const done = new Promise((resolve, reject) => {
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
                tx.onabort = () => reject(new DOMException("The transaction was aborted", "AbortError"));
            });
            return { tx, store, done };
        });
    }
}
//# sourceMappingURL=IndexedDBPersistence.js.map