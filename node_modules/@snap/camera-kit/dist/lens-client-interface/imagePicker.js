import { __awaiter } from "tslib";
import { fileOpen } from "browser-fs-access";
import { getLogger } from "../logger/logger";
import { extractJpegOrientationTag } from "./exif";
const logger = getLogger("lensClientInterfaceImagePicker");
const mimeTypes = {
    image: [
        "image/avif",
        "image/bmp",
        "image/gif",
        "image/jpeg",
        "image/png",
        "image/svg+xml",
        "image/tiff",
        "image/webp",
    ],
    video: [
        "video/3gpp",
        "video/3gpp2",
        "video/mp2t",
        "video/mp4",
        "video/mpeg",
        "video/ogg",
        "video/quicktime",
        "video/webm",
        "video/x-msvideo",
    ],
};
function* enumerateSupportedVideoTypes(types) {
    const testVideoElement = typeof document !== "undefined" ? document.createElement("video") : undefined;
    for (const type of types) {
        if ((testVideoElement === null || testVideoElement === void 0 ? void 0 : testVideoElement.canPlayType(type)) || false) {
            yield type;
        }
    }
}
function readFileAsArrayBuffer(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener("load", (event) => {
            resolve(event.target.result);
        });
        reader.addEventListener("error", (event) => {
            reject(event.target.error);
        });
        reader.readAsArrayBuffer(file);
    });
}
function getMimeType({ ImageEnabled, VideoEnabled }) {
    const types = [];
    if (ImageEnabled === "1")
        types.push(...mimeTypes.image);
    if (VideoEnabled === "1")
        types.push(...enumerateSupportedVideoTypes(mimeTypes.video));
    if (types.length === 0) {
        throw new Error("Unknown media type requested.");
    }
    return types;
}
function getOrientation(data, lensCore) {
    var _a;
    const orientationMap = {
        [1]: lensCore.ExternalMediaOrientation.CW0,
        [2]: lensCore.ExternalMediaOrientation.CW0,
        [3]: lensCore.ExternalMediaOrientation.CW180,
        [4]: lensCore.ExternalMediaOrientation.CW180,
        [5]: lensCore.ExternalMediaOrientation.CW90,
        [6]: lensCore.ExternalMediaOrientation.CW90,
        [7]: lensCore.ExternalMediaOrientation.CW270,
        [8]: lensCore.ExternalMediaOrientation.CW270,
    };
    try {
        return orientationMap[(_a = extractJpegOrientationTag(data)) !== null && _a !== void 0 ? _a : 1];
    }
    catch (error) {
        logger.info("Error occurred while reading EXIF orientation tag.", error);
        return lensCore.ExternalMediaOrientation.CW0;
    }
}
export function pickClientImage(clientInterfaceData, lensCore, filePicker) {
    return __awaiter(this, void 0, void 0, function* () {
        const mimeTypes = getMimeType(clientInterfaceData);
        logger.debug(`Opening file dialog for MIME types: ${mimeTypes}`);
        const file = yield filePicker({ mimeTypes }, fileOpen);
        if (Array.isArray(file)) {
            throw new Error("Multiple files are not supported.");
        }
        logger.debug(`Selected file MIME type: ${file.type}`);
        const data = yield readFileAsArrayBuffer(file);
        if (file.type.startsWith("image/")) {
            lensCore.provideExternalImage({
                data,
                orientation: getOrientation(data, lensCore),
                faceRects: [
                    {
                        origin: {
                            x: 0,
                            y: 0,
                        },
                        size: {
                            width: 1,
                            height: 1,
                        },
                    },
                ],
            });
        }
        else {
            lensCore.provideExternalVideo({
                data,
                orientation: lensCore.ExternalMediaOrientation.CW0,
            });
        }
    });
}
//# sourceMappingURL=imagePicker.js.map