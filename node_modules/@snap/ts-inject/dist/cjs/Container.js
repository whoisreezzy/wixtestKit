"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = exports.CONTAINER = void 0;
const memoize_1 = require("./memoize");
const PartialContainer_1 = require("./PartialContainer");
const Injectable_1 = require("./Injectable");
const entries_1 = require("./entries");
exports.CONTAINER = "$container";
class Container {
    static provides(fnOrContainer) {
        if (fnOrContainer instanceof PartialContainer_1.PartialContainer)
            return new Container({}).provides(fnOrContainer);
        if (fnOrContainer instanceof Container)
            return new Container({}).provides(fnOrContainer);
        return new Container({}).provides(fnOrContainer);
    }
    static providesValue(token, value) {
        return new Container({}).providesValue(token, value);
    }
    static fromObject(services) {
        return (0, entries_1.entries)(services).reduce((container, [token, value]) => container.providesValue(token, value), new Container({}));
    }
    factories;
    constructor(factories) {
        const memoizedFactories = {};
        for (const k in factories) {
            const fn = factories[k];
            if ((0, memoize_1.isMemoized)(fn)) {
                memoizedFactories[k] = fn;
                fn.thisArg = this;
            }
            else {
                memoizedFactories[k] = (0, memoize_1.memoize)(this, fn);
            }
        }
        this.factories = memoizedFactories;
    }
    copy(scopedServices) {
        const factories = { ...this.factories };
        (scopedServices || []).forEach((token) => {
            factories[token] = this.factories[token].delegate;
        });
        return new Container(factories);
    }
    get(token) {
        if (token === exports.CONTAINER)
            return this;
        const factory = this.factories[token];
        if (!factory) {
            throw new Error(`[Container::get] Could not find Service for Token "${String(token)}". This should've caused a ` +
                "compile-time error. If the Token is 'undefined', check all your calls to the Injectable " +
                "function. Make sure you define dependencies using string literals or string constants that are " +
                "definitely initialized before the call to Injectable.");
        }
        return factory();
    }
    run(fnOrContainer) {
        if (fnOrContainer instanceof PartialContainer_1.PartialContainer) {
            const runnableContainer = this.provides(fnOrContainer);
            for (const token of fnOrContainer.getTokens()) {
                runnableContainer.get(token);
            }
        }
        else {
            this.provides(fnOrContainer).get(fnOrContainer.token);
        }
        return this;
    }
    provides(fnOrContainer) {
        if (fnOrContainer instanceof PartialContainer_1.PartialContainer || fnOrContainer instanceof Container) {
            const factories = fnOrContainer instanceof PartialContainer_1.PartialContainer ? fnOrContainer.getFactories(this) : fnOrContainer.factories;
            return new Container({
                ...this.factories,
                ...factories,
            });
        }
        return this.providesService(fnOrContainer);
    }
    providesClass = (token, cls) => this.providesService((0, Injectable_1.ClassInjectable)(token, cls));
    providesValue = (token, value) => this.providesService((0, Injectable_1.Injectable)(token, [], () => value));
    appendValue = (token, value) => this.providesService((0, Injectable_1.ConcatInjectable)(token, () => value));
    appendClass = (token, cls) => this.providesService((0, Injectable_1.ConcatInjectable)(token, () => this.providesClass(token, cls).get(token)));
    append = (fn) => this.providesService((0, Injectable_1.ConcatInjectable)(fn.token, () => this.providesService(fn).get(fn.token)));
    providesService(fn) {
        const token = fn.token;
        const dependencies = fn.dependencies;
        const getFromParent = dependencies.indexOf(token) === -1 ? undefined : () => this.get(token);
        const factory = (0, memoize_1.memoize)(this, function () {
            return fn(...dependencies.map((t) => (t === token ? getFromParent() : this.get(t))));
        });
        const factories = { ...this.factories, [token]: factory };
        return new Container(factories);
    }
}
exports.Container = Container;
//# sourceMappingURL=Container.js.map