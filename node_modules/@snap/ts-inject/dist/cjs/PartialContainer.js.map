{"version":3,"file":"PartialContainer.js","sourceRoot":"","sources":["../../src/PartialContainer.ts"],"names":[],"mappings":";;;AAAA,uCAAoC;AAEpC,uCAAoC;AAWpC,6CAA2D;AAkE3D,MAAa,gBAAgB;IACE;IAA7B,YAA6B,WAAgD;QAAhD,gBAAW,GAAX,WAAW,CAAqC;IAAG,CAAC;IAcjF,QAAQ,CAMN,EAA6E;QAW7E,OAAO,IAAI,gBAAgB,CAAC,EAAE,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC,EAAE,CAAC,KAAK,CAAC,EAAE,EAAE,EAAS,CAAC,CAAC;IAC9E,CAAC;IAeD,aAAa,GAAG,CAAmC,KAAY,EAAE,KAAc,EAAE,EAAE,CACjF,IAAI,CAAC,QAAQ,CAAC,IAAA,uBAAU,EAAC,KAAK,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;IAqBpD,aAAa,GAAG,CAOd,KAAY,EACZ,GAAU,EACV,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAiD,IAAA,4BAAe,EAAC,KAAK,EAAE,GAAG,CAAC,CAAC,CAAC;IAkBhG,YAAY,CAAC,MAA+B;QAC1C,IAAI,SAAS,GAAoD,SAAS,CAAC;QAC3E,OAAO,CAAC,SAAS,GAAG,MAAM,CAAC,WAAW,CACpC,IAAA,iBAAO,EAAC,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC;YAC7C,KAAK;YACL,IAAA,iBAAO,EAAC,MAAM,EAAE,GAAG,EAAE,CACnB,EAAE,CACA,GAAI,EAAE,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;gBAC5B,OAAO,CAAC,KAAK,KAAK;oBAChB,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAuB,CAAC;oBACrC,CAAC,CAAC,SAAU,CAAC,CAAkC,CAAC;wBAC9C,CAAC,CAAC,SAAU,CAAC,CAAC,CAAC,EAAE;wBACjB,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAuB,CAAC,CAAC;YAC5C,CAAC,CAAS,CACX,CACF;SACF,CAAC,CACoC,CAAC,CAAC;IAC5C,CAAC;IAED,SAAS;QACP,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,CAA0B,CAAC;IAChE,CAAC;CACF;AAxHD,4CAwHC","sourcesContent":["import { entries } from \"./entries\";\nimport type { Memoized } from \"./memoize\";\nimport { memoize } from \"./memoize\";\nimport type { Container } from \"./Container\";\nimport type {\n  AddService,\n  InjectableClass,\n  InjectableFunction,\n  ServicesFromTokenizedParams,\n  TokenType,\n  ValidTokens,\n} from \"./types\";\nimport type { ConstructorReturnType } from \"./Injectable\";\nimport { ClassInjectable, Injectable } from \"./Injectable\";\n\n// Using a conditional type forces TS language services to evaluate the type -- so when showing e.g. type hints, we\n// will see the mapped type instead of the AddDependencies type alias. This produces better hints.\ntype AddDependencies<ParentDependencies, Dependencies> = ParentDependencies extends any\n  ? // A mapped type produces better, more concise type hints than an intersection type.\n    {\n      [K in keyof ParentDependencies | keyof Dependencies]: K extends keyof ParentDependencies\n        ? ParentDependencies[K]\n        : K extends keyof Dependencies\n          ? Dependencies[K]\n          : never;\n    }\n  : never;\n\ntype ExcludeKey<T, U> = T extends any ? { [K in Exclude<keyof T, U>]: T[K] } : never;\n\ntype PartialInjectableFunction<\n  Params extends readonly any[],\n  Tokens extends readonly TokenType[],\n  Token extends TokenType,\n  Service,\n> = {\n  (...args: Params): Service;\n  token: Token;\n  dependencies: Tokens;\n};\n\ntype Injectables<Services, Dependencies> = {\n  [K in keyof Services]: K extends TokenType\n    ? InjectableFunction<Services & Dependencies, readonly ValidTokens<Services & Dependencies>[], K, Services[K]>\n    : never;\n};\n\ntype PartialContainerFactories<Services> = {\n  [K in keyof Services]: Memoized<() => Services[K]>;\n};\n\n/**\n * Similar to [Container], with the exception that Services may be provided to a PartialContainer which *does not*\n * contain all of that Services dependencies.\n *\n * For this to remain safe, Services can not be resolved by PartialContainer – it has no `get` method.\n *\n * Instead, the PartialContainer must be provided to a [Container] which *does* contain all the dependencies required\n * by all the Service in the PartialContainer. The resulting [Container] can then resolve these Services.\n *\n * PartialContainers are used to create a collection of Services which can then be provided via a simple one-line syntax\n * to an existing Container (which fulfills the collection's dependencies). It is an organizational tool, allowing\n * coherent groupings of Services to be defined in one place, then combined elsewhere to form a complete [Container].\n *\n * Here's an example of PartialContainer usage:\n * ```ts\n * // We can provide fooFactory, even though the PartialContainer doesn't fulfill the Bar dependency.\n * const fooFactory = Injectable('Foo', ['Bar'] as const, (bar: Bar) => new Foo(bar))\n * const partialContainer = new PartialContainer({}).provide(fooFactory)\n *\n * const barFactory = Injectable('Bar', () => new Bar())\n * const dependenciesContainer = Container.provides(barFactory)\n *\n * const combinedContainer = dependenciesContainer.provides(partialContainer)\n *\n * // We can resolve Foo, because the combined container includes Bar, so all of Foo's dependencies are now met.\n * const foo = combinedContainer.get('Foo')\n * ```\n */\nexport class PartialContainer<Services = {}, Dependencies = {}> {\n  constructor(private readonly injectables: Injectables<Services, Dependencies>) {}\n\n  /**\n   * Create a new PartialContainer which provides a Service created by the given InjectableFunction.\n   *\n   * The InjectableFunction contains metadata specifying the Token by which the created Service will be known, as well\n   * as an ordered list of Tokens to be resolved and provided to the InjectableFunction as arguments.\n   *\n   * The dependencies are allowed to be missing from the PartialContainer, but these dependencies are maintained as a\n   * parameter of the returned PartialContainer. This allows `[Container.provides]` to type check the dependencies and\n   * ensure they can be provided by the Container.\n   *\n   * @param fn A InjectableFunction, taking dependencies as arguments, which returns the Service.\n   */\n  provides<\n    AdditionalDependencies extends readonly any[],\n    Tokens extends readonly TokenType[],\n    Token extends TokenType,\n    Service,\n  >(\n    fn: PartialInjectableFunction<AdditionalDependencies, Tokens, Token, Service>\n  ): PartialContainer<\n    AddService<Services, Token, Service>,\n    // The dependencies of the new PartialContainer are the combined dependencies of this container and the\n    // PartialInjectableFunction -- but we exclude any dependencies already provided by this container (i.e. this\n    // container's Services) as well as the new Service being provided.\n    ExcludeKey<\n      AddDependencies<ExcludeKey<Dependencies, Token>, ServicesFromTokenizedParams<Tokens, AdditionalDependencies>>,\n      keyof Services\n    >\n  > {\n    return new PartialContainer({ ...this.injectables, [fn.token]: fn } as any);\n  }\n\n  /**\n   * Create a new PartialContainer which provides the given value as a Service.\n   *\n   * Example:\n   * ```ts\n   * const partial = new PartialContainer({}).providesValue(\"value\", 42);\n   * const value = Container.provides(partial).get(\"value\");\n   * console.log(value); // 42\n   * ```\n   *\n   * @param token the Token by which the value will be known.\n   * @param value the value to be provided.\n   */\n  providesValue = <Token extends TokenType, Service>(token: Token, value: Service) =>\n    this.provides(Injectable(token, [], () => value));\n\n  /**\n   * Create a new PartialContainer which provides the given class as a Service, all of the class's dependencies will be\n   * resolved by the parent Container.\n   *\n   * Example:\n   * ```ts\n   * class Foo {\n   *  static dependencies = ['bar'] as const;\n   *  constructor(public bar: string) {}\n   * }\n   *\n   * const partial = new PartialContainer({}).providesClass(\"foo\", Foo);\n   * const foo = Container.providesValue(\"bar\", \"bar value\").provides(partial).get(\"foo\");\n   * console.log(foo.bar); // \"bar value\"\n   * ```\n   *\n   * @param token the Token by which the class will be known.\n   * @param cls the class to be provided, must match the InjectableClass type.\n   */\n  providesClass = <\n    Class extends InjectableClass<any, any, any>,\n    AdditionalDependencies extends ConstructorParameters<Class>,\n    Tokens extends Class[\"dependencies\"],\n    Service extends ConstructorReturnType<Class>,\n    Token extends TokenType,\n  >(\n    token: Token,\n    cls: Class\n  ) => this.provides<AdditionalDependencies, Tokens, Token, Service>(ClassInjectable(token, cls));\n\n  /**\n   * In order to create a [Container], the InjectableFunctions maintained by the PartialContainer must be memoized\n   * into Factories that can resolve their dependencies and return the correct Service.\n   *\n   * In particular, this requires access to a \"parent\" Container to avoid infinite looping in cases where Service A\n   * depends on Service A – this is allowed (as long as the parent container provides Service A), but requires access\n   * to the parent Container to provide the parent implementation of Service A.\n   *\n   * This also means that Services provided by a PartialContainer to a Container via this function will always be\n   * scoped to the Container. In other words, if a PartialContainer containing Service A is provided to both\n   * Container X and Container Y, when Service A is resolved by Container X the InjectableFunction used to create\n   * Service A will be invoked – and when Service A is resolved by Container Y, the InjectableFunction will be invoked\n   * again.\n   *\n   * @param parent A [Container] which provides all the required Dependencies of this PartialContainer.\n   */\n  getFactories(parent: Container<Dependencies>): PartialContainerFactories<Services> {\n    let factories: PartialContainerFactories<Services> | undefined = undefined;\n    return (factories = Object.fromEntries(\n      entries(this.injectables).map(([token, fn]) => [\n        token,\n        memoize(parent, () =>\n          fn(\n            ...(fn.dependencies.map((t) => {\n              return t === token\n                ? parent.get(t as keyof Dependencies)\n                : factories![t as keyof Services & Dependencies]\n                  ? factories![t]()\n                  : parent.get(t as keyof Dependencies);\n            }) as any)\n          )\n        ),\n      ])\n    ) as PartialContainerFactories<Services>);\n  }\n\n  getTokens(): Array<keyof Services> {\n    return Object.keys(this.injectables) as Array<keyof Services>;\n  }\n}\n"]}