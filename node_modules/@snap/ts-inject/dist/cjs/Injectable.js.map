{"version":3,"file":"Injectable.js","sourceRoot":"","sources":["../../src/Injectable.ts"],"names":[],"mappings":";;AAuEA,gCA0BC;AAWD,4CAWC;AA2CD,0CAQC;AA2DD,4CA6BC;AA3LD,SAAgB,UAAU,CACxB,KAAgB,EAChB,gBAAqD,EACrD,OAAiC;IAEjC,MAAM,YAAY,GAAgB,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC;IAC1F,MAAM,EAAE,GAAG,OAAO,gBAAgB,KAAK,UAAU,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC;IAE/E,IAAI,CAAC,EAAE,EAAE,CAAC;QACR,MAAM,IAAI,SAAS,CACjB,0FAA0F,GAAG,oBAAoB,CAClH,CAAC;IACJ,CAAC;IAED,IAAI,EAAE,CAAC,MAAM,KAAK,YAAY,CAAC,MAAM,EAAE,CAAC;QACtC,MAAM,IAAI,SAAS,CACjB,4FAA4F;YAC1F,GAAG,EAAE,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,+BAA+B;YACvE,mBAAmB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CACpD,CAAC;IACJ,CAAC;IAED,MAAM,OAAO,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;IAChD,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;IACtB,OAAO,CAAC,YAAY,GAAG,YAAY,CAAC;IACpC,OAAO,OAAO,CAAC;AACjB,CAAC;AAWD,SAAgB,gBAAgB,CAM9B,KAAY,EACZ,YAAoB,EACpB,EAAqF;IAErF,OAAO,UAAU,CAAC,KAAK,EAAE,YAAY,EAAE,EAAE,CAAC,CAAC;AAC7C,CAAC;AA2CD,SAAgB,eAAe,CAC7B,KAAgB,EAChB,GAAoD;IAEpD,MAAM,OAAO,GAAG,CAAC,GAAG,IAAW,EAAE,EAAE,CAAC,IAAI,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;IACrD,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;IACtB,OAAO,CAAC,YAAY,GAAG,GAAG,CAAC,YAAY,CAAC;IACxC,OAAO,OAAO,CAAC;AACjB,CAAC;AA2DD,SAAgB,gBAAgB,CAC9B,KAAgB,EAChB,gBAAqD,EACrD,OAAiC;IAEjC,MAAM,YAAY,GAAgB,KAAK,CAAC,OAAO,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,EAAE,CAAC;IAC1F,MAAM,EAAE,GAAG,OAAO,gBAAgB,KAAK,UAAU,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC,CAAC,OAAO,CAAC;IAE/E,IAAI,CAAC,EAAE,EAAE,CAAC;QACR,MAAM,IAAI,SAAS,CACjB,gGAAgG;YAC9F,oBAAoB,CACvB,CAAC;IACJ,CAAC;IAED,IAAI,EAAE,CAAC,MAAM,KAAK,YAAY,CAAC,MAAM,EAAE,CAAC;QACtC,MAAM,IAAI,SAAS,CACjB,4FAA4F;YAC1F,GAAG,EAAE,CAAC,MAAM,SAAS,YAAY,CAAC,MAAM,+BAA+B;YACvE,mBAAmB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,EAAE,CACpD,CAAC;IACJ,CAAC;IAED,MAAM,OAAO,GAAG,CAAC,KAAY,EAAE,GAAG,IAAW,EAAE,EAAE;QAC/C,OAAO,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,CAAC;IACnC,CAAC,CAAC;IACF,OAAO,CAAC,KAAK,GAAG,KAAK,CAAC;IACtB,OAAO,CAAC,YAAY,GAAG,CAAC,KAAK,EAAE,GAAG,YAAY,CAAC,CAAC;IAChD,OAAO,OAAO,CAAC;AACjB,CAAC","sourcesContent":["import type { InjectableClass, InjectableFunction, ServicesFromTokenizedParams, TokenType } from \"./types\";\n\n/**\n * Creates an Injectable factory function designed for services without dependencies.\n * This is useful for simple services or values that don't depend on other parts of the system.\n *\n * @example\n * ```ts\n * const container = Container.provides(Injectable(\"MyService\", () => new MyService()));\n *\n * const myService = container.get(\"MyService\");\n * ```\n *\n * @param token A unique Token identifying the Service within the container. This token\n *              is used to retrieve the instance from the container.\n * @param fn A zero-argument function that initializes and returns the Service instance.\n *           This can be any class instance, primitive, or complex value meant to be managed\n *           within the DI container.\n */\nexport function Injectable<Token extends TokenType, Service>(\n  token: Token,\n  fn: () => Service\n): InjectableFunction<any, [], Token, Service>;\n\n/**\n * Creates an Injectable factory function that requires dependencies.\n *\n * The dependencies are specified as tokens, and the factory function\n * will receive these dependencies as arguments in the order they are listed.\n *\n * **Important:** This function requires **TypeScript 5 or later** due to the use of `const` type parameters.\n * Users on TypeScript 4 and earlier must use {@link InjectableCompat} instead.\n *\n * @example\n * ```ts\n * const dependencyB = 'DependencyB';\n * const container = Container\n *   .providesValue(\"DependencyA\", new A())\n *   .providesValue(\"DependencyB\", new B())\n *   .provides(Injectable(\n *     \"MyService\",\n *     [\"DependencyA\", dependencyB] as const, // \"as const\" can be omitted in TypeScript 5 and later\n *     (a: A, b: B) => new MyService(a, b),\n *   )\n * )\n *\n * const myService = container.get(\"MyService\");\n * ```\n *\n * @param token A unique Token identifying the Service within the container.\n * @param dependencies A *readonly* array of Tokens representing the dependencies required by the factory function.\n * These will be resolved by the container and provided as arguments to the factory function.\n * @param fn A factory function whose parameters match the dependencies. This function should initialize and\n * return an instance of the Service. The types and number of its parameters must exactly match the dependencies.\n */\nexport function Injectable<\n  Token extends TokenType,\n  const Tokens extends readonly TokenType[],\n  Params extends readonly any[],\n  Service,\n>(\n  token: Token,\n  dependencies: Tokens,\n  // The function arity (number of arguments) must match the number of dependencies specified â€“ if they don't, we'll\n  // force a compiler error by saying the arguments should be `void[]`. We'll also throw at runtime, so the return\n  // type will be `never`.\n  fn: (...args: Tokens[\"length\"] extends Params[\"length\"] ? Params : void[]) => Service\n): Tokens[\"length\"] extends Params[\"length\"]\n  ? InjectableFunction<ServicesFromTokenizedParams<Tokens, Params>, Tokens, Token, Service>\n  : never;\n\nexport function Injectable(\n  token: TokenType,\n  dependenciesOrFn?: readonly TokenType[] | (() => any),\n  maybeFn?: (...args: any[]) => any\n): InjectableFunction<any, readonly TokenType[], TokenType, any> {\n  const dependencies: TokenType[] = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];\n  const fn = typeof dependenciesOrFn === \"function\" ? dependenciesOrFn : maybeFn;\n\n  if (!fn) {\n    throw new TypeError(\n      \"[Injectable] Received invalid arguments. The factory function must be either the second \" + \"or third argument.\"\n    );\n  }\n\n  if (fn.length !== dependencies.length) {\n    throw new TypeError(\n      \"[Injectable] Function arity does not match the number of dependencies. Function has arity \" +\n        `${fn.length}, but ${dependencies.length} dependencies were specified.` +\n        `\\nDependencies: ${JSON.stringify(dependencies)}`\n    );\n  }\n\n  const factory = (...args: any[]) => fn(...args);\n  factory.token = token;\n  factory.dependencies = dependencies;\n  return factory;\n}\n\n/**\n * A compatibility version of {@link Injectable} for TypeScript 4 and earlier users.\n * This function behaves identically to {@link Injectable} but requires the use of `as const` on the dependencies array.\n *\n * @deprecated Use {@link Injectable} instead. This function is provided for compatibility with TypeScript 4\n * and earlier versions and will be removed in future releases.\n *\n * @see {@link Injectable} for detailed usage instructions and examples.\n */\nexport function InjectableCompat<\n  Token extends TokenType,\n  Tokens extends readonly TokenType[],\n  Params extends readonly any[],\n  Service,\n>(\n  token: Token,\n  dependencies: Tokens,\n  fn: (...args: Tokens[\"length\"] extends Params[\"length\"] ? Params : void[]) => Service\n): ReturnType<typeof Injectable> {\n  return Injectable(token, dependencies, fn);\n}\n\n/**\n * Creates an Injectable factory function for an InjectableClass.\n *\n * @example\n * ```ts\n * class Logger {\n *   static dependencies = [\"config\"] as const;\n *   constructor(private config: string) {}\n *   public print() {\n *     console.log(this.config);\n *   }\n * }\n *\n * const container = Container\n *   .providesValue(\"config\", \"value\")\n *   .provides(ClassInjectable(\"logger\", Logger));\n *\n * container.get(\"logger\").print(); // prints \"value\"\n * ```\n *\n * It is recommended to use the `Container.provideClass()` method. The example above is equivalent to:\n * ```ts\n * const container = Container\n *   .providesValue(\"config\", \"value\")\n *   .providesClass(\"logger\", Logger);\n * container.get(\"logger\").print(); // prints \"value\"\n * ```\n *\n * @param token Token identifying the Service.\n * @param cls InjectableClass to instantiate.\n */\nexport function ClassInjectable<\n  Class extends InjectableClass<any, any, any>,\n  Dependencies extends ConstructorParameters<Class>,\n  Token extends TokenType,\n  Tokens extends Class[\"dependencies\"],\n>(\n  token: Token,\n  cls: Class\n): InjectableFunction<ServicesFromTokenizedParams<Tokens, Dependencies>, Tokens, Token, ConstructorReturnType<Class>>;\n\nexport function ClassInjectable(\n  token: TokenType,\n  cls: InjectableClass<any, any, readonly TokenType[]>\n): InjectableFunction<any, readonly TokenType[], TokenType, any> {\n  const factory = (...args: any[]) => new cls(...args);\n  factory.token = token;\n  factory.dependencies = cls.dependencies;\n  return factory;\n}\n\n/**\n * Creates an Injectable factory function without dependencies that appends a Service\n * to an existing array of Services of the same type. Useful for dynamically expanding\n * service collections without altering original service tokens or factories.\n *\n * @example\n * ```ts\n * const container = Container\n *   .providesValue(\"values\", [1]) // Initially provide an array with one value\n *   .provides(ConcatInjectable(\"values\", () => 2)); // Append another value to the array\n *\n * const result = container.get(\"values\"); // Results in [1, 2]\n * ```\n *\n * In this context, `ConcatInjectable(\"values\", () => 2)` acts as a simplified form of\n * `Injectable(\"values\", [\"values\"], (values: number[]) => [...values, 2])`,\n * directly appending a new value to the \"values\" service array without the need for explicit array manipulation.\n *\n * @param token Token identifying an existing Service array to which the new Service will be appended.\n * @param fn A no-argument function that returns the service to be appended.\n */\nexport function ConcatInjectable<Token extends TokenType, Service>(\n  token: Token,\n  fn: () => Service\n): InjectableFunction<{ [T in keyof Token]: Service[] }, [], Token, Service[]>;\n\n/**\n * Creates an Injectable factory function with dependencies that appends a Service\n * to an existing array of Services of the same type. This variant supports services\n * that require other services to be instantiated, allowing for more complex setups.\n *\n * @example\n * ```ts\n * const container = Container\n *   .providesValue(\"two\", 2)\n *   .providesValue(\"values\", [1]) // Initially provide an array with one value\n *   .provides(ConcatInjectable(\"values\", [\"two\"] as const, (two: number) => two)); // Append another value to the array\n *\n * const result = container.get(\"values\"); // [1, 2]\n * ```\n *\n * @param token Token identifying an existing Service array to append the new Service to.\n * @param dependencies Read-only list of Tokens for dependencies required by the factory function.\n * @param fn Factory function returning the Service to append.\n * The types and number of its parameters must exactly match the dependencies.\n */\nexport function ConcatInjectable<\n  Token extends TokenType,\n  const Tokens extends readonly TokenType[],\n  Params extends readonly any[],\n  Service,\n>(\n  token: Token,\n  dependencies: Tokens,\n  fn: (...args: Tokens[\"length\"] extends Params[\"length\"] ? Params : void[]) => Service\n): InjectableFunction<ServicesFromTokenizedParams<Tokens, Params>, Tokens, Token, Service[]>;\n\nexport function ConcatInjectable(\n  token: TokenType,\n  dependenciesOrFn?: readonly TokenType[] | (() => any),\n  maybeFn?: (...args: any[]) => any\n): InjectableFunction<any, readonly TokenType[], TokenType, any[]> {\n  const dependencies: TokenType[] = Array.isArray(dependenciesOrFn) ? dependenciesOrFn : [];\n  const fn = typeof dependenciesOrFn === \"function\" ? dependenciesOrFn : maybeFn;\n\n  if (!fn) {\n    throw new TypeError(\n      \"[ConcatInjectable] Received invalid arguments. The factory function must be either the second \" +\n        \"or third argument.\"\n    );\n  }\n\n  if (fn.length !== dependencies.length) {\n    throw new TypeError(\n      \"[Injectable] Function arity does not match the number of dependencies. Function has arity \" +\n        `${fn.length}, but ${dependencies.length} dependencies were specified.` +\n        `\\nDependencies: ${JSON.stringify(dependencies)}`\n    );\n  }\n\n  const factory = (array: any[], ...args: any[]) => {\n    return array.concat(fn(...args));\n  };\n  factory.token = token;\n  factory.dependencies = [token, ...dependencies];\n  return factory;\n}\n\nexport type ConstructorReturnType<T> = T extends new (...args: any) => infer C ? C : any;\n"]}