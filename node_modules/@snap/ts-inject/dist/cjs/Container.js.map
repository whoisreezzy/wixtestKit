{"version":3,"file":"Container.js","sourceRoot":"","sources":["../../src/Container.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Memoized } from \"./memoize\";\nimport { isMemoized, memoize } from \"./memoize\";\nimport { PartialContainer } from \"./PartialContainer\";\nimport type { AddService, AddServices, InjectableClass, InjectableFunction, TokenType, ValidTokens } from \"./types\";\nimport { ClassInjectable, ConcatInjectable, Injectable } from \"./Injectable\";\nimport { entries } from \"./entries\";\n\ntype MaybeMemoizedFactories<Services> = {\n  [K in keyof Services]: (() => Services[K]) | Memoized<() => Services[K]>;\n};\n\ntype Factories<Services> = {\n  [K in keyof Services]: Memoized<() => Services[K]>;\n};\n\n/**\n * A special token used to resolve the entire container as a dependency.\n * This can be utilized when a service needs access to the container itself,\n * allowing for dynamic retrieval of other services.\n *\n * @example\n *\n * ```ts\n * const initial = Container.providesValue(\"value\", 1);\n * const extended = initial.provides(\n *   Injectable(\"service\", [CONTAINER], (container: typeof initial) => {\n *     return container.get(\"value\") + 1;\n *   })\n * );\n *\n * const result = extended.get(\"service\"); // 2\n * ```\n */\nexport const CONTAINER = \"$container\";\nexport type ContainerToken = typeof CONTAINER;\n\ntype ArrayElement<A> = A extends readonly (infer T)[] ? T : never;\n\n/**\n * Represents the dependency injection container that manages the registration,\n * creation, and retrieval of services. The Container class is central to\n * the dependency injection process, facilitating typesafe injection and\n * retrieval of services based on tokens.\n *\n * @example\n *\n * ```ts\n * const fooFactory = Injectable('Foo', () => new Foo())\n * const barFactory = Injectable('Bar', ['Foo'] as const, (foo: Foo) => new Bar(foo))\n * const container = Container.provides(fooFactory).provides(barFactory)\n *\n * const bar = container.get('Bar')\n * ```\n */\nexport class Container<Services = {}> {\n  /**\n   * Creates a new [Container] by providing a [PartialContainer] that has no dependencies.\n   *\n   * @example\n   * ```ts\n   * // Register a single service\n   * const container = Container.provides(Injectable('Logger', () => new Logger()));\n   *\n   * // Extend container with another container or partial container\n   * const extendedContainer = Container.provide(existingContainer);\n   * ```\n   */\n  static provides<Services>(container: PartialContainer<Services, {}> | Container<Services>): Container<Services>;\n\n  /**\n   * Creates a new [Container] by providing a Service that has no dependencies.\n   *\n   * @example\n   * ```ts\n   * // Register a single service with no dependencies\n   * const container = Container.provides(Injectable('Logger', () => new Logger()));\n   * ```\n   */\n  static provides<Token extends TokenType, Service>(\n    fn: InjectableFunction<{}, [], Token, Service>\n  ): Container<AddService<{}, Token, Service>>;\n\n  static provides(\n    fnOrContainer: InjectableFunction<{}, [], TokenType, any> | PartialContainer<any, {}> | Container<any>\n  ): Container<any> {\n    // Although the `provides` method has overloads that match both members of the union type separately, it does\n    // not match the union type itself, so the compiler forces us to branch and handle each type within the union\n    // separately. (Maybe in the future the compiler will decide to infer this, but for now this is necessary.)\n    if (fnOrContainer instanceof PartialContainer) return new Container({}).provides(fnOrContainer);\n    if (fnOrContainer instanceof Container) return new Container({}).provides(fnOrContainer);\n    return new Container({}).provides(fnOrContainer);\n  }\n\n  /**\n   * Registers a static value as a service in a new Container. Ideal for services that don't require\n   * instantiation or dependencies.\n\n   * NOTE: This method acts as a syntactic shortcut, essentially registering a factory function that\n   * directly returns the provided value.\n   *\n   * @example\n   * ```ts\n   * // Registering an instance of a class\n   * const logger = new Logger();\n   * const container = Container.providesValue('Logger', logger);\n   *\n   * // This is effectively a shortcut for the following, where an Injectable is explicitly created\n   * const container2 = Container.provides(Injectable('Logger', () => logger);\n   * ```\n   *\n   * @param token A unique Token identifying the service within the container. This token is used to retrieve the value.\n   * @param value The value or instance to register as a service within the container. This can be of any type.\n   * @returns A new Container instance with the specified service registered.\n   */\n  static providesValue<Token extends TokenType, Service>(\n    token: Token,\n    value: Service\n  ): Container<AddService<{}, Token, Service>> {\n    return new Container({}).providesValue(token, value);\n  }\n\n  /**\n   * Creates a new Container from a plain object containing service definitions.\n   * Each property of the object is treated as a unique token,\n   * and its corresponding value is registered in the Container as a service under that token.\n   * This method offers a convenient way to quickly bootstrap a container with predefined services.\n   *\n   * @example\n   * ```ts\n   * // Creating a container with simple value services\n   * const container = Container.fromObject({ foo: 1, bar: 'baz' });\n   *\n   * // Retrieving services from the container\n   * console.log(container.get('foo')); // prints 1\n   * console.log(container.get('bar')); // prints 'baz'\n   * ```\n   *\n   * In this example, `container` is of type `Container<{ foo: number, bar: string }>` indicating\n   * that it holds services under the tokens 'foo' and 'bar' with corresponding types.\n   *\n   * @param services A plain object where each property (token) maps to a service value. This object\n   * defines the initial set of services to be contained within the new Container instance.\n   * @returns A new Container instance populated with the provided services.\n   */\n  static fromObject<Services extends { [s: string]: any }>(services: Services): Container<Services> {\n    return entries(services).reduce(\n      (container, [token, value]) => container.providesValue(token, value),\n      new Container({})\n    ) as Container<Services>;\n  }\n\n  // this is public on purpose; if the field is declared as private generated *.d.ts files do not include the field type\n  // which makes typescript compiler behave differently when resolving container types; e.g. it becomes impossible to\n  // assign a container of type Container<{ a: number, b: string }> to a variable of type Container<{ a: number }>.\n  readonly factories: Readonly<Factories<Services>>;\n\n  constructor(factories: MaybeMemoizedFactories<Services>) {\n    const memoizedFactories = {} as Factories<Services>;\n    for (const k in factories) {\n      const fn = factories[k];\n      if (isMemoized(fn)) {\n        memoizedFactories[k] = fn;\n        // to allow overriding values in the container we replace the factory's reference to the container with the\n        // newly created one, this makes sure that overrides are taken into account when resolving the service's\n        // dependencies.\n        fn.thisArg = this;\n      } else {\n        memoizedFactories[k] = memoize(this, fn);\n      }\n    }\n    this.factories = memoizedFactories;\n  }\n\n  /**\n   * Creates a copy of this Container, optionally scoping specified services to the new copy.\n   * Unspecified services are shared between the original and copied containers,\n   * while factory functions for scoped services are re-invoked upon service resolution in the new container.\n   *\n   * This can be useful, for example, if different parts of an application wish to use the same Service interface,\n   * but do not want to share a reference to same Service instance.\n   *\n   * Consider an example where we have a `UserListService` that manages a list of users.\n   * If our application needs to display two user lists that can be edited independently\n   * (e.g., in separate components or pages), it would be beneficial to create a distinct Container\n   * for each list component. By scoping the `UserListService` to each Container,\n   * we ensure that each component receives its own independent copy of the service.\n   * This setup allows for independent edits to each user list without any overlap or\n   * interference between the two components.\n   *\n   * @example\n   * ```ts\n   * // Create the original container and provide the UserListService\n   * const originalContainer = Container.provides(Injectable('UserListService', () => new UserListService()));\n   *\n   * // Create a new Container copy with UserListService scoped, allowing for independent user lists\n   * const newListContainer = originalContainer.copy(['UserListService']);\n   *\n   * // Each Container now manages its own independent UserListService service instance\n   * ```\n   *\n   * @param scopedServices An optional list of tokens for Services to be scoped to the new Container copy. Services\n   * not specified will be shared with the original Container, while specified ones will be re-instantiated in the\n   * new Container.\n   * @returns A new Container copy that shares the original's services, with specified services scoped as unique\n   * instances to the new Container.\n   */\n  copy<Tokens extends readonly (keyof Services)[]>(scopedServices?: Tokens): Container<Services> {\n    const factories: MaybeMemoizedFactories<Services> = { ...this.factories };\n\n    // We \"un-memoize\" scoped Service InjectableFunctions so they will create a new copy of their Service when\n    // provided by the new Container – we re-memoize them so the new Container will itself only create one Service\n    // instance.\n    (scopedServices || []).forEach((token: keyof Services) => {\n      factories[token] = this.factories[token].delegate;\n    });\n    return new Container(factories);\n  }\n\n  /**\n   * Retrieves a reference to this Container.\n   *\n   * @param token The {@link CONTAINER} token.\n   * @returns This Container.\n   */\n  get(token: ContainerToken): this;\n\n  /**\n   * Retrieves a Service from the Container by its token.\n   * On first request, the service's factory function is invoked and the result is memoized for future requests,\n   * ensuring singleton behavior.\n   *\n   * @param token A unique token corresponding to a Service\n   * @returns A Service corresponding to the given Token.\n   */\n  get<Token extends keyof Services>(token: Token): Services[Token];\n\n  get(token: ContainerToken | keyof Services): this | Services[keyof Services] {\n    if (token === CONTAINER) return this;\n    const factory = this.factories[token];\n    if (!factory) {\n      throw new Error(\n        `[Container::get] Could not find Service for Token \"${String(token)}\". This should've caused a ` +\n          \"compile-time error. If the Token is 'undefined', check all your calls to the Injectable \" +\n          \"function. Make sure you define dependencies using string literals or string constants that are \" +\n          \"definitely initialized before the call to Injectable.\"\n      );\n    }\n    return factory();\n  }\n\n  /**\n   * Runs the factory functions for all services listed in the provided {@link PartialContainer},\n   * along with their dependencies that are registered within *this* container.\n   *\n   * This method is particularly useful for preemptively initializing services that require setup before use.\n   * It ensures that services are ready when needed without waiting for a lazy instantiation.\n   *\n   * **Note**: This method does not add new services to the container.\n   *\n   * @example\n   * ```ts\n   * // Create initializers for caching and reporting setup that depend on a request service\n   * const initializers = new PartialContainer({})\n   *   .provides(Injectable(\"initCache\", [\"request\"], (request: Request) => fetchAndPopulateCache(request)))\n   *   .provides(Injectable(\"setupReporter\", [\"request\"], (request: Request) => setupReporter(request)));\n   *\n   * // Setup the main container with a request service and run the initializers\n   * const container = Container\n   *   .provides(Injectable(\"request\", () => (url: string) => fetch(url)))\n   *   .run(initializers);\n   *\n   * // At this point, `initCache` and `setupReporter` have been executed using the `request` service.\n   * // And the `request` service itself has also been initialized within the `container`.\n   * ```\n   * @param container The {@link PartialContainer} specifying which services to initialize.\n   * @returns The current container unchanged, with dependencies of the services listed\n   * in the provided {@link PartialContainer} initialized as needed.\n   */\n  run<AdditionalServices, Dependencies, FulfilledDependencies extends Dependencies>(\n    // FullfilledDependencies is assignable to Dependencies -- by specifying Container<FulfilledDependencies> as the\n    // `this` type, we ensure this Container can provide all the Dependencies required by the PartialContainer.\n    this: Container<FulfilledDependencies>,\n    container: PartialContainer<AdditionalServices, Dependencies>\n  ): this;\n\n  /**\n   * Runs the factory function for a specified service provided by {@link InjectableFunction},\n   * along with its dependencies that are registered within *this* container.\n   *\n   * This method is particularly useful for services that need to be set up before they are used. It ensures that\n   * the service is ready when needed, without relying on lazy instantiation.\n   *\n   * **Note**: This method does not add new services to the container.\n   *\n   * @example\n   * ```ts\n   * // Setup a container with a request service and directly run the `initCache` service\n   * const container = Container\n   *   .provides(Injectable(\"request\", () => (url: string) => fetch(url)))\n   *   .run(Injectable(\"initCache\", [\"request\"], (request: Request) => fetchAndPopulateCache(request)));\n   *\n   * // At this point, `initCache` has been executed using the `request` service.\n   * // And the `request` service itself has also been initialized.\n   * ```\n   *\n   * @param fn The {@link InjectableFunction} specifying the service to initialize.\n   * @returns The current container unchanged, with dependencies of the provided {@link InjectableFunction}\n   * initialized as needed.\n   */\n  run<Token extends TokenType, Tokens extends readonly ValidTokens<Services>[], Service>(\n    fn: InjectableFunction<Services, Tokens, Token, Service>\n  ): this;\n\n  run<Token extends TokenType, Tokens extends readonly ValidTokens<Services>[], Service, AdditionalServices>(\n    fnOrContainer: InjectableFunction<Services, Tokens, Token, Service> | PartialContainer<AdditionalServices, Services>\n  ): this {\n    if (fnOrContainer instanceof PartialContainer) {\n      const runnableContainer = this.provides(fnOrContainer);\n      for (const token of fnOrContainer.getTokens()) {\n        runnableContainer.get(token);\n      }\n    } else {\n      this.provides(fnOrContainer).get(fnOrContainer.token);\n    }\n    return this;\n  }\n\n  /**\n   * Merges additional services from a given `PartialContainer` into this container,\n   * creating a new `Container` instance. Services defined in the `PartialContainer` take precedence\n   * in the event of token conflicts, meaning any service in the `PartialContainer` with the same token\n   * as one in this container will override the existing service.\n   *\n   * If the same `PartialContainer` is provided to multiple containers, each resulting container will have its own\n   * independent instance of the services defined in the `PartialContainer`, ensuring no shared state between them.\n   *\n   * @param container The `PartialContainer` that provides the additional services to be merged into this container.\n   *                  This container defines services and their dependencies that are to be integrated.\n   * @returns A new `Container` instance that combines the services of this container with those from the provided\n   *          `PartialContainer`, with services from the `PartialContainer` taking precedence in case of conflicts.\n   */\n  provides<AdditionalServices, Dependencies, FulfilledDependencies extends Dependencies>(\n    // FullfilledDependencies is assignable to Dependencies -- by specifying Container<FulfilledDependencies> as the\n    // `this` type, we ensure this Container can provide all the Dependencies required by the PartialContainer.\n    this: Container<FulfilledDependencies>,\n    container: PartialContainer<AdditionalServices, Dependencies>\n  ): Container<AddServices<Services, AdditionalServices>>;\n\n  /**\n   * Merges services from another `Container` into this container, creating a new `Container` instance.\n   * Services from the provided `Container` take precedence in the event of token conflicts.\n   *\n   * Importantly, services from the provided `Container` are shared between the original (source) container\n   * and the new (destination) container created by this method. This means that both containers will reference\n   * the same service instances, ensuring consistency but not isolation.\n   *\n   * If isolation is required (i.e., separate instances of the services in different containers), the source\n   * container should be copied before being passed to this method. This ensures that new instances of the\n   * services are created in the new container, avoiding shared state issues.\n   *\n   * @param container The `Container` that provides the additional services to be merged.\n   * @returns A new `Container` instance that combines services from this container with those from the\n   *          provided container, with services from the provided container taking precedence in case of conflicts.\n   */\n  provides<AdditionalServices>(\n    container: Container<AdditionalServices>\n  ): Container<AddServices<Services, AdditionalServices>>;\n\n  /**\n   * Registers a new service in this Container using an `InjectableFunction`. This function defines how the service\n   * is created, including its dependencies and the token under which it will be registered. When called, this method\n   * adds the service to the container, ready to be retrieved via its token.\n   *\n   * The `InjectableFunction` must specify:\n   * - A unique `Token` identifying the service.\n   * - A list of `Tokens` representing the dependencies needed to create the service.\n   *\n   * This method ensures type safety by verifying that all required dependencies are available in the container\n   * and match the expected types. If a dependency is missing or a type mismatch occurs, a compiler error is raised,\n   * preventing runtime errors and ensuring reliable service creation.\n   *\n   * @param fn The `InjectableFunction` that constructs the service. It should take required dependencies as arguments\n   * and return the newly created service.\n   * @returns A new `Container` instance containing the added service, allowing chaining of multiple `provides` calls.\n   */\n  provides<Token extends TokenType, Tokens extends readonly ValidTokens<Services>[], Service>(\n    fn: InjectableFunction<Services, Tokens, Token, Service>\n  ): Container<AddService<Services, Token, Service>>;\n\n  provides<Token extends TokenType, Tokens extends readonly ValidTokens<Services>[], Service, AdditionalServices>(\n    fnOrContainer:\n      | InjectableFunction<Services, Tokens, Token, Service>\n      | PartialContainer<AdditionalServices, Services>\n      | Container<AdditionalServices>\n  ): Container<any> {\n    if (fnOrContainer instanceof PartialContainer || fnOrContainer instanceof Container) {\n      const factories =\n        fnOrContainer instanceof PartialContainer ? fnOrContainer.getFactories(this) : fnOrContainer.factories;\n      // Safety: `this.factories` and `factories` are both properly type checked, so merging them produces\n      // a Factories object with keys from both Services and AdditionalServices. The compiler is unable to\n      // infer that Factories<A> & Factories<B> == Factories<A & B>, so the cast is required.\n      return new Container({\n        ...this.factories,\n        ...factories,\n      } as unknown as MaybeMemoizedFactories<AddServices<Services, AdditionalServices>>);\n    }\n    return this.providesService(fnOrContainer);\n  }\n\n  /**\n   * Registers a service in the container using a class constructor, simplifying the service creation process.\n   *\n   * This method is particularly useful when the service creation logic can be encapsulated within a class\n   * constructor.\n   *\n   * @param token A unique Token used to identify and retrieve the service from the container.\n   * @param cls A class with a constructor that takes dependencies as arguments and a static `dependencies` field\n   *            specifying these dependencies.\n   * @returns A new Container instance containing the newly created service, allowing for method chaining.\n   */\n  providesClass = <Token extends TokenType, Service, Tokens extends readonly ValidTokens<Services>[]>(\n    token: Token,\n    cls: InjectableClass<Services, Service, Tokens>\n  ): Container<AddService<Services, Token, Service>> =>\n    this.providesService(ClassInjectable(token, cls)) as Container<AddService<Services, Token, Service>>;\n\n  /**\n   * Registers a static value as a service in the container. This method is ideal for services that do not\n   * require dynamic instantiation and can be provided directly as they are.\n   *\n   * @param token A unique Token used to identify and retrieve the service from the container.\n   * @param value The actual value to register as a service. This could be anything from a simple data object,\n   *              a configuration, or a pre-instantiated service object.\n   * @returns A new Container instance that includes the provided service, allowing for chaining additional\n   *          `provides` calls.\n   */\n  providesValue = <Token extends TokenType, Service>(\n    token: Token,\n    value: Service\n  ): Container<AddService<Services, Token, Service>> => this.providesService(Injectable(token, [], () => value));\n\n  /**\n   * Appends a value to the array associated with a specified token in the current Container, then returns\n   * the new Container with the updated value. This method is applicable under the following conditions:\n   *  1. The Container already contains an array associated with the given token.\n   *  2. The type of the items in the array matches the type of the value being appended.\n   *\n   * ```ts\n   * const container = Container.fromObject({ services: [1, 2, 3] as number[] });\n   * const newContainer = container.appendValue('services', 4);\n   * console.log(newContainer.get('services')); // prints [1, 2, 3, 4];\n   * ```\n   *\n   * @param token - A unique Token which will correspond to the previously defined typed array.\n   * @param value - A value to append to the array.\n   * @returns The updated Container with the appended value in the specified array.\n   */\n  appendValue = <Token extends keyof Services, Service extends ArrayElement<Services[Token]>>(\n    token: Token,\n    value: Service\n  ): Container<Services> => this.providesService(ConcatInjectable(token, () => value)) as Container<Services>;\n\n  /**\n   * Appends an injectable class factory to the array associated with a specified token in the current Container,\n   * then returns the new Container with the updated value. This method is applicable under the following conditions:\n   *  1. The Container already contains an array associated with the given token.\n   *  2. The type of the items in the array matches the type of the value being appended.\n   *\n   * ```ts\n   * const container = Container.fromObject({ services: [] as Service[] });\n   * const newContainer = container.appendClass('services', Service);\n   * console.log(newContainer.get('services').length); // prints 1;\n   *\n   * @param token - A unique Token which will correspond to the previously defined typed array.\n   * @param cls - A class with a constructor that takes dependencies as arguments, which returns the Service.\n   * @returns The updated Container with the new service instance appended to the specified array.\n   */\n  appendClass = <\n    Token extends keyof Services,\n    Tokens extends readonly ValidTokens<Services>[],\n    Service extends ArrayElement<Services[Token]>,\n  >(\n    token: Token,\n    cls: InjectableClass<Services, Service, Tokens>\n  ): Container<Services> =>\n    this.providesService(\n      ConcatInjectable(token, () => this.providesClass(token, cls).get(token))\n    ) as Container<Services>;\n\n  /**\n   * Appends a new service instance to an existing array within the container using an `InjectableFunction`.\n   *\n   * @example\n   * ```ts\n   * // Assume there's a container with an array ready to hold service instances\n   * const container = Container.fromObject({ services: [] as Service[] });\n   * // Append a new Service instance to the 'services' array using a factory function\n   * const newContainer = container.append(Injectable('services', () => new Service()));\n   * // Retrieve the services array to see the added Service instance\n   * console.log(newContainer.get('services').length); // prints 1;\n   * ```\n   *\n   * @param fn - An injectable function that returns the Service.\n   * @returns The updated Container, now including the new service instance appended to the array\n   * specified by the token.\n   */\n  append = <\n    Token extends keyof Services,\n    Tokens extends readonly ValidTokens<Services>[],\n    Service extends ArrayElement<Services[Token]>,\n  >(\n    fn: InjectableFunction<Services, Tokens, Token, Service>\n  ): Container<Services> =>\n    this.providesService(\n      ConcatInjectable(fn.token, () => this.providesService(fn).get(fn.token))\n    ) as Container<Services>;\n\n  private providesService<\n    Token extends TokenType,\n    Tokens extends readonly ValidTokens<Services>[],\n    Service,\n    Dependencies,\n  >(fn: InjectableFunction<Dependencies, Tokens, Token, Service>): Container<AddService<Services, Token, Service>> {\n    const token = fn.token;\n    const dependencies: readonly any[] = fn.dependencies;\n    // If the service depends on itself, e.g. in the multi-binding case, where we call append multiple times with\n    // the same token, we always must resolve the dependency using the parent container to avoid infinite loop.\n    const getFromParent = dependencies.indexOf(token) === -1 ? undefined : () => this.get(token as any);\n    const factory = memoize(this, function (this: Container<Services>) {\n      // Safety: getFromParent is defined if the token is in the dependencies list, so it is safe to call it.\n      return fn(...(dependencies.map((t) => (t === token ? getFromParent!() : this.get(t))) as any));\n    });\n    // Safety: `token` and `factory` are properly type checked, so extending `this.factories` produces a\n    // MaybeMemoizedFactories object with the expected set of services – but when using the spread operation to\n    // merge two objects, the compiler widens the Token type to string. So we must re-narrow via casting.\n    const factories = { ...this.factories, [token]: factory };\n    return new Container(factories) as Container<AddService<Services, Token, Service>>;\n  }\n}\n"]}