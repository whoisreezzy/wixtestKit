{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { Container, ContainerToken } from \"./Container\";\n\ntype AsTuple<T> = T extends readonly any[] ? T : never;\n\ntype CorrespondingService<Services, Token extends ValidTokens<Services>> = Token extends ContainerToken\n  ? Container<Services>\n  : Token extends keyof Services\n    ? Services[Token]\n    : never;\n\n/**\n * Token type for associating services in a container, supporting strings, numbers, or symbols.\n */\nexport type TokenType = string | number | symbol;\n\n/**\n * Given a Services object, the valid Tokens are simply the keys of that object or the special Container Token.\n */\nexport type ValidTokens<Services> = ContainerToken | keyof Services;\n\n/**\n * Given Services, map from a list of Tokens to a list of Service types.\n */\nexport type CorrespondingServices<Services, Tokens extends readonly ValidTokens<Services>[]> = {\n  [K in keyof Tokens]: Tokens[K] extends ValidTokens<Services> ? CorrespondingService<Services, Tokens[K]> : never;\n};\n\n/**\n * A valid `InjectableFunction` is one that can be successfully called, given some Services, to return a new Service.\n * That is, it must satisfy two conditions:\n *\n *   1. All the Tokens it specifies as dependencies are valid given the Services (i.e. they are either the Container\n *   Token or keys of the Services type).\n *   2. The function argument types correspond to the Services specified by the dependency Tokens.\n *\n * A `InjectableFunction` also includes its own key Token and dependency Tokens as metadata, so it may be resolved by\n * Container<Services> later.\n */\nexport type InjectableFunction<\n  Services,\n  Tokens,\n  Token extends TokenType,\n  Service,\n> = Tokens extends readonly ValidTokens<Services>[]\n  ? {\n      (...args: AsTuple<CorrespondingServices<Services, Tokens>>): Service;\n      token: Token;\n      dependencies: Tokens;\n    }\n  : never;\n\n/**\n * Represents a class that can be used as an injectable service within a dependency injection {@link Container}.\n * The `InjectableClass` type ensures that the class's dependencies and constructor signature align with\n * the services available in the container, providing strong type safety.\n */\nexport type InjectableClass<Services, Service, Tokens> = Tokens extends readonly ValidTokens<Services>[]\n  ? {\n      readonly dependencies: Tokens;\n      new (...args: AsTuple<CorrespondingServices<Services, Tokens>>): Service;\n    }\n  : never;\n\nexport type AnyInjectable = InjectableFunction<any, readonly TokenType[], TokenType, any>;\n\n/**\n * Maps an array of {@link InjectableFunction} to a service type object, where each key is the token of an\n * {@link Injectable}, and the corresponding value is the return type of that {@link Injectable}.\n *\n * This utility type is useful for deriving the service types provided by a collection of {@link InjectableFunction}s,\n * ensuring type safety and consistency throughout your application.\n *\n * You can use `ServicesFromInjectables` to construct a type that serves as a type parameter for a {@link Container},\n * allowing the container's type to accurately reflect the services it provides,\n * even before the container is constructed.\n *\n * @typeParam Injectables - A tuple of {@link InjectableFunction}s.\n *\n * @example\n * // Define some Injectable functions\n * const injectable1 = Injectable(\"Service1\", () => \"service1\");\n * const injectable2 = Injectable(\"Service2\", () => 42);\n *\n * // Collect them in a tuple\n * const injectables = [injectable1, injectable2] as const;\n *\n * // Use ServicesFromInjectables to derive the services' types\n * type Services = ServicesFromInjectables<typeof injectables>;\n *\n * // Services type is equivalent to:\n * // {\n * //   Service1: string;\n * //   Service2: number;\n * // }\n *\n * // Declare a container variable with the derived Services type\n * // This allows us to reference the container with accurate typing before it's constructed,\n * // ensuring type safety and enabling its use in type annotations elsewhere\n * let container: Container<Services>;\n *\n * // Assign the container with the actual instance\n * container = Container.provides(injectable1).provides(injectable2);\n */\nexport type ServicesFromInjectables<Injectables extends readonly AnyInjectable[]> = {\n  [Name in Injectables[number][\"token\"]]: ReturnType<Extract<Injectables[number], { token: Name }>>;\n};\n\n/**\n * Add a Service with a Token to an existing set of Services.\n */\n// Using a conditional type forces TS language services to evaluate the type -- so when showing e.g. type hints, we\n// will see the mapped type instead of the AddService type alias. This produces better hints.\nexport type AddService<ParentServices, Token extends TokenType, Service> = ParentServices extends any\n  ? // A mapped type produces better, more concise type hints than an intersection type.\n    {\n      [K in keyof ParentServices | Token]: K extends keyof ParentServices\n        ? K extends Token\n          ? Service\n          : ParentServices[K]\n        : Service;\n    }\n  : never;\n\n/**\n * Same as AddService above, but is merging multiple services at once. Services types override those of the parent.\n */\n// Using a conditional type forces TS language services to evaluate the type -- so when showing e.g. type hints, we\n// will see the mapped type instead of the AddService type alias. This produces better hints.\nexport type AddServices<ParentServices, Services> = ParentServices extends any\n  ? Services extends any\n    ? {\n        [K in keyof Services | keyof ParentServices]: K extends keyof Services\n          ? Services[K]\n          : K extends keyof ParentServices\n            ? ParentServices[K]\n            : never;\n      }\n    : never\n  : never;\n\n/**\n * Create an object type from two tuples of the same length. The first tuple contains the object keys and the\n * second contains the value types corresponding to those keys.\n *\n * Ex:\n * ```ts\n * type FooBar = ServicesFromTokenizedParams<['foo', 'bar'], [string, number]>\n * const foobar: FooBar = {foo: 'foo', bar: 1}\n * const badfoobar: FooBar = {foo: 1, bar: 'bar'} // any extra, missing, or mis-typed properties raise an error.\n * ```\n */\nexport type ServicesFromTokenizedParams<Tokens, Params> = Tokens extends readonly []\n  ? Params extends readonly []\n    ? {}\n    : never\n  : Tokens extends readonly [infer Token, ...infer RemainingTokens]\n    ? Params extends readonly [infer Param, ...infer RemainingParams]\n      ? Tokens[\"length\"] extends Params[\"length\"]\n        ? Token extends ContainerToken\n          ? Param extends Container<infer S>\n            ? S & ServicesFromTokenizedParams<RemainingTokens, RemainingParams>\n            : never\n          : Token extends TokenType\n            ? { [K in Token]: Param extends Container<infer S> ? S : Param } & ServicesFromTokenizedParams<\n                RemainingTokens,\n                RemainingParams\n              >\n            : never\n        : never\n      : never\n    : never;\n"]}