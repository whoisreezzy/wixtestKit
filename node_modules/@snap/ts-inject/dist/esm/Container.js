import { isMemoized, memoize } from "./memoize";
import { PartialContainer } from "./PartialContainer";
import { ClassInjectable, ConcatInjectable, Injectable } from "./Injectable";
import { entries } from "./entries";
export const CONTAINER = "$container";
export class Container {
    static provides(fnOrContainer) {
        if (fnOrContainer instanceof PartialContainer)
            return new Container({}).provides(fnOrContainer);
        if (fnOrContainer instanceof Container)
            return new Container({}).provides(fnOrContainer);
        return new Container({}).provides(fnOrContainer);
    }
    static providesValue(token, value) {
        return new Container({}).providesValue(token, value);
    }
    static fromObject(services) {
        return entries(services).reduce((container, [token, value]) => container.providesValue(token, value), new Container({}));
    }
    factories;
    constructor(factories) {
        const memoizedFactories = {};
        for (const k in factories) {
            const fn = factories[k];
            if (isMemoized(fn)) {
                memoizedFactories[k] = fn;
                fn.thisArg = this;
            }
            else {
                memoizedFactories[k] = memoize(this, fn);
            }
        }
        this.factories = memoizedFactories;
    }
    copy(scopedServices) {
        const factories = { ...this.factories };
        (scopedServices || []).forEach((token) => {
            factories[token] = this.factories[token].delegate;
        });
        return new Container(factories);
    }
    get(token) {
        if (token === CONTAINER)
            return this;
        const factory = this.factories[token];
        if (!factory) {
            throw new Error(`[Container::get] Could not find Service for Token "${String(token)}". This should've caused a ` +
                "compile-time error. If the Token is 'undefined', check all your calls to the Injectable " +
                "function. Make sure you define dependencies using string literals or string constants that are " +
                "definitely initialized before the call to Injectable.");
        }
        return factory();
    }
    run(fnOrContainer) {
        if (fnOrContainer instanceof PartialContainer) {
            const runnableContainer = this.provides(fnOrContainer);
            for (const token of fnOrContainer.getTokens()) {
                runnableContainer.get(token);
            }
        }
        else {
            this.provides(fnOrContainer).get(fnOrContainer.token);
        }
        return this;
    }
    provides(fnOrContainer) {
        if (fnOrContainer instanceof PartialContainer || fnOrContainer instanceof Container) {
            const factories = fnOrContainer instanceof PartialContainer ? fnOrContainer.getFactories(this) : fnOrContainer.factories;
            return new Container({
                ...this.factories,
                ...factories,
            });
        }
        return this.providesService(fnOrContainer);
    }
    providesClass = (token, cls) => this.providesService(ClassInjectable(token, cls));
    providesValue = (token, value) => this.providesService(Injectable(token, [], () => value));
    appendValue = (token, value) => this.providesService(ConcatInjectable(token, () => value));
    appendClass = (token, cls) => this.providesService(ConcatInjectable(token, () => this.providesClass(token, cls).get(token)));
    append = (fn) => this.providesService(ConcatInjectable(fn.token, () => this.providesService(fn).get(fn.token)));
    providesService(fn) {
        const token = fn.token;
        const dependencies = fn.dependencies;
        const getFromParent = dependencies.indexOf(token) === -1 ? undefined : () => this.get(token);
        const factory = memoize(this, function () {
            return fn(...dependencies.map((t) => (t === token ? getFromParent() : this.get(t))));
        });
        const factories = { ...this.factories, [token]: factory };
        return new Container(factories);
    }
}
//# sourceMappingURL=Container.js.map